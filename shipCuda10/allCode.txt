D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\athor_doc\Athor.java

package ua.edu.donntu.cs.athor_doc;

import java.awt.Dimension;
import java.awt.Font;
import java.awt.Toolkit;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.UIManager;

import ua.edu.donntu.cs.service.CalcStrings;

/**
 * Класс для отображения информации об авторе и проекте
 * 
 * @author Denis Vodolazskiy
 */
public class Athor extends JFrame {
	/**
	 * Конструктор, создаёт окно, добавляет информацию и ссылку
	 */
	public Athor() {
		super("Об авторе:");
		// System Look-And-Feel:
		try {
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (Exception e) {
			// Exception handle
		}
		JPanel panel = new JPanel();
		panel.setLayout(null);
		setSize(280, 200); // задание размеров
		setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); // задание параметров //
														// главного окна при
														// закрытии
		Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();
		int width = getSize().width;
		int height = getSize().height;
		int x = (dim.width - width) / 2;
		int y = (dim.height - height) / 2;
		setLocation(x, y);

		JLabel jl2 = new JLabel(
				"<html>ДонНТУ, кафедра компьютерной инженерии,"
						+ "	группа КСм-12</html>");
		Font font = new Font(Font.SANS_SERIF, 1, 13);
		jl2.setFont(font);
		jl2.setSize(250, 60);
		jl2.setLocation(30, 10);
		
		font = new Font(Font.MONOSPACED, 1, 16);			
		JLabel jl1 = new JLabel();
		jl1.setFont(font);
		makeLink(jl1, "Денис Водолазский",
				"http://masters.donntu.edu.ua/2013/fknt/vodolazskiy/");
		jl1.setSize(280, 30);
		jl1.setLocation(0, 70);
		jl1.setHorizontalAlignment(0);
		
		CalcStrings cs=new CalcStrings();
		JLabel jl3 = new JLabel(
				"<html>Количество файлов: "+cs.getFilesNumber()
						+ "<br>Количество строк кода: "+cs.getCount()+"</html>");
		font = new Font(Font.SANS_SERIF, 1, 13);
		jl3.setFont(font);
		jl3.setSize(250, 60);
		jl3.setLocation(30, 100);
		
		panel.add(jl2);
		panel.add(jl1);
		panel.add(jl3);
		setResizable(false);
		setVisible(true);
		setContentPane(panel);
	}
/**
 * Создаёт ссылку в метке
 * @param jl метка
 * @param name текст ссылки
 * @param address ссылка
 */
	private void makeLink(JLabel jl, String name, final String address) {
		// Чтобы JLabel выглядел как полноценная гиперссылка
		jl.setText("<html><a href=\"#\">" + name + "</a></html>");
		// Чтобы JLabel выглядел как полноценная гиперссылка при наведении
		// курсора мыши
		jl.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
		// Переопределяем MouseListener
		jl.addMouseListener(new java.awt.event.MouseAdapter() {
			@Override
			public void mouseClicked(java.awt.event.MouseEvent evt) {
				try {
					// Запускаем браузер по-умолчанию и открываем в нем нужную
					// страницу
					java.awt.Desktop.getDesktop().browse(new URI(address));
				} catch (IOException ex) {
					ex.printStackTrace();
				} catch (URISyntaxException ex) {
					ex.printStackTrace();
				}
			}
		});
	}

}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\athor_doc\Documents.java

package ua.edu.donntu.cs.athor_doc;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;

import ua.edu.donntu.cs.cuda.exception.PrintExceptionShortStack;
/**
 * Класс для отображения документации в браузере
 * 
 * @author Denis Vodolazskiy
 */
public class Documents {
	/**
	 * Конструктор, открывает файл "/doc/index.html" в браузере по умолчанию
	 */
	public Documents() {
		try {
			// Запускаем браузер по-умолчанию и открываем в нем нужную
			// страницу
			URL url;
			url = getClass().getResource("/doc/index.html");
			// System.out.println("url = "+url);
			java.awt.Desktop.getDesktop().browse(url.toURI());

		} catch (IOException ex) {
			new PrintExceptionShortStack(ex);
		} catch (URISyntaxException ex) {
			new PrintExceptionShortStack(ex);
		}
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\compare_frame\CPUandGPUCompareFrame.java

package ua.edu.donntu.cs.cuda.compare_frame;

/**
 * Класс для вызова заставки при запуске построения графика сравнения значений времени выполнения на GPU и CPU  
 * 
 * @author Denis Vodolazskiy
 */

import java.awt.Dimension;
import java.awt.Toolkit;

import javax.swing.JFrame;
import javax.swing.UIManager;

import ua.edu.donntu.cs.cuda.exception.InitCuda;
import ua.edu.donntu.cs.cuda.kutt.full_engine_many.ParallelFullCalcCuda;
import ua.edu.donntu.cs.cuda.kutt.test_time.SerialSpeedCalc;
import ua.edu.donntu.cs.inout.LoadTimeValues;
import ua.edu.donntu.cs.inout.QuantityOfStringsInFile;
import ua.edu.donntu.cs.inout.WriteToFile;

public class CPUandGPUCompareFrame extends JFrame {
	/**
	 * Панель для размещения компонентов
	 */
	private PaintCompare panel;

	/**
	 * Конструктор, задаёт расположение окна и его свойства. Принимает данные,
	 * проверяет, являются ли данные новыми. Если да, то заново рассчитывает
	 * время выполнения и записывает результат в текстовый файл. Если нет, то
	 * читает данные из текстового файла. Затем строит график. Перед выполнением
	 * рассчётов проверяет наличие видеокарты
	 */
	public CPUandGPUCompareFrame() {
		super("Сравнение времени выполнения на CPU и GPU:");
		// System Look-And-Feel:
		try {
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (Exception e) {
			// Exception handle
		}
		int nShips = 144;// any value, not big //20_000 for
		// ParallelSpeedCalcCuda, 3200 for
		// ParallelFullCalcCuda
		final int size = 8_000;// define size in cu-file.size=8000,
		float timesGPU[] = new float[nShips + 1];
		float timesCPU[] = new float[nShips + 1];
		final String nameGPU = "timesGPU.txt";
		final String nameCPU = "timesCPU.txt";

		int stringQuantatyGPU = 0;
		stringQuantatyGPU = new QuantityOfStringsInFile()
				.quantityOfStringsTime(nameGPU);
		int stringQuantatyCPU = 0;
		stringQuantatyCPU = new QuantityOfStringsInFile()
				.quantityOfStringsTime(nameCPU);

		if ((stringQuantatyGPU == nShips + 1)
				&& (stringQuantatyCPU == nShips + 1)) {
			timesGPU = new LoadTimeValues().loadTimes(nameGPU);
			timesCPU = new LoadTimeValues().loadTimes(nameCPU);
		} else {
			if (new InitCuda().isPresent()) {// check GPU
				for (int i = 1; i < nShips + 1; i++) {
					timesGPU[i] = new ParallelFullCalcCuda(i, size)
							.getEl_time();
					timesCPU[i] = new SerialSpeedCalc(i, size).getTimeout();
				}
				new WriteToFile(timesGPU, nameGPU);
				new WriteToFile(timesCPU, nameCPU);
			}
		}

		panel = new PaintCompare("ships", "time, ms", timesGPU, timesCPU, 1, 1);
		panel.setLayout(null);
		setSize(700, 500); // задание размеров
		setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); // задание параметров
															// // главного окна
															// при закрытии

		Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();
		int width = getSize().width;
		int height = getSize().height;
		int x = (dim.width - width) / 2;
		int y = (dim.height - height) / 2;
		setLocation(x, y);

		//
		setResizable(false);
		setVisible(true);
		setContentPane(panel);
	}

}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\compare_frame\PaintCompare.java

package ua.edu.donntu.cs.cuda.compare_frame;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;

import javax.swing.JPanel;

/**
 * Панель сравнения времени выполнения на GPU и CPU
 * 
 * @author Denis Vodolazskiy
 */
public class PaintCompare extends JPanel {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private int divScaleByX = 1;
	private int divScaleByY = 1;
	private int xMagnitude = 1;
	private int yMagnitude = 3000;
	// private float valX[];
	private float valY[];
	private float valY2[];
	private String xAxisName = "";
	private String yAxisName = "";
	// private int divideForRealModelingTime = 1;
	private Color c1 = new Color(0).CYAN;
	private Color c2 = new Color(0).RED;

	/**
	 * Конструктор, принимает параметры
	 * 
	 * @param xAxisName
	 *            подпись по оси X
	 * @param yAxisName
	 *            подпись по оси Y
	 * @param valY
	 *            массив значений первой легенды (GPU)
	 * @param valY2
	 *            массив значений первой легенды (CPU)
	 * @param divScaleByX
	 *            делитель значений по оси X
	 * @param divScaleByY
	 *            делитель значений по оси Y
	 */
	public PaintCompare(String xAxisName, String yAxisName, float valY[],
			float valY2[], int divScaleByX, int divScaleByY) {
		this.xAxisName = xAxisName;
		this.yAxisName = yAxisName;
		this.valY = valY;
		this.valY2 = valY2;
		this.divScaleByX = divScaleByX;
		this.divScaleByY = divScaleByY;
		xMagnitude = valY.length;
	}

	/**
	 * Выполняет перерисовку окна
	 */
	public void paint(Graphics g) {
		Graphics2D g2 = (Graphics2D) g;
		drawAxis(g2);
		BasicStroke pen1 = new BasicStroke(2);
		g2.setStroke(pen1);
		// g2.setColor(Color.CYAN);
		drawLegend(g2);
	}

	/**
	 * Выполняет отрисовку осей
	 */
	private void drawAxis(Graphics2D g2) {
		Color c = new Color(187, 187, 187);
		g2.setColor(c);
		g2.fillRect(0, 0, this.getWidth(), this.getHeight());
		//
		g2.setColor(c1);
		g2.drawString("GPU", this.getWidth() - 80, this.getHeight() / 2 + 60);
		g2.setColor(c2);
		g2.drawString("CPU", this.getWidth() - 40, this.getHeight() / 2 + 60);
		//
		g2.setColor(Color.black);
		g2.drawString(xAxisName, this.getWidth() - 40,
				this.getHeight() / 2 + 40);
		g2.drawString(yAxisName, 60, 10);
		if (divScaleByY != 1) {
			g2.drawString("* " + divScaleByY, 60, 25);
		}
		if (divScaleByX != 1) {
			g2.drawString("/" + divScaleByX, this.getWidth() - 20,
					this.getHeight() / 2 - 35);
		}
		//
		g2.setColor(Color.blue);
		g2.drawLine(0, this.getHeight() / 2, this.getWidth(),
				this.getHeight() / 2);
		g2.drawLine(0, this.getHeight(), 0, 0);
		float k = this.getWidth();
		k /= xMagnitude;
		for (int i = 0, x = 0; i < xMagnitude + 1; i++, x = (int) (i * k)) {
			if (i % 1 == 0) {// 1
				g2.drawLine(x, this.getHeight() / 2 + 3, x,
						this.getHeight() / 2 - 3);
			}
			if (i % 10 == 0) {// 10
				g2.drawLine(x, this.getHeight() / 2 + 10, x,
						this.getHeight() / 2 - 10);
			} else if (i % 5 == 0) {
				g2.drawLine(x, this.getHeight() / 2 + 5, x,
						this.getHeight() / 2 - 5);
			}
			if (i % 5 == 0) {// 5
				g2.drawString("" + i, x - 4, this.getHeight() / 2 + 23);
			}
		}
		//
		float m = this.getHeight();
		m /= yMagnitude;
		for (int i = 0, x = 0; i < yMagnitude / 2 + 1; i++, x = (int) (i * m)) {
			// g2.drawLine(3, x + this.getHeight() / 2, - 3, x +
			// this.getHeight() / 2);
			if (i % 200 == 0) {
				g2.drawLine(10, x + this.getHeight() / 2, -10,
						x + this.getHeight() / 2);
			} else if (i % 100 == 0) {
				g2.drawLine(5, x + this.getHeight() / 2, -5,
						x + this.getHeight() / 2);
			}
			if (i % 100 == 0 && i != 0) {// second 0
				g2.drawString("-" + i, 27, x + this.getHeight() / 2);
			}
		}
		for (int i = 0, x = 0; i < yMagnitude / 2 + 1; i++, x = (int) (i * m)) {
			// g2.drawLine(3, -x + this.getHeight() / 2, - 3, -x +
			// this.getHeight() / 2);
			if (i % 200 == 0) {
				g2.drawLine(10, -x + this.getHeight() / 2, -10,
						-x + this.getHeight() / 2);
			} else if (i % 100 == 0) {
				g2.drawLine(+5, -x + this.getHeight() / 2, -5,
						-x + this.getHeight() / 2);
			}
			if (i % 100 == 0) {
				g2.drawString("" + i, 27, -x + this.getHeight() / 2);
			}
		}
	}

	/**
	 * Выполняет отрисовку легенд
	 */
	private void drawLegend(Graphics g2) {

		float k = this.getWidth();
		k = (k / xMagnitude);
		float displ = 0;
		float m = this.getHeight();
		m = (m / yMagnitude);
		//
		// assert (valY.length >= xMagnitude);

		for (int i = 1; i < xMagnitude; i++) {
			g2.setColor(c1);
			g2.drawLine(
					(int) (displ + k * (i - 1) / divScaleByX),
					(int) (this.getHeight() / 2 - valY[i - 1] * m / divScaleByY),
					(int) (displ + k * i / divScaleByX),
					(int) (this.getHeight() / 2 - valY[i] * m / divScaleByY));
			g2.setColor(c2);
			g2.drawLine((int) (displ + k * (i - 1) / divScaleByX),
					(int) (this.getHeight() / 2 - valY2[i - 1] * m
							/ divScaleByY),
					(int) (displ + k * i / divScaleByX),
					(int) (this.getHeight() / 2 - valY2[i] * m / divScaleByY));
		}
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\exception\InitCuda.java

package ua.edu.donntu.cs.cuda.exception;

import static jcuda.driver.JCudaDriver.cuDeviceGetCount;
import static jcuda.driver.JCudaDriver.cuInit;

/**
 * инициализация GPU. При отсутствии видеокарты бросает исключение
 * 
 * @author Denis Vodolazskiy
 */
public class InitCuda {
	private boolean present = true;

	/**
	 * Конструктор инициализации GPU. При отсутствии видеокарты вызывает
	 * диалоговое окно
	 * 
	 */
	public InitCuda() {
		try {
			doInit();
		} catch (MyCudaException ce) {
			present = false;
			javax.swing.JOptionPane.showMessageDialog(
					(java.awt.Component) null, "Error: " + ce.getMessage(),
					"Error:", javax.swing.JOptionPane.DEFAULT_OPTION);
		}
	}

	/**
	 * Выполняет инициализацию GPU
	 * 
	 * @throws MyCudaException
	 *             при отсутствии видеокарты
	 */
	private static void doInit() throws MyCudaException {
		try {
			cuInit(0);
			// Obtain the number of devices
			int deviceCountArray[] = { 0 };
			cuDeviceGetCount(deviceCountArray);
			int deviceCount = deviceCountArray[0];
			if (deviceCount == 0) {
				throw new MyCudaException("CUDA-device not found");
			} else {
				// System.out.println("Found " + deviceCount + " devices");
			}
		} catch (Exception e) {
			// e.printStackTrace();
			new PrintExceptionShortStack(e);
			throw e;
		}
	}

	/**
	 * Сигнализирует о статусе GPU
	 * 
	 * @return true or false
	 */
	public boolean isPresent() {
		return present;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\exception\MyCudaException.java

package ua.edu.donntu.cs.cuda.exception;

/**
 * Собственное исключение для GPU
 * 
 * @author Denis Vodolazskiy
 */
public class MyCudaException extends Exception {
	public MyCudaException(String msg) {
		super(msg);
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\exception\PrintExceptionShortStack.java

package ua.edu.donntu.cs.cuda.exception;

/**
 * Укороченный стек исключения
 * 
 * @author Denis Vodolazskiy
 */
public class PrintExceptionShortStack {
	Exception e;

	/**
	 * Конструктор вывода в консоль стека. Выводятся первые 6 элементов
	 * 
	 */
	public PrintExceptionShortStack(Exception e) {
		this.e = e;
		assert e != null;
		StackTraceElement ste[] = e.getStackTrace();
		System.err.println("Short stack messages: " + e.getLocalizedMessage());
		int n = 6;
		if (ste.length < 6) {
			n = ste.length;
		}
		for (int i = 0; i < n; i++) {
			System.err.println(ste[i]);
		}
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\kutt\full_engine_many\ParallelFullCalcCuda.java

package ua.edu.donntu.cs.cuda.kutt.full_engine_many;

import static jcuda.runtime.JCuda.cudaFree;
import static jcuda.runtime.JCuda.cudaMalloc;
import static jcuda.runtime.JCuda.cudaMemcpy;
import static jcuda.runtime.cudaMemcpyKind.cudaMemcpyDeviceToHost;
import jcuda.Pointer;
import jcuda.Sizeof;
import jcuda.runtime.cudaStream_t;
import jcuda.utils.KernelLauncher;
import ua.edu.donntu.cs.cuda.service.CUDATiming;

/**
 * Этот класс вычисляет координаты и скорости для произвольного количества
 * кораблей с помощью CUDA. Для одного корабля выделяется память объёмом
 * 8*nShips*size*Sizeof.FLOAT. Замеряется время выполнения
 * 
 * @author Denis Vodolazskiy
 */
public class ParallelFullCalcCuda {
	// with k11 - 580.91; coef Vx, Vy
	/**
	 * Количество кораблей
	 */
	private int nShips;// = 20_000;// any value
	/**
	 * Количество шагов (секунд)
	 */
	private int size;// = 8_000;// define size in cu-file.size=8000,
						// otherwise - CUDA_ERROR_OUT_OF_MEMORY
	/**
	 * Время выполнения
	 */
	private float el_time;

	/**
	 * Конструктор, выполняющий вычисления координат и скоростей для
	 * произвольного количества кораблей
	 * 
	 * @param nShips
	 *            количество кораблей
	 * @param size
	 *            количество шагов вычислений (количество секунд)
	 * 
	 */
	public ParallelFullCalcCuda(int nShips, int size) {
		this.nShips = nShips;
		this.size = size;
		float VX[] = new float[nShips * size];
		float VY[] = new float[nShips * size];
		float ww[] = new float[nShips * size];
		// для второго интеграла
		float X[] = new float[nShips * size];
		float Y[] = new float[nShips * size];
		float W[] = new float[nShips * size];
		// неподвижная система координат
		float Xobs[] = new float[nShips * size];
		float Yobs[] = new float[nShips * size];

		cudaStream_t stream = new cudaStream_t();
		CUDATiming ct = new CUDATiming(stream);
		ct.startTiming();
		// create device pointers and allocate memory on the device
		Pointer dev_VX = new Pointer();
		cudaMalloc(dev_VX, nShips * size * Sizeof.FLOAT);
		Pointer dev_VY = new Pointer();
		cudaMalloc(dev_VY, nShips * size * Sizeof.FLOAT);
		Pointer dev_ww = new Pointer();
		cudaMalloc(dev_ww, nShips * size * Sizeof.FLOAT);
		Pointer dev_X = new Pointer();
		cudaMalloc(dev_X, nShips * size * Sizeof.FLOAT);
		Pointer dev_Y = new Pointer();
		cudaMalloc(dev_Y, nShips * size * Sizeof.FLOAT);
		Pointer dev_W = new Pointer();
		cudaMalloc(dev_W, nShips * size * Sizeof.FLOAT);
		Pointer dev_Xobs = new Pointer();
		cudaMalloc(dev_Xobs, nShips * size * Sizeof.FLOAT);
		Pointer dev_Yobs = new Pointer();
		cudaMalloc(dev_Yobs, nShips * size * Sizeof.FLOAT);

		// set cu-file
		KernelLauncher kernelLauncher = KernelLauncher.create(
				"data/cuSource/ParallelFullCalcCuda.cu",
				"ParallelFullCalcCuda", false);

		// parameters of CUDA-function
		int threadsPerBlock = 64;
		int blockPerGrid = (nShips + threadsPerBlock - 1) / threadsPerBlock;
		kernelLauncher.setGridSize(blockPerGrid, 1);
		kernelLauncher.setBlockSize(threadsPerBlock, 1, 1);

		// launch kernel to obtain visible polygons
		kernelLauncher.call(dev_VX, dev_VY, dev_ww, dev_X, dev_Y, dev_W,
				dev_Xobs, dev_Yobs, nShips);

		// copy data from device to host
		cudaMemcpy(Pointer.to(VX), dev_VX, nShips * size * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(VY), dev_VY, nShips * size * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(ww), dev_ww, nShips * size * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(X), dev_X, nShips * size * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(Y), dev_Y, nShips * size * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(W), dev_W, nShips * size * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(Xobs), dev_Xobs, nShips * size * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(Yobs), dev_Yobs, nShips * size * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaFree(dev_VX);
		cudaFree(dev_VY);
		cudaFree(dev_ww);
		cudaFree(dev_X);
		cudaFree(dev_Y);
		cudaFree(dev_W);
		cudaFree(dev_Xobs);
		cudaFree(dev_Yobs);
		el_time = ct.stopTiming();
	}

	/**
	 * Передаёт время выполнения
	 */
	public float getEl_time() {
		return el_time;
	}

}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\kutt\full_engine_one\ModelCalcFullEngineCudaOne.java

package ua.edu.donntu.cs.cuda.kutt.full_engine_one;

import static jcuda.runtime.JCuda.cudaFree;
import static jcuda.runtime.JCuda.cudaMalloc;
import static jcuda.runtime.JCuda.cudaMemcpy;
import static jcuda.runtime.cudaMemcpyKind.cudaMemcpyDeviceToHost;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

import jcuda.Pointer;
import jcuda.Sizeof;
import jcuda.utils.KernelLauncher;

/**
 * Этот класс вычисляет координаты и скорости для одного корабля с помощью CUDA.
 * Количество шагов - 40_000. Выделяется память объёмом
 * 8*nShips*size*Sizeof.FLOAT. Основной класс для вычисления траектории движения
 * (CUDA)
 * 
 * @author Denis Vodolazskiy
 */
public class ModelCalcFullEngineCudaOne {

	// with k11 - 580.91; coef Vx, Vy
	/**
	 * Количество кораблей
	 */
	final private int nShips = 1;// only 1 !!!
	final private float T = 4.0f, L = 80.0f, B = 15.0f;// осадка, длина, ширина
														// c 323, 321
	final private float m = 2_0_000_000_000.0f; // масса судна
	final private float lr = 40.0f; // расстояние от ДРК до ЦТ судна
	private float Vx = 5.0f, Vy = 0.0f;// скорости по осям
	private float v = 0.0f, w = 0.0f;// линейная и угловая скорости
	// private float Rc;//радиус циркуляции
	/**
	 * Количество шагов
	 */
	final private int size = 40_000;
	private float VX[] = new float[size];
	private float VY[] = new float[size];
	private float ww[] = new float[size];
	// для второго интеграла
	private float X[] = new float[size];
	private float Y[] = new float[size];
	private float W[] = new float[size];
	// неподвижная система координат
	private float Xobs[] = new float[size];
	private float Yobs[] = new float[size];

	// private float Wmov[] = new float[size];
	/**
	 * Конструктор, выполняющий вычисления координат и скоростей для одного
	 * корабля
	 */
	public ModelCalcFullEngineCudaOne() {

		// create device pointers and allocate memory on the device
		Pointer dev_VX = new Pointer();
		cudaMalloc(dev_VX, nShips * size * Sizeof.FLOAT);
		Pointer dev_VY = new Pointer();
		cudaMalloc(dev_VY, nShips * size * Sizeof.FLOAT);
		Pointer dev_ww = new Pointer();
		cudaMalloc(dev_ww, nShips * size * Sizeof.FLOAT);
		Pointer dev_X = new Pointer();
		cudaMalloc(dev_X, nShips * size * Sizeof.FLOAT);
		Pointer dev_Y = new Pointer();
		cudaMalloc(dev_Y, nShips * size * Sizeof.FLOAT);
		Pointer dev_W = new Pointer();
		cudaMalloc(dev_W, nShips * size * Sizeof.FLOAT);
		Pointer dev_Xobs = new Pointer();
		cudaMalloc(dev_Xobs, nShips * size * Sizeof.FLOAT);
		Pointer dev_Yobs = new Pointer();
		cudaMalloc(dev_Yobs, nShips * size * Sizeof.FLOAT);

		// set cu-file
		KernelLauncher kernelLauncher = KernelLauncher.create(
				"data/cuSource/modelCalc.cu", "modelCalc", false);

		// parameters of CUDA-function
		int threadsPerBlock = 16;
		int blockPerGrid = (nShips + threadsPerBlock - 1) / threadsPerBlock;
		kernelLauncher.setGridSize(blockPerGrid, 1);
		kernelLauncher.setBlockSize(threadsPerBlock, 1, 1);

		// launch kernel to obtain visible polygons
		kernelLauncher.call(dev_VX, dev_VY, dev_ww, dev_X, dev_Y, dev_W,
				dev_Xobs, dev_Yobs, T, L, B, m, lr, Vx, Vy, v, w, size, nShips);

		// copy data from device to host
		cudaMemcpy(Pointer.to(VX), dev_VX, nShips * size * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(VY), dev_VY, nShips * size * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(ww), dev_ww, nShips * size * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(X), dev_X, nShips * size * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(Y), dev_Y, nShips * size * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(W), dev_W, nShips * size * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(Xobs), dev_Xobs, nShips * size * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(Yobs), dev_Yobs, nShips * size * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaFree(dev_VX);
		cudaFree(dev_VY);
		cudaFree(dev_ww);
		cudaFree(dev_X);
		cudaFree(dev_Y);
		cudaFree(dev_W);
		cudaFree(dev_Xobs);
		cudaFree(dev_Yobs);
		printToFile();
	}

	/**
	 * Запись данных в файл
	 */
	private void printToFile() {
		try {
			BufferedWriter outfile = new BufferedWriter(new FileWriter(
					"data/outfiles/VxVy.txt"));
			BufferedWriter outfile2 = new BufferedWriter(new FileWriter(
					"data/outfiles/viv.txt"));
			BufferedWriter outfile3 = new BufferedWriter(new FileWriter(
					"data/outfiles/XY.txt"));
			BufferedWriter outfile4 = new BufferedWriter(new FileWriter(
					"data/outfiles/XYmov.txt"));
			//
			outfile.write("\t Vx\t\t\t\t Vy\t\t\t\t w\t\t\t t\n");
			//
			outfile3.write("X\t\t Y\t\t W" + "\n");
			//
			outfile4.write("Xmov\t\t Ymov\t\t Wmov" + "\n");

			for (int t = 0; t < size; t++) {
				outfile3.write(X[t] + "\t" + Y[t] + "\t" + W[t] + "\n");
				outfile2.write("viv=" + W[t] + "\n");
				outfile4.write(Xobs[t] + "\t" + Yobs[t] + "\n");
				outfile.write(Vx + "\t\t" + Vy + "\t\t" + w + "\t\t" + t + "\n");
			}
			outfile.close();
			outfile2.close();
			outfile3.close();
			outfile4.close();
		} catch (IOException e) {
		}
	}

	/**
	 * Взять VX
	 * 
	 * @return скорость по оси X в системе объекта
	 */
	public float[] getVX() {
		return VX;
	}

	/**
	 * Взять VY
	 * 
	 * @return скорость по оси Y в системе объекта
	 */
	public float[] getVY() {
		return VY;
	}

	/**
	 * Взять ww
	 * 
	 * @return угловая скорость в системе объекта
	 */
	public float[] getw() {
		return ww;
	}

	/**
	 * Взять X
	 * 
	 * @return скорость по оси X в мировой системе
	 */
	public float[] getX() {
		return X;
	}

	/**
	 * Взять Y
	 * 
	 * @return скорость по оси Y в мировой системе
	 */
	public float[] getY() {
		return Y;
	}

	/**
	 * Взять W
	 * 
	 * @return угловая скорость в мировой системе
	 */
	public float[] getW() {
		return W;
	}

	/**
	 * Взять Xobs
	 * 
	 * @return скорость по оси X в системе наблюдателя
	 */
	public float[] getXobs() {
		return Xobs;
	}

	/**
	 * Взять Yobs
	 * 
	 * @return скорость по оси Y в системе наблюдателя
	 */
	public float[] getYobs() {
		return Yobs;
	}

	/**
	 * Взять Rc
	 * 
	 * @return установившийся радиус циркуляции
	 */
	public float getRc() {
		// return Rc = v / w;
		return ((float) Math.sqrt((float) Math.pow(VX[size - 1], 2.0f)
				+ (float) Math.pow(VY[size - 1], 2.0f)))
				/ ww[size - 1];
	}

	/**
	 * Взять T
	 * 
	 * @return осадка корабля
	 */
	public float getT() {
		return T;
	}

	/**
	 * Взять L
	 * 
	 * @return длина корабля
	 */
	public float getL() {
		return L;
	}

	/**
	 * Взять B
	 * 
	 * @return ширина корабля
	 */
	public float getB() {
		return B;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\kutt\test_time\ParallelSpeedCalcCuda.java

/*Class to know finals speeds of many ships (same ship). define size in cu-file. Copies only final speeds*/
package ua.edu.donntu.cs.cuda.kutt.test_time;

import static jcuda.runtime.JCuda.cudaFree;
import static jcuda.runtime.JCuda.cudaMalloc;
import static jcuda.runtime.JCuda.cudaMemcpy;
import static jcuda.runtime.cudaMemcpyKind.cudaMemcpyDeviceToHost;
import jcuda.Pointer;
import jcuda.Sizeof;
import jcuda.runtime.cudaStream_t;
import jcuda.utils.KernelLauncher;
import ua.edu.donntu.cs.cuda.service.CUDATiming;

/**
 * Этот класс вычисляет конечные скорости для произвольного количества кораблей
 * с помощью CUDA. Для одного корабля выделяется память объёмом
 * 8*nShips*Sizeof.FLOAT. Замеряется время выполнения
 * 
 * @author Denis Vodolazskiy
 */
public class ParallelSpeedCalcCuda {
	// with k11 - 580.91; coef Vx, Vy
	/**
	 * Количество кораблей
	 */
	private int nShips;// = 20_000;// any value
	/**
	 * Количество шагов (секунд)
	 */
	private int size;// = 8_000;// define size in cu-file.size=8000,
						// otherwise - CUDA_ERROR_OUT_OF_MEMORY
	/**
	 * Время выполнения
	 */
	private float el_time;

	/**
	 * Конструктор, выполняющий вычисления конечных скоростей для произвольного
	 * количества кораблей
	 * 
	 * @param nShips
	 *            количество кораблей
	 * @param size
	 *            количество шагов вычислений (количество секунд)
	 * 
	 */
	public ParallelSpeedCalcCuda(int nShips, int size) {
		this.nShips = nShips;
		this.size = size;
		float VX[] = new float[nShips];
		float VY[] = new float[nShips];
		float ww[] = new float[nShips];
		// для второго интеграла
		float X[] = new float[nShips];
		float Y[] = new float[nShips];
		float W[] = new float[nShips];
		// неподвижная система координат
		float Xobs[] = new float[nShips];
		float Yobs[] = new float[nShips];

		cudaStream_t stream = new cudaStream_t();
		CUDATiming ct = new CUDATiming(stream);
		ct.startTiming();
		// create device pointers and allocate memory on the device
		Pointer dev_VX = new Pointer();
		cudaMalloc(dev_VX, nShips * Sizeof.FLOAT);
		Pointer dev_VY = new Pointer();
		cudaMalloc(dev_VY, nShips * Sizeof.FLOAT);
		Pointer dev_ww = new Pointer();
		cudaMalloc(dev_ww, nShips * Sizeof.FLOAT);
		Pointer dev_X = new Pointer();
		cudaMalloc(dev_X, nShips * Sizeof.FLOAT);
		Pointer dev_Y = new Pointer();
		cudaMalloc(dev_Y, nShips * Sizeof.FLOAT);
		Pointer dev_W = new Pointer();
		cudaMalloc(dev_W, nShips * Sizeof.FLOAT);
		Pointer dev_Xobs = new Pointer();
		cudaMalloc(dev_Xobs, nShips * Sizeof.FLOAT);
		Pointer dev_Yobs = new Pointer();
		cudaMalloc(dev_Yobs, nShips * Sizeof.FLOAT);

		// set cu-file
		KernelLauncher kernelLauncher = KernelLauncher.create(
				"data/cuSource/ParallelSpeedCalcCuda.cu",
				"ParallelSpeedCalcCuda", false);

		// parameters of CUDA-function
		int threadsPerBlock = 64;
		int blockPerGrid = (nShips + threadsPerBlock - 1) / threadsPerBlock;
		kernelLauncher.setGridSize(blockPerGrid, 1);
		kernelLauncher.setBlockSize(threadsPerBlock, 1, 1);

		// launch kernel to obtain visible polygons
		kernelLauncher.call(dev_VX, dev_VY, dev_ww, dev_X, dev_Y, dev_W,
				dev_Xobs, dev_Yobs, nShips);

		// copy data from device to host
		cudaMemcpy(Pointer.to(VX), dev_VX, nShips * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(VY), dev_VY, nShips * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(ww), dev_ww, nShips * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(X), dev_X, nShips * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(Y), dev_Y, nShips * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(W), dev_W, nShips * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(Xobs), dev_Xobs, nShips * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(Yobs), dev_Yobs, nShips * Sizeof.FLOAT,
				cudaMemcpyDeviceToHost);
		cudaFree(dev_VX);
		cudaFree(dev_VY);
		cudaFree(dev_ww);
		cudaFree(dev_X);
		cudaFree(dev_Y);
		cudaFree(dev_W);
		cudaFree(dev_Xobs);
		cudaFree(dev_Yobs);
		el_time = ct.stopTiming();
		// System.out.println("(Final velocities) elapsed time GPU=" + el_time +
		// " ms");
		// for (int i = 0; i < nShips; i++)
		// System.out.println(VX[i]);

	}

	/**
	 * Передаёт время выполнения
	 */
	public float getEl_time() {
		return el_time;
	}

}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\kutt\test_time\PrepareThreadSpeedCalc.java

package ua.edu.donntu.cs.cuda.kutt.test_time;

public class PrepareThreadSpeedCalc {
	/**
	 * Количество кораблей
	 */
	private int nShips;
	/**
	 * Время выполнения
	 */
	private long timeout;
	/**
	 * Количество шагов (секунд)
	 */
	private int size;// = 8_000;

	/**
	 * Конструктор, передающий данные в класс-поток
	 * 
	 * @param nShips
	 *            количество кораблей (циклов)
	 * @param size
	 *            количество шагов вычислений (количество секунд)
	 * 
	 */
	public PrepareThreadSpeedCalc(int nShips, int size) {
		this.nShips = nShips;
		this.size = size;
		timeout = System.currentTimeMillis();
		callThreads();
		timeout = System.currentTimeMillis() - timeout;
	}

	/**
	 * Запуск потока
	 */
	private void callThreads() {
		for (int i = 0; i < nShips; i++) {
			Thread t = new Thread(new ThreadSpeedCalc(nShips, size));
			t.start();
			try {
				t.join();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}

	/**
	 * Передаёт время выполнения
	 */
	public long getTimeout() {
		return timeout;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\kutt\test_time\SerialSpeedCalc.java

package ua.edu.donntu.cs.cuda.kutt.test_time;

/**
 * Этот класс вычисляет конечные скорости для произвольного количества кораблей
 * последовательно. Для одного корабля выделяется память объёмом
 * 8*nShips*Sizeof.FLOAT. Замеряется время выполнения
 * 
 * @author Denis Vodolazskiy
 */
public class SerialSpeedCalc {
	/**
	 * Количество кораблей
	 */
	private int nShips;
	/**
	 * Время выполнения
	 */
	private long timeout;
	// with k11 - 580.91; coef Vx, Vy
	final private float T = 4.0f, L = 80.0f, B = 15.0f;// осадка, длина, ширина
														// c 323, 321
	final private float m = 2_0_000_000_000.0f; // масса судна
	final private float lr = 40.0f; // расстояние от ДРК до ЦТ судна
	private float Vx = 0.0f, Vy = 0.0f;// скорости по осям
	private float v = 0.0f, w = 0.0f;// линейная и угловая скорости
	private float Rc;// радиус циркуляции
	/**
	 * Количество шагов (секунд)
	 */
	private int size;// = 8_000;

	/**
	 * Конструктор, выполняющий вычисления конечных скоростей для произвольного
	 * количества кораблей. Вычисления выполняются в цикле
	 * 
	 * @param nShips
	 *            количество кораблей (циклов)
	 * @param size
	 *            количество шагов вычислений (количество секунд)
	 * 
	 */
	public SerialSpeedCalc(int nShips, int size) {
		this.nShips = nShips;
		this.size = size;

		// start of timer
		timeout = System.currentTimeMillis();

		float VX[] = new float[size];
		float VY[] = new float[size];
		float ww[] = new float[size];
		// для второго интеграла
		float X[] = new float[size];
		float Y[] = new float[size];
		float W[] = new float[size];
		// неподвижная система координат
		float Xobs[] = new float[size];
		float Yobs[] = new float[size];

		for (int j = 0; j < nShips; j++) {
			float k11, k22, k66, k26;

			final float delta = 0.7f;// коэффициент общей полноты
			float c1, c2, c3, m1, m2;// коэффициеты Р.Я.Першица
			float w_ = 0.0f;// угол дрейфа approx
			float betta_d = 0.0f;// угол дрейфа в центре тяжести (rad)
			float Cxr, Cyr, Cmr;// коэффициенты Cxr, боковой силы, момента
			// float L1=B,T1=L/2;//хорда, полудлина вертикального крыла
			// ????????????????????
			final float p = 1000.0f;// плотность воды
			float Xr, Yr, Mr;// гидродинамические усилия
			float ZpTei = 0;// полезная тяга винтов при равномерном
							// прямолинейном движении =R+Xa
			float Jz;// момент инерции массы судна относительно оси Gz
			float ZpYri;// боковая сила ДРК
			final float a66 = 0.31f;// числовой коэффициент
			float Ramp = 0.0f;// для одиночных рулей
			float lyamdaR = 1.4f;// удлинение c 335 //0.5--1.4 //1

			float deltaR = 0.349f;// угол перекладки руля - 20% //0.349f

			// float Va;//скорость натекания воды на руль
			float Yri, Ysi;// боковая и стабилизирубщая силы
			final float Ar = 6.0f;// площадь перьев//5 можно увеличить
			final float D = 1.5f;// диаметр диска винта//2 можно уменьшить
			final float Cta = 10.0f, Ctt = 50.0f;// c 334 //Cta<=20, 0.5--30,
													// Ctt<=20, 1--50 UP!!!
			// Ctt =30
			float Kvx, Kvy, Kw;// коэффиценты для производных
			final float No = 3.0f;// обороты двигателя //Першин//3 оборота
			final float Re = 5000000.0f;// Число Рейнольда >5E8
			float K_betta;
			float fit;
			final float xk = 1.0f;
			final float bettar = 0.9f;
			final float fik = 0.95f;
			float ld_;// относительная длина насадки c228
			float betta_D;// коэффициент расширения
			float fiD;// c 338
			float CyD1;
			float CyD;
			float A0;// площадь диска винта
			float xD;// c 339
			float viv = 0.0f;// угол для неподвижной системы координат с 27
								// ch3_2
			float[][] Rmatr = new float[][] {
					{ (float) Math.cos(viv), -(float) Math.sin(viv), 0.0f },
					{ (float) Math.sin(viv), (float) Math.cos(viv), 0.0f },
					{ 0.0f, 0.0f, 1.0f } };
			// Math.cos(viv),-Math.sin(viv),0.0f,Math.sin(viv),Math.cos(viv),0.0f,0.0f,0.0f,1.0f};
			// ------------------------------------------------------------
			// c 330 5.91-в книге, 580.91 - выравнять Х
			k11 = (580.91f * (float) Math.pow(B / L, 2.0f) + 7.76f * (B / L) - 0.259f)
					/ (48.4f - 6.89f * (B / T) + 1.47f
							* (float) Math.pow(B / T, 2.0f) - 0.0475f * (float) Math
							.pow(B / T, 3.0f));

			k22 = ((0.722f + 0.224f * delta) * (1.022f - (float) Math.pow(
					B / L, 2.0f))) / (0.264f + 0.368f * (B / T));
			k66 = (2.0f * T / B) * (2.59f + 0.781f * delta)
					* (0.357f - 1.77f * (float) Math.pow(B / L, 2.0f));
			k26 = k22;
			// k26=0;
			// System.out.printf("k11=%f\tk22=%f\tk66=%f\tk26=%f\n", k11, k22,
			// k66, k26);
			// c 323
			c1 = 3.14f * (T / L)
					* (float) Math.pow((0.63f / delta), (5.0f / 2.0f))
					* (float) Math.pow(L / (6.0f * B), (1.0f / 3.0f)) - 0.032f;
			c2 = -2.0f * k11 * delta * (B / L);
			c3 = 1.35f * (float) Math.pow(T / B, (1.0f / 2.0f))
					* (float) Math.pow((0.63f / delta), (3.0f / 2.0f)) - 0.029f;
			m1 = 1.67f * (T / L) - 0.56f * delta + 0.43f;
			m2 = -0.44f * (T / L) - 0.0375f;
			// System.out.printf("c1=%f\tc2=%f\tc3=%f\tm1=%f\tm2=%f\n", c1, c2,
			// c3, m1, m2);
			Jz = (m * (float) Math.pow(L, 2.0f) / 12.4f)
					* (0.463f + 0.574f * (float) Math.pow(delta, a66) + (float) Math
							.pow(B / L, 2.0f));// c 330
			/*
			 * коэффиценты для производных: 1/m(1+k11) 1/m(1+k22) 1/Jz(1+k26)
			 */
			Kvx = 1 / (m * (1 + k11));
			Kvy = 1 / (m * (1 + k22));
			Kw = 1 / (Jz * (1 + k66));// ????? m
			// System.out.printf("Kvx=%g\tKvy=%g\tKw=%g\n", Kvx, Kvy, Kw);
			// ----------------------------------------------------------------

			float k1, k2, k3, k4;
			float q1, q2, q3, q4;
			float z1, z2, z3, z4;
			float j1, j2, j3, j4;
			// t = 0.0f; // шаг времени
			// int t = 0;
			float h = 1f;
			// System.out.printf("\tVx\t\tVy\t\tw\tt\n");
			Vx = 5.0f;
			Vy = 0.0f;
			w = 0.0f;
			// -------------------------------------
			// ------------------------
			for (int t = 0; t < size; t++) { // 16550
				v = (float) Math.sqrt((float) Math.pow(Vx, 2.0f)
						+ (float) Math.pow(Vy, 2.0f));
				// assert(Vx==0);
				if (Vx != 0) {
					// c 353 ?????????????????????????
					w_ = w * L / v;// ??????????????????????
					betta_d = -(float) Math.atan(Vy / Vx);// c 350
				} else {
					w_ = w * L / v;
					// betta_d = 0;
					betta_d = -(float) Math.atan(Vy / Vx);// c 350
				}
				// System.out.println(w_);
				Cxr = 0.01f * (1.0f + 170.0f * (T / L));// для плота c 119
				Cyr = c1 * betta_d + c2 * w_ + c3 * betta_d * Math.abs(betta_d);// c
																				// 323
				Cmr = m1 * betta_d + m2 * w_;

				Xr = Cxr * L * T * (float) Math.pow(v, 2.0f) * p / 2.0f;// c 320
				Yr = Cyr * L * T * (float) Math.pow(v, 2.0f) * p / 2.0f;
				Mr = Cmr * L * T * (float) Math.pow(v, 2.0f) * p / 2.0f;

				K_betta = 0.43f * (float) Math.pow(Ctt, -0.6f);
				fit = (float) Math.pow(1.0f + Ctt, 0.508f);

				// IMOPRTANT!!! deltaR
				Yri = 3.14f
						* (deltaR - K_betta * xk * (betta_d + lr * w_))
						* p
						* Ar
						* (float) Math.pow(v * fik * fit, 2.0f)
						/ (1.0f + 2.2f / (float) Math.pow(lyamdaR, 2.0f / 3.0f));

				ld_ = 0.77f - 0.125f * (float) Math.sqrt(Ctt)
						/ (1.65f * (float) Math.sqrt(Ctt) - 1.0f);
				betta_D = 1.22f - 0.0563f * (float) Math.sqrt(Ctt)
						/ (1.65f * (float) Math.sqrt(Ctt) - 1.0f);
				fiD = 0.5f * ((float) Math.sqrt(1.0f + 2.0f * Ctt / betta_D) + 1.0f);

				CyD1 = 12.0f * ld_ / (1.0f + 1.56f * ld_);
				CyD = CyD1 + 2.0f * betta_D * (float) Math.pow(fiD, 2.0f);
				xD = xk * (CyD1 + 2.0f * betta_D * fiD)
						/ (CyD1 + 2.0f * betta_D * (float) Math.pow(fiD, 2.0f));
				A0 = 3.14f * (float) Math.pow(D, 2.0f) / 4.0f;
				Ysi = CyD * (xD - 0.02f * xk) * (betta_d + lr * w_)
						* (p / 2.0f) * A0 * (float) Math.pow(v, 2.0f)
						* (float) Math.pow(fik, 2.0f);

				// ZpTei = Xr;//при прямолинейном движении Xr=R
				ZpTei = 1000_000f * (9.740f * (float) Math.pow(No, 2.0f) - 2.23f * v); // Пелевин//9.740f

				ZpYri = 2.0f * (Yri - Ysi);// 2 винта
				// printf("ZpTei=%f\tZpYri=%f\t\n",ZpTei,ZpYri);

				k1 = h * vxd(Vy, w, ZpTei, Xr, Kvx);
				q1 = h * vyd(Vx, w, ZpYri, Yr, Kvy);
				z1 = h * wd(Mr, ZpTei, Yr, Kw);

				k2 = h * vxd(Vy + q1 / 2.0f, w + z1 / 2.0f, ZpTei, Xr, Kvx);
				q2 = h * vyd(Vx + k1 / 2.0f, w + z1 / 2.0f, ZpYri, Yr, Kvy);
				z2 = h * wd(Mr, ZpYri, Yr, Kw);

				k3 = h * vxd(Vy + q2 / 2.0f, w + z2 / 2.0f, ZpTei, Xr, Kvx);
				q3 = h * vyd(Vx + k2 / 2.0f, w + z2 / 2.0f, ZpYri, Yr, Kvy);
				z3 = h * wd(Mr, ZpYri, Yr, Kw);

				k4 = h * vxd(Vy + q3, w + z3, ZpTei, Xr, Kvx);
				q4 = h * vyd(Vx + k3, w + z3, ZpYri, Yr, Kvy);
				z4 = h * wd(Mr, ZpYri, Yr, Kw);

				Vx = Vx + (1.0f / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
				// VX[t] = Vx / 1.24;
				VX[t] = Vx;
				Vy = Vy + (1.0f / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
				VY[t] = Vy;
				w = w + (1.0f / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);
				ww[t] = w;

				// ---второй интеграл-----------------------------------------
				k1 = h * vxd(Vy, w, ZpTei, Xr, Kvx);
				q1 = h * vyd(Vx, w, ZpYri, Yr, Kvy);
				z1 = h * wd(Mr, ZpTei, Yr, Kw);

				k2 = h * vxd(Vy + q1 / 2.0f, w + z1 / 2.0f, ZpTei, Xr, Kvx);
				q2 = h * vyd(Vx + k1 / 2.0f, w + z1 / 2.0f, ZpYri, Yr, Kvy);
				z2 = h * wd(Mr, ZpYri, Yr, Kw);

				k3 = h * vxd(Vy + q2 / 2.0f, w + z2 / 2.0f, ZpTei, Xr, Kvx);
				q3 = h * vyd(Vx + k2 / 2.0f, w + z2 / 2.0f, ZpYri, Yr, Kvy);
				z3 = h * wd(Mr, ZpYri, Yr, Kw);

				k4 = h * vxd(Vy + q3, w + z3, ZpTei, Xr, Kvx);
				q4 = h * vyd(Vx + k3, w + z3, ZpYri, Yr, Kvy);
				z4 = h * wd(Mr, ZpYri, Yr, Kw);

				X[t] = Vx + (1.0f / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
				Y[t] = Vy + (1.0f / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
				W[t] = w + (1.0f / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);

				viv = W[t];

				// -------
				Rmatr[0][0] = (float) Math.cos(viv);
				Rmatr[0][1] = -(float) Math.sin(viv);
				Rmatr[1][0] = (float) Math.sin(viv);
				Rmatr[1][1] = (float) Math.cos(viv);
				Xobs[t] = Rmatr[0][0] * X[t] + Rmatr[0][1] * Y[t];
				Yobs[t] = Rmatr[1][0] * X[t] + Rmatr[1][1] * Y[t];

				// ----------
				// t += 1f;

			}
		}

		// End of timer. Calc elapsed time.
		timeout = System.currentTimeMillis() - timeout;
		// System.out.println("(serial execution) elapsed time CPU="+timeout +
		// " ms");
	}

	/**
	 * Прирашение скорости по оси X
	 * 
	 * @param Vy
	 *            скорость по оси Y
	 * @param w
	 *            угловая скорость
	 * @param ZpTei
	 *            тяга в продольном направлениии
	 * @param Xr
	 *            гидродинамические усилия в продольном направлении
	 * @param Kvx
	 *            коэффициент по X
	 * @return приращение скорости
	 */
	private float vxd(float Vy, float w, float ZpTei, float Xr, float Kvx) {
		if (Vy > 0) {
			return ((m * Vy * w - Xr + ZpTei) * Kvx);
		} else {
			return ((m * Vy * w * 1.09f - Xr + ZpTei) * Kvx);// Vx*1.061
																// ;N0=3;k11=580.91f
																// Ubuntu
			// return ((m * Vy * w - Xr + ZpTei) * Kvx);
		}// *1.1045; k11=5.91f windows ; 1.09; k11=580.91f
	}

	/**
	 * Прирашение скорости по оси Y
	 * 
	 * @param Vx
	 *            скорость по оси x
	 * @param w
	 *            угловая скорость
	 * @param ZpYri
	 *            тяга в поперечном направлениии
	 * @param Yr
	 *            гидродинамические усилия в поперечном направлении
	 * @param Kvy
	 *            коэффициент по Y
	 * @return приращение скорости
	 */
	private float vyd(float Vx, float w, float ZpYri, float Yr, float Kvy) {
		if (Vx > 0) {
			return ((Yr - ZpYri - m * Vx * w * 1.0165f) * Kvy);// Vx*1.0179
			// return ((Yr - ZpYri - m * Vx * w) * Kvy);
		} else {// *1.0165; k11=5.91f windows
			return ((Yr - ZpYri - m * Vx * w) * Kvy);
		}
	}

	/**
	 * Прирашение угловой скорости
	 * 
	 * @param Mr
	 *            момент гидродинамических усилий
	 * @param ZpYri
	 *            тяга в поперечном направлениии
	 * @param Yr
	 *            гидродинамические усилия в поперечном направлении
	 * @param Kw
	 *            коэффициент для угловой скорости
	 * @return приращение угловой скорости
	 */
	private float wd(float Mr, float ZpYri, float Yr, float Kw) {
		return ((Mr + lr * ZpYri) * Kw);
	}

	/**
	 * Передаёт время выполнения
	 */
	public long getTimeout() {
		return timeout;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\kutt\test_time\TestElapsedTime.java

package ua.edu.donntu.cs.cuda.kutt.test_time;

import ua.edu.donntu.cs.cuda.kutt.full_engine_many.ParallelFullCalcCuda;

/**
 * Этот класс запускает различные реализации вычисления координат кораблей и
 * замеряет время выполнения. Данные выводятся в консоль
 * 
 * @author Denis Vodolazskiy
 */
public class TestElapsedTime {
	private final int nShips = 20;// any value, not big //20_000 for
									// ParallelSpeedCalcCuda, 3200 for
									// ParallelFullCalcCuda
	private final int size = 8_000;// define size in cu-file.size=8000,

	// otherwise (bigger) - CUDA_ERROR_OUT_OF_MEMORY
	/**
	 * Конструктор выводит данные в консоль
	 */
	public TestElapsedTime() {
		System.out.println("(Final velocities) elapsed time GPU="
				+ new ParallelSpeedCalcCuda(nShips, size).getEl_time() + " ms");
		System.out.println("(full data) elapsed time GPU="
				+ new ParallelFullCalcCuda(nShips, size).getEl_time() + " ms");
		System.out.println("(serial execution) elapsed time CPU="
				+ new SerialSpeedCalc(nShips, size).getTimeout() + " ms");
		System.out
				.println("(thread execution) elapsed time thread CPU="
						+ new PrepareThreadSpeedCalc(nShips, size).getTimeout()
						+ " ms");
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\kutt\test_time\ThreadSpeedCalc.java

package ua.edu.donntu.cs.cuda.kutt.test_time;

/**
 * Этот класс вычисляет конечные скорости для произвольного количества кораблей
 * в потоках. Для одного корабля выделяется память объёмом
 * 8*nShips*Sizeof.FLOAT. Замеряется время выполнения
 * 
 * @author Denis Vodolazskiy
 */
public class ThreadSpeedCalc implements Runnable {
	/**
	 * Количество кораблей
	 */
	private int nShips;

	// with k11 - 580.91; coef Vx, Vy
	final private float T = 4.0f, L = 80.0f, B = 15.0f;// осадка, длина, ширина
														// c 323, 321
	final private float m = 2_0_000_000_000.0f; // масса судна
	final private float lr = 40.0f; // расстояние от ДРК до ЦТ судна
	private float Vx = 0.0f, Vy = 0.0f;// скорости по осям
	private float v = 0.0f, w = 0.0f;// линейная и угловая скорости
	private float Rc;// радиус циркуляции
	/**
	 * Количество шагов (секунд)
	 */
	private int size;// = 8_000;

	/**
	 * Конструктор, выполняющий вычисления конечных скоростей для произвольного
	 * количества кораблей.
	 * 
	 * @param nShips
	 *            количество кораблей (циклов)
	 * @param size
	 *            количество шагов вычислений (количество секунд)
	 * 
	 */
	public ThreadSpeedCalc(int nShips, int size) {
		this.nShips = nShips;
		this.size = size;
	}

	/**
	 * Содержимое потока
	 */
	@Override
	public void run() {
		float VX[] = new float[size];
		float VY[] = new float[size];
		float ww[] = new float[size];
		// для второго интеграла
		float X[] = new float[size];
		float Y[] = new float[size];
		float W[] = new float[size];
		// неподвижная система координат
		float Xobs[] = new float[size];
		float Yobs[] = new float[size];

		for (int j = 0; j < nShips; j++) {
			float k11, k22, k66, k26;

			final float delta = 0.7f;// коэффициент общей полноты
			float c1, c2, c3, m1, m2;// коэффициеты Р.Я.Першица
			float w_ = 0.0f;// угол дрейфа approx
			float betta_d = 0.0f;// угол дрейфа в центре тяжести (rad)
			float Cxr, Cyr, Cmr;// коэффициенты Cxr, боковой силы, момента
			// float L1=B,T1=L/2;//хорда, полудлина вертикального крыла
			// ????????????????????
			final float p = 1000.0f;// плотность воды
			float Xr, Yr, Mr;// гидродинамические усилия
			float ZpTei = 0;// полезная тяга винтов при равномерном
							// прямолинейном движении =R+Xa
			float Jz;// момент инерции массы судна относительно оси Gz
			float ZpYri;// боковая сила ДРК
			final float a66 = 0.31f;// числовой коэффициент
			float Ramp = 0.0f;// для одиночных рулей
			float lyamdaR = 1.4f;// удлинение c 335 //0.5--1.4 //1

			float deltaR = 0.349f;// угол перекладки руля - 20% //0.349f

			// float Va;//скорость натекания воды на руль
			float Yri, Ysi;// боковая и стабилизирубщая силы
			final float Ar = 6.0f;// площадь перьев//5 можно увеличить
			final float D = 1.5f;// диаметр диска винта//2 можно уменьшить
			final float Cta = 10.0f, Ctt = 50.0f;// c 334 //Cta<=20, 0.5--30,
													// Ctt<=20, 1--50 UP!!!
			// Ctt =30
			float Kvx, Kvy, Kw;// коэффиценты для производных
			final float No = 3.0f;// обороты двигателя //Першин//3 оборота
			final float Re = 5000000.0f;// Число Рейнольда >5E8
			float K_betta;
			float fit;
			final float xk = 1.0f;
			final float bettar = 0.9f;
			final float fik = 0.95f;
			float ld_;// относительная длина насадки c228
			float betta_D;// коэффициент расширения
			float fiD;// c 338
			float CyD1;
			float CyD;
			float A0;// площадь диска винта
			float xD;// c 339
			float viv = 0.0f;// угол для неподвижной системы координат с 27
								// ch3_2
			float[][] Rmatr = new float[][] {
					{ (float) Math.cos(viv), -(float) Math.sin(viv), 0.0f },
					{ (float) Math.sin(viv), (float) Math.cos(viv), 0.0f },
					{ 0.0f, 0.0f, 1.0f } };
			// Math.cos(viv),-Math.sin(viv),0.0f,Math.sin(viv),Math.cos(viv),0.0f,0.0f,0.0f,1.0f};
			// ------------------------------------------------------------
			// c 330 5.91-в книге, 580.91 - выравнять Х
			k11 = (580.91f * (float) Math.pow(B / L, 2.0f) + 7.76f * (B / L) - 0.259f)
					/ (48.4f - 6.89f * (B / T) + 1.47f
							* (float) Math.pow(B / T, 2.0f) - 0.0475f * (float) Math
							.pow(B / T, 3.0f));

			k22 = ((0.722f + 0.224f * delta) * (1.022f - (float) Math.pow(
					B / L, 2.0f))) / (0.264f + 0.368f * (B / T));
			k66 = (2.0f * T / B) * (2.59f + 0.781f * delta)
					* (0.357f - 1.77f * (float) Math.pow(B / L, 2.0f));
			k26 = k22;
			// k26=0;
			// System.out.printf("k11=%f\tk22=%f\tk66=%f\tk26=%f\n", k11, k22,
			// k66, k26);
			// c 323
			c1 = 3.14f * (T / L)
					* (float) Math.pow((0.63f / delta), (5.0f / 2.0f))
					* (float) Math.pow(L / (6.0f * B), (1.0f / 3.0f)) - 0.032f;
			c2 = -2.0f * k11 * delta * (B / L);
			c3 = 1.35f * (float) Math.pow(T / B, (1.0f / 2.0f))
					* (float) Math.pow((0.63f / delta), (3.0f / 2.0f)) - 0.029f;
			m1 = 1.67f * (T / L) - 0.56f * delta + 0.43f;
			m2 = -0.44f * (T / L) - 0.0375f;
			// System.out.printf("c1=%f\tc2=%f\tc3=%f\tm1=%f\tm2=%f\n", c1, c2,
			// c3, m1, m2);
			Jz = (m * (float) Math.pow(L, 2.0f) / 12.4f)
					* (0.463f + 0.574f * (float) Math.pow(delta, a66) + (float) Math
							.pow(B / L, 2.0f));// c 330
			/*
			 * коэффиценты для производных: 1/m(1+k11) 1/m(1+k22) 1/Jz(1+k26)
			 */
			Kvx = 1 / (m * (1 + k11));
			Kvy = 1 / (m * (1 + k22));
			Kw = 1 / (Jz * (1 + k66));// ????? m
			// System.out.printf("Kvx=%g\tKvy=%g\tKw=%g\n", Kvx, Kvy, Kw);
			// ----------------------------------------------------------------

			float k1, k2, k3, k4;
			float q1, q2, q3, q4;
			float z1, z2, z3, z4;
			float j1, j2, j3, j4;
			// t = 0.0f; // шаг времени
			// int t = 0;
			float h = 1f;
			// System.out.printf("\tVx\t\tVy\t\tw\tt\n");
			Vx = 5.0f;
			Vy = 0.0f;
			w = 0.0f;
			// -------------------------------------
			// ------------------------
			for (int t = 0; t < size; t++) { // 16550
				v = (float) Math.sqrt((float) Math.pow(Vx, 2.0f)
						+ (float) Math.pow(Vy, 2.0f));
				// assert(Vx==0);
				if (Vx != 0) {
					// c 353 ?????????????????????????
					w_ = w * L / v;// ??????????????????????
					betta_d = -(float) Math.atan(Vy / Vx);// c 350
				} else {
					w_ = w * L / v;
					// betta_d = 0;
					betta_d = -(float) Math.atan(Vy / Vx);// c 350
				}
				// System.out.println(w_);
				Cxr = 0.01f * (1.0f + 170.0f * (T / L));// для плота c 119
				Cyr = c1 * betta_d + c2 * w_ + c3 * betta_d * Math.abs(betta_d);// c
																				// 323
				Cmr = m1 * betta_d + m2 * w_;

				Xr = Cxr * L * T * (float) Math.pow(v, 2.0f) * p / 2.0f;// c 320
				Yr = Cyr * L * T * (float) Math.pow(v, 2.0f) * p / 2.0f;
				Mr = Cmr * L * T * (float) Math.pow(v, 2.0f) * p / 2.0f;

				K_betta = 0.43f * (float) Math.pow(Ctt, -0.6f);
				fit = (float) Math.pow(1.0f + Ctt, 0.508f);

				// IMOPRTANT!!! deltaR
				Yri = 3.14f
						* (deltaR - K_betta * xk * (betta_d + lr * w_))
						* p
						* Ar
						* (float) Math.pow(v * fik * fit, 2.0f)
						/ (1.0f + 2.2f / (float) Math.pow(lyamdaR, 2.0f / 3.0f));

				ld_ = 0.77f - 0.125f * (float) Math.sqrt(Ctt)
						/ (1.65f * (float) Math.sqrt(Ctt) - 1.0f);
				betta_D = 1.22f - 0.0563f * (float) Math.sqrt(Ctt)
						/ (1.65f * (float) Math.sqrt(Ctt) - 1.0f);
				fiD = 0.5f * ((float) Math.sqrt(1.0f + 2.0f * Ctt / betta_D) + 1.0f);

				CyD1 = 12.0f * ld_ / (1.0f + 1.56f * ld_);
				CyD = CyD1 + 2.0f * betta_D * (float) Math.pow(fiD, 2.0f);
				xD = xk * (CyD1 + 2.0f * betta_D * fiD)
						/ (CyD1 + 2.0f * betta_D * (float) Math.pow(fiD, 2.0f));
				A0 = 3.14f * (float) Math.pow(D, 2.0f) / 4.0f;
				Ysi = CyD * (xD - 0.02f * xk) * (betta_d + lr * w_)
						* (p / 2.0f) * A0 * (float) Math.pow(v, 2.0f)
						* (float) Math.pow(fik, 2.0f);

				// ZpTei = Xr;//при прямолинейном движении Xr=R
				ZpTei = 1000_000f * (9.740f * (float) Math.pow(No, 2.0f) - 2.23f * v); // Пелевин//9.740f

				ZpYri = 2.0f * (Yri - Ysi);// 2 винта
				// printf("ZpTei=%f\tZpYri=%f\t\n",ZpTei,ZpYri);

				k1 = h * vxd(Vy, w, ZpTei, Xr, Kvx);
				q1 = h * vyd(Vx, w, ZpYri, Yr, Kvy);
				z1 = h * wd(Mr, ZpTei, Yr, Kw);

				k2 = h * vxd(Vy + q1 / 2.0f, w + z1 / 2.0f, ZpTei, Xr, Kvx);
				q2 = h * vyd(Vx + k1 / 2.0f, w + z1 / 2.0f, ZpYri, Yr, Kvy);
				z2 = h * wd(Mr, ZpYri, Yr, Kw);

				k3 = h * vxd(Vy + q2 / 2.0f, w + z2 / 2.0f, ZpTei, Xr, Kvx);
				q3 = h * vyd(Vx + k2 / 2.0f, w + z2 / 2.0f, ZpYri, Yr, Kvy);
				z3 = h * wd(Mr, ZpYri, Yr, Kw);

				k4 = h * vxd(Vy + q3, w + z3, ZpTei, Xr, Kvx);
				q4 = h * vyd(Vx + k3, w + z3, ZpYri, Yr, Kvy);
				z4 = h * wd(Mr, ZpYri, Yr, Kw);

				Vx = Vx + (1.0f / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
				// VX[t] = Vx / 1.24;
				VX[t] = Vx;
				Vy = Vy + (1.0f / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
				VY[t] = Vy;
				w = w + (1.0f / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);
				ww[t] = w;

				// ---второй интеграл-----------------------------------------
				k1 = h * vxd(Vy, w, ZpTei, Xr, Kvx);
				q1 = h * vyd(Vx, w, ZpYri, Yr, Kvy);
				z1 = h * wd(Mr, ZpTei, Yr, Kw);

				k2 = h * vxd(Vy + q1 / 2.0f, w + z1 / 2.0f, ZpTei, Xr, Kvx);
				q2 = h * vyd(Vx + k1 / 2.0f, w + z1 / 2.0f, ZpYri, Yr, Kvy);
				z2 = h * wd(Mr, ZpYri, Yr, Kw);

				k3 = h * vxd(Vy + q2 / 2.0f, w + z2 / 2.0f, ZpTei, Xr, Kvx);
				q3 = h * vyd(Vx + k2 / 2.0f, w + z2 / 2.0f, ZpYri, Yr, Kvy);
				z3 = h * wd(Mr, ZpYri, Yr, Kw);

				k4 = h * vxd(Vy + q3, w + z3, ZpTei, Xr, Kvx);
				q4 = h * vyd(Vx + k3, w + z3, ZpYri, Yr, Kvy);
				z4 = h * wd(Mr, ZpYri, Yr, Kw);

				X[t] = Vx + (1.0f / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
				Y[t] = Vy + (1.0f / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
				W[t] = w + (1.0f / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);

				viv = W[t];

				// -------
				Rmatr[0][0] = (float) Math.cos(viv);
				Rmatr[0][1] = -(float) Math.sin(viv);
				Rmatr[1][0] = (float) Math.sin(viv);
				Rmatr[1][1] = (float) Math.cos(viv);
				Xobs[t] = Rmatr[0][0] * X[t] + Rmatr[0][1] * Y[t];
				Yobs[t] = Rmatr[1][0] * X[t] + Rmatr[1][1] * Y[t];

				// ----------
				// t += 1f;

			}
		}
	}

	/**
	 * Прирашение скорости по оси X
	 * 
	 * @param Vy
	 *            скорость по оси Y
	 * @param w
	 *            угловая скорость
	 * @param ZpTei
	 *            тяга в продольном направлениии
	 * @param Xr
	 *            гидродинамические усилия в продольном направлении
	 * @param Kvx
	 *            коэффициент по X
	 * @return приращение скорости
	 */
	private float vxd(float Vy, float w, float ZpTei, float Xr, float Kvx) {
		if (Vy > 0) {
			return ((m * Vy * w - Xr + ZpTei) * Kvx);
		} else {
			return ((m * Vy * w * 1.09f - Xr + ZpTei) * Kvx);// Vx*1.061
																// ;N0=3;k11=580.91f
																// Ubuntu
			// return ((m * Vy * w - Xr + ZpTei) * Kvx);
		}// *1.1045; k11=5.91f windows ; 1.09; k11=580.91f
	}

	/**
	 * Прирашение скорости по оси Y
	 * 
	 * @param Vx
	 *            скорость по оси x
	 * @param w
	 *            угловая скорость
	 * @param ZpYri
	 *            тяга в поперечном направлениии
	 * @param Yr
	 *            гидродинамические усилия в поперечном направлении
	 * @param Kvy
	 *            коэффициент по Y
	 * @return приращение скорости
	 */
	private float vyd(float Vx, float w, float ZpYri, float Yr, float Kvy) {
		if (Vx > 0) {
			return ((Yr - ZpYri - m * Vx * w * 1.0165f) * Kvy);// Vx*1.0179
			// return ((Yr - ZpYri - m * Vx * w) * Kvy);
		} else {// *1.0165; k11=5.91f windows
			return ((Yr - ZpYri - m * Vx * w) * Kvy);
		}
	}

	/**
	 * Прирашение угловой скорости
	 * 
	 * @param Mr
	 *            момент гидродинамических усилий
	 * @param ZpYri
	 *            тяга в поперечном направлениии
	 * @param Yr
	 *            гидродинамические усилия в поперечном направлении
	 * @param Kw
	 *            коэффициент для угловой скорости
	 * @return приращение угловой скорости
	 */
	private float wd(float Mr, float ZpYri, float Yr, float Kw) {
		return ((Mr + lr * ZpYri) * Kw);
	}

}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\load_data\ICudaPrepareData.java

/*Class with constant arrays (for CUDA)*/

/*Not used*/
package ua.edu.donntu.cs.cuda.load_data;

/**
 * Этот интерфейс создаёт константные массивы точек, полигонов и нормалей. Для
 * реализации на CUDA
 * 
 * @author Denis Vodolazskiy
 */
public interface ICudaPrepareData {
	public final LoadDataCuda dataCuda = new LoadDataCuda();
	public final int pointsBaseCuda[] = dataCuda.loadPoints();
	// public final int pointsBaseCuda[] = new TransformArray().in1D(points, N);
	public final int polygonsCuda[] = dataCuda.loadPolygons();
	public final int normalsCuda[] = dataCuda.loadNormals(pointsBaseCuda,
			polygonsCuda);
	// public final int normalsCuda[] =
	// dataCuda.loadNormalsCuda(pointsBaseCuda,polygonsCuda);
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\load_data\LoadDataCuda.java

/*Class to load data*/
package ua.edu.donntu.cs.cuda.load_data;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;

import ua.edu.donntu.cs.inout.LoadData;

/**
 * Этот класс загружает данные из файлов и сохраняет их в одномерные массивы.
 * Одномерные массивы используются для вычисления на GPU
 * 
 * @author Denis Vodolazskiy
 */
public class LoadDataCuda {
	private final int n = 3;
	private int countPoints = 0;
	private int countPolygons = 0;

	// ----------method for normal creation----------------------------
	/**
	 * Вычисление вектора нормали
	 * 
	 * @param b
	 *            координаты первой точки
	 * @param c
	 *            координаты второй точки
	 * @param d
	 *            координаты третей точки
	 * @return вектор нормали
	 */
	private int[] createNewNormal(int b[], int c[], int d[]) {
		int normal[] = new int[3];
		int x[] = new int[3];
		int y[] = new int[3];
		int z[] = new int[3];
		// for (int i=0;i<4;i++){
		x[0] = b[0];
		x[1] = c[0];
		x[2] = d[0];

		y[0] = b[1];
		y[1] = c[1];
		y[2] = d[1];

		z[0] = b[2];
		z[1] = c[2];
		z[2] = d[2];
		// }
		int j = 0;
		for (int i = 0; i < 3; i++) {
			if (i < 2) {
				j = i + 1;
				normal[0] += -(y[i] - y[j]) * (z[i] + z[j]);
				normal[1] += -(z[i] - z[j]) * (x[i] + x[j]);
				normal[2] += -(x[i] - x[j]) * (y[i] + y[j]);
			} else {
				j = 0;
				normal[0] += -(y[i] - y[j]) * (z[i] + z[j]);
				normal[1] += -(z[i] - z[j]) * (x[i] + x[j]);
				normal[2] += -(x[i] - x[j]) * (y[i] + y[j]);
			}
		}
		return normal;
	}

	// ----------------------------------Cuda-------------------------
	// ----------------------load points CUDA-------------------------
	/**
	 * Загружает координаты точек из файла
	 * 
	 * @return одномерный массив координат точек
	 */
	public int[] loadPoints() {
		ArrayList<Integer> p = new ArrayList<Integer>();
		try {
			Scanner scanner = new Scanner(new File(
					"data/inputfiles/points2.txt"));
			while (scanner.hasNext()) {
				p.add(scanner.nextInt());
				countPoints++;
			}
		} catch (FileNotFoundException ex) {
			System.out.println("som");
			Logger.getLogger(LoadData.class.getName()).log(Level.SEVERE, null,
					ex);
		}
		int[] points = new int[countPoints];
		int i = 0;
		while (i < countPoints) {
			points[i] = p.get(i);
			i++;
		}
		countPoints /= 3;
		return points;
	}

	// ----------------------load polygons Cuda-------------------------
	/**
	 * Загружает список точек для каждого треугольника
	 * 
	 * @return массив треугольников
	 */
	public int[] loadPolygons() {
		ArrayList<Integer> p = new ArrayList<Integer>();
		try {
			Scanner scanner = new Scanner(new File(
					"data/inputfiles/pointsAndPolygons2.txt"));
			while (scanner.hasNext()) {
				p.add(scanner.nextInt());
				countPolygons++;
			}
		} catch (FileNotFoundException ex) {
			System.out.println("som");
			Logger.getLogger(LoadData.class.getName()).log(Level.SEVERE, null,
					ex);
		}
		int[] polygons = new int[countPolygons];
		int i = 0;
		while (i < countPolygons) {
			polygons[i] = p.get(i);
			i++;
		}
		countPolygons /= 3;
		return polygons;
	}

	// -----------------------------------------------------------------
	/**
	 * Обрабатывает массивы точек и полигонов. Вызывается функция
	 * createNewNormal
	 * 
	 * @param points
	 *            массив координат точек
	 * @param polygons
	 *            массив точек для полигонов
	 * @return вектор нормали
	 */
	public int[] loadNormals(int points[], int polygons[]) {
		int[] normals = new int[countPolygons * n];
		int[] norm = new int[3];
		for (int i = 0; i < countPolygons; i++) {
			int[] x = { points[3 * polygons[3 * i]],
					points[3 * polygons[3 * i] + 1],
					points[3 * polygons[3 * i] + 2] };
			int[] y = { points[3 * polygons[3 * i + 1]],
					points[3 * polygons[3 * i + 1] + 1],
					points[3 * polygons[3 * i + 1] + 2] };
			int[] z = { points[3 * polygons[3 * i + 2]],
					points[3 * polygons[3 * i + 2] + 1],
					points[3 * polygons[3 * i + 2] + 2] };
			norm = createNewNormal(x, y, z);
			normals[3 * i] = norm[0];
			normals[3 * i + 1] = norm[1];
			normals[3 * i + 2] = norm[2];
		}
		// new WriteToFile(normals, "normal2.txt");
		return normals;
	}

	/**
	 * Взять количество точек
	 * 
	 * @return количество точек
	 */
	public int getCountPoints() {
		return countPoints;
	}

	/**
	 * Взять количество полигонов
	 * 
	 * @return количество полигонов
	 */
	public int getCountPolygons() {
		return countPolygons;
	}

}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\load_data\LoadNormalsCuda1D.java

package ua.edu.donntu.cs.cuda.load_data;

import static jcuda.runtime.JCuda.cudaFree;
import static jcuda.runtime.JCuda.cudaMalloc;
import static jcuda.runtime.JCuda.cudaMemcpy;
import static jcuda.runtime.cudaMemcpyKind.cudaMemcpyDeviceToHost;
import static jcuda.runtime.cudaMemcpyKind.cudaMemcpyHostToDevice;
import jcuda.Pointer;
import jcuda.Sizeof;
import jcuda.utils.KernelLauncher;

/**
 * Этот класс вычисляет векторы нормалей.Используется CUDA. Одномерные массивы
 * используются для вычисления на GPU
 * 
 * @author Denis Vodolazskiy
 */
public class LoadNormalsCuda1D {
	// ---------------normals Cuda------------------------------
	/**
	 * Рассчитывает векторы нормалей на GPU
	 * 
	 * @param points
	 *            координаты точек
	 * @param polygons
	 *            точки полигонов
	 * @param countPoints
	 *            количество точек
	 * @param countPolygons
	 *            количество полигонов
	 * @return одномерный массив векторов нормалей
	 */
	public int[] loadNormalsCuda(int points[], int polygons[], int countPoints,
			int countPolygons) {
		int[] normals = new int[countPolygons * 3];
		int sizePoly = 3 * countPolygons * Sizeof.INT;

		int sizePoint = 3 * countPoints * Sizeof.INT;
		int size = countPolygons * Sizeof.INT;
		int normalX[] = new int[countPolygons];
		int normalY[] = new int[countPolygons];
		int normalZ[] = new int[countPolygons];

		// create device pointers and allocate memory on the device
		Pointer poi = new Pointer();
		cudaMalloc(poi, sizePoint);
		Pointer pol = new Pointer();
		cudaMalloc(pol, sizePoly);
		Pointer nX = new Pointer();
		cudaMalloc(nX, size);
		Pointer nY = new Pointer();
		cudaMalloc(nY, size);
		Pointer nZ = new Pointer();
		cudaMalloc(nZ, size);

		// copy data from host to device. Pointer.to(points) - host pointer
		cudaMemcpy(poi, Pointer.to(points), sizePoint, cudaMemcpyHostToDevice);
		cudaMemcpy(pol, Pointer.to(polygons), sizePoly, cudaMemcpyHostToDevice);

		// set cu-file
		KernelLauncher kernelLauncher = KernelLauncher.create(
				"data/cuSource/TestNormalFull.cu", "TestNormalFull", false);

		// parameters of CUDA-function
		int threadsPerBlock = 64;
		int blockPerGrid = (countPolygons + threadsPerBlock - 1)
				/ threadsPerBlock;
		kernelLauncher.setGridSize(blockPerGrid, 1);
		kernelLauncher.setBlockSize(threadsPerBlock, 1, 1);

		// launch kernel to obtain normals
		kernelLauncher.call(poi, pol, nX, nY, nZ, countPolygons);

		// copy data from device to host
		cudaMemcpy(Pointer.to(normalX), nX, size, cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(normalY), nY, size, cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(normalZ), nZ, size, cudaMemcpyDeviceToHost);

		// free memory on the device
		cudaFree(poi);
		cudaFree(pol);
		cudaFree(nX);
		cudaFree(nY);
		cudaFree(nZ);

		for (int i = 0; i < countPolygons; i++) {
			normals[3 * i] = normalX[i];
			normals[3 * i + 1] = normalY[i];
			normals[3 * i + 2] = normalZ[i];
		}
		// new WriteToFile(normals, "normalCuda.txt");
		return normals;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\load_data\LoadNormalsCuda2D.java

package ua.edu.donntu.cs.cuda.load_data;

import static jcuda.runtime.JCuda.cudaFree;
import static jcuda.runtime.JCuda.cudaMalloc;
import static jcuda.runtime.JCuda.cudaMemcpy;
import static jcuda.runtime.cudaMemcpyKind.cudaMemcpyDeviceToHost;
import static jcuda.runtime.cudaMemcpyKind.cudaMemcpyHostToDevice;
import jcuda.Pointer;
import jcuda.Sizeof;
import jcuda.utils.KernelLauncher;
import ua.edu.donntu.cs.inout.WriteToFile;

/**
 * Этот класс вычисляет векторы нормалей.Используется CUDA. Двумерные массивы
 * используются для вычисления на CPU
 * 
 * @author Denis Vodolazskiy
 */
public class LoadNormalsCuda2D {
	// the same method for 2D arrays
	/**
	 * Рассчитывает векторы нормалей на GPU
	 * 
	 * @param points
	 *            координаты точек
	 * @param polygons
	 *            точки полигонов
	 * @param countPoints
	 *            количество точек
	 * @param countPolygons
	 *            количество полигонов
	 * @return двумерный массив векторов нормалей
	 */
	public int[][] loadNormalsCuda(int points[][], int polygons[][],
			int countPoints, int countPolygons) {
		int normals[][] = new int[countPolygons][3];
		int sizePoly = 3 * countPolygons * Sizeof.INT;
		int sizePoint = 3 * countPoints * Sizeof.INT;
		int size = countPolygons * Sizeof.INT;
		int point[] = new int[sizePoint];
		int polygon[] = new int[sizePoly];
		int normalX[] = new int[countPolygons];
		int normalY[] = new int[countPolygons];
		int normalZ[] = new int[countPolygons];
		//
		for (int i = 0; i < countPoints; i++) {
			for (int j = 0; j < 3; j++) {
				point[3 * i + j] = points[i][j];
			}
		}
		for (int i = 0; i < countPolygons; i++) {
			for (int j = 0; j < 3; j++) {
				polygon[3 * i + j] = polygons[i][j];
			}
		}

		// create device pointers and allocate memory on the device
		Pointer poi = new Pointer();
		cudaMalloc(poi, sizePoint);
		Pointer pol = new Pointer();
		cudaMalloc(pol, sizePoly);
		Pointer nX = new Pointer();
		cudaMalloc(nX, size);
		Pointer nY = new Pointer();
		cudaMalloc(nY, size);
		Pointer nZ = new Pointer();
		cudaMalloc(nZ, size);

		// copy data from host to device. Pointer.to(points) - host pointer
		cudaMemcpy(poi, Pointer.to(point), sizePoint, cudaMemcpyHostToDevice);
		cudaMemcpy(pol, Pointer.to(polygon), sizePoly, cudaMemcpyHostToDevice);

		// set cu-file
		KernelLauncher kernelLauncher = KernelLauncher.create(
				"data/cuSource/TestNormalFull.cu", "TestNormalFull", false);

		// parameters of CUDA-function
		int threadsPerBlock = 64;
		int blockPerGrid = (countPolygons + threadsPerBlock - 1)
				/ threadsPerBlock;
		kernelLauncher.setGridSize(blockPerGrid, 1);
		kernelLauncher.setBlockSize(threadsPerBlock, 1, 1);

		// launch kernel to obtain normals
		kernelLauncher.call(poi, pol, nX, nY, nZ, countPolygons);

		// copy data from device to host
		cudaMemcpy(Pointer.to(normalX), nX, size, cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(normalY), nY, size, cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(normalZ), nZ, size, cudaMemcpyDeviceToHost);

		// free memory on the device
		cudaFree(poi);
		cudaFree(pol);
		cudaFree(nX);
		cudaFree(nY);
		cudaFree(nZ);

		for (int i = 0; i < countPolygons; i++) {
			normals[i][0] = normalX[i];
			normals[i][1] = normalY[i];
			normals[i][2] = normalZ[i];
		}
		new WriteToFile(normals, "normal2.txt");
		return normals;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\many_ships\ManyShipsCuda.java

/*Class to move group of ships using CUDA*/
package ua.edu.donntu.cs.cuda.many_ships;

import static jcuda.runtime.JCuda.cudaFree;
import static jcuda.runtime.JCuda.cudaMalloc;
import static jcuda.runtime.JCuda.cudaMemcpy;
import static jcuda.runtime.cudaMemcpyKind.cudaMemcpyDeviceToHost;
import static jcuda.runtime.cudaMemcpyKind.cudaMemcpyHostToDevice;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;

import javax.swing.JPanel;
import javax.swing.Timer;

import jcuda.Pointer;
import jcuda.Sizeof;
import jcuda.utils.KernelLauncher;
import ua.edu.donntu.cs.draw.information.InfoPrint;
import ua.edu.donntu.cs.draw.matrix_transform.MatrixTransform;
import ua.edu.donntu.cs.inout.IPrepareData;
import ua.edu.donntu.cs.key_manager.Craft;
import ua.edu.donntu.cs.service.transform_pixels_meters.MetMmTransform;

/**
 * Панель для построения 9-ти объектов с помощью GPU
 * 
 * @author Denis Vodolazskiy
 */
public class ManyShipsCuda extends JPanel implements ActionListener,
		IPrepareData {
	private static final long serialVersionUID = 1L;
	//
	private Timer timer;
	private Craft craft;

	// start corners
	protected float psi = 0;// -30;
	protected float teta = 0;// 30;
	protected float gamma = 0;
	protected int pr = 1;

	// start distances
	protected int distanceX = new MetMmTransform().meter2mm(-500);// 60000;
	protected int distanceY = 0;
	protected int distanceZ = 0;
	//
	final int n = 3;
	final int nShips = 9;
	protected int shipLocationX[] = { 0, 0, 0, 150000, -150000, 150000, -150000,
			-150000, 150000, };
	protected int shipLocationZ[] = { 0, 150000, -150000, 0, 0, 150000, 150000,
			-150000, -150000 };
	//

	protected int[] polygonToFillX = new int[Q_POLYGONS * n * nShips];
	protected int[] polygonToFillY = new int[Q_POLYGONS * n * nShips];
	protected int[] S = new int[Q_POLYGONS * nShips];

	/**
	 * Конструктор, активирует слушателя и менеджера клавиатуры. Запускает
	 * таймер.
	 */
	public ManyShipsCuda() {
		addKeyListener(new TAdapter());
		setFocusable(true);
		setBackground(Color.BLACK);
		setDoubleBuffered(true);
		craft = new Craft(psi, teta, gamma, distanceX, distanceY, distanceZ);
		timer = new Timer(5, this);
		timer.start();
	}

	/**
	 * Функции для определения видимых полигонов с помощью GPU
	 */
	protected void calc() {
		// ------------------matrix A B C------------------------------------
		double matrixA[][] = new double[3][3];
		MatrixTransform mt = new MatrixTransform();
		matrixA = mt.matr(psi, teta, gamma, pr);
		double matrixB[][] = { { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 } };
		float[] matrixC = new float[12];
		float pcs[] = { 0, 0, 0 };// вектор сцены 0,0,0

		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 3; j++) {
				matrixC[i * 4 + j] = (float) (matrixA[i][0] * matrixB[j][0]
						+ matrixA[i][1] * matrixB[j][1] + matrixA[i][2]
						* matrixB[j][2]);
			}
		}
		pcs[0] = pcs[0] - distanceX;
		pcs[1] = pcs[1] - distanceY;
		pcs[2] = pcs[2] - distanceZ;
		matrixC[3] = (float) (pcs[0] * matrixB[0][0] + pcs[1] * matrixB[1][0] + pcs[2]
				* matrixB[2][0]);// 1350//150
		matrixC[7] = (float) (pcs[0] * matrixB[0][1] + pcs[1] * matrixB[1][1] + pcs[2]
				* matrixB[2][1]);// -150
		matrixC[11] = (float) (pcs[0] * matrixB[0][2] + pcs[1] * matrixB[1][2] + pcs[2]
				* matrixB[2][2]);// -150

		// create device pointers and allocate memory on the device
		Pointer dev_points = new Pointer();
		cudaMalloc(dev_points, 3 * Q_POINTS * Sizeof.INT);
		Pointer dev_polygons = new Pointer();
		cudaMalloc(dev_polygons, 3 * Q_POLYGONS * Sizeof.INT);
		Pointer dev_normals = new Pointer();
		cudaMalloc(dev_normals, 3 * Q_POLYGONS * Sizeof.INT);
		Pointer dev_matrixC = new Pointer();
		cudaMalloc(dev_matrixC, 12 * Sizeof.FLOAT);
		Pointer dev_shipLocationX = new Pointer();
		cudaMalloc(dev_shipLocationX, nShips * Sizeof.INT);
		Pointer dev_shipLocationZ = new Pointer();
		cudaMalloc(dev_shipLocationZ, nShips * Sizeof.INT);
		Pointer dev_S = new Pointer();
		cudaMalloc(dev_S, Q_POLYGONS * nShips * Sizeof.INT);
		Pointer dev_polygonToFillX = new Pointer();
		cudaMalloc(dev_polygonToFillX, 3 * Q_POLYGONS * nShips * Sizeof.INT);
		Pointer dev_polygonToFillY = new Pointer();
		cudaMalloc(dev_polygonToFillY, 3 * Q_POLYGONS * nShips * Sizeof.INT);

		// copy data from host to device. Pointer.to(pointsBase) - host pointer
		cudaMemcpy(dev_points, Pointer.to(pointsBaseCuda), 3 * Q_POINTS
				* Sizeof.INT, cudaMemcpyHostToDevice);
		cudaMemcpy(dev_polygons, Pointer.to(polygonsCuda), 3 * Q_POLYGONS
				* Sizeof.INT, cudaMemcpyHostToDevice);
		cudaMemcpy(dev_normals, Pointer.to(normalsCuda), 3 * Q_POLYGONS
				* Sizeof.INT, cudaMemcpyHostToDevice);
		cudaMemcpy(dev_matrixC, Pointer.to(matrixC), 12 * Sizeof.FLOAT,
				cudaMemcpyHostToDevice);
		cudaMemcpy(dev_shipLocationX, Pointer.to(shipLocationX), nShips
				* Sizeof.INT, cudaMemcpyHostToDevice);
		cudaMemcpy(dev_shipLocationZ, Pointer.to(shipLocationZ), nShips
				* Sizeof.INT, cudaMemcpyHostToDevice);

		// set cu-file
		KernelLauncher kernelLauncher = KernelLauncher.create(
				"data/cuSource/obtainPolygonsSteps.cu", "obtainPolygonsSteps",
				false);

		// parameters of CUDA-function
		int threadsPerBlock = 16;
		int blockPerGrid = (nShips + threadsPerBlock - 1) / threadsPerBlock;
		kernelLauncher.setGridSize(blockPerGrid, 1);
		kernelLauncher.setBlockSize(threadsPerBlock, 1, 1);

		// launch kernel to obtain visible polygons
		kernelLauncher.call(dev_S, dev_polygonToFillX, dev_polygonToFillY,
				dev_shipLocationX, dev_shipLocationZ, dev_matrixC, dev_points,
				dev_polygons, dev_normals, nShips);

		// copy data from device to host
		cudaMemcpy(Pointer.to(S), dev_S, Q_POLYGONS * nShips * Sizeof.INT,
				cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(polygonToFillX), dev_polygonToFillX, 3
				* Q_POLYGONS * nShips * Sizeof.INT, cudaMemcpyDeviceToHost);
		cudaMemcpy(Pointer.to(polygonToFillY), dev_polygonToFillY, 3
				* Q_POLYGONS * nShips * Sizeof.INT, cudaMemcpyDeviceToHost);

		// free memory on the device
		cudaFree(dev_points);
		cudaFree(dev_polygons);
		cudaFree(dev_normals);
		cudaFree(dev_matrixC);
		cudaFree(dev_shipLocationX);
		cudaFree(dev_shipLocationZ);
		cudaFree(dev_S);
		cudaFree(dev_polygonToFillX);
		cudaFree(dev_polygonToFillY);
	}

	// Turn on antialiasing.
	/**
	 * Включение антиалиасинга
	 */
	protected void setAntialiasing(Graphics2D g2) {
		g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
				RenderingHints.VALUE_ANTIALIAS_ON);
	}

	// draw one polygon in default color
	/**
	 * 
	 * @param g2
	 *            графический контент
	 * @param x
	 *            x-координаты точек полигона
	 * @param y
	 *            y-координаты точек полигона
	 * @param num
	 *            количество вершин в полигоне
	 */
	protected void makePolygon(Graphics2D g2, int x[], int y[], int num) {
		// Color cFigure = new Color(0, 255, 0);
		// Color cFill = new Color(255, 255, 255);
		Color cFigure = new Color(0, 255, 0);
		Color cFill = new Color(255, 255, 255);
		g2.setPaint(cFigure);
		g2.drawPolygon(x, y, num);
		g2.setPaint(cFill);
		g2.fillPolygon(x, y, num);
	}

	// draw polygons in default color
	/**
	 * 
	 * Выделяет три точки, разносит из координаты по массивам x и y
	 */
	protected void makeAllPolygons(Graphics2D g2) {
		for (int i = 0; i < Q_POLYGONS * nShips; i++) {
			if (S[i] == 1) {
				int[] x = new int[3];
				int[] y = new int[3];
				x[0] = polygonToFillX[3 * i];
				x[1] = polygonToFillX[3 * i + 1];
				x[2] = polygonToFillX[3 * i + 2];
				y[0] = polygonToFillY[3 * i];
				y[1] = polygonToFillY[3 * i + 1];
				y[2] = polygonToFillY[3 * i + 2];
				makePolygon(g2, x, y, 3);
			}
		}
	}

	@Override
	public void actionPerformed(ActionEvent arg0) {
		// TODO Auto-generated method stub
		craft.move();
		repaint();
	}

	/**
	 * Выполняет перерисовку экрана
	 */
	public void paint(Graphics g) {
		super.paint(g);

		Graphics2D g2 = (Graphics2D) g;
		// setAntialiasing(g2);
		psi = craft.getPsi();
		teta = craft.getTeta();
		gamma = craft.getGamma();
		distanceX = craft.getDistX();
		distanceY = craft.getDistY();
		distanceZ = craft.getDistZ();
		calc();
		makeAllPolygons(g2);
		new InfoPrint(g2, craft);
		Toolkit.getDefaultToolkit().sync();
		g.dispose();
	}

	/**
	 * Обрабатывает нажатие клавиш
	 * 
	 * @author Denis Vodolazskiy
	 * 
	 */
	private class TAdapter extends KeyAdapter {

		public void keyReleased(KeyEvent e) {
			craft.keyReleased(e);
		}

		public void keyPressed(KeyEvent e) {
			craft.keyPressed(e);
		}
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\properties\ComputerProperties.java

package ua.edu.donntu.cs.cuda.properties;

/**
 * Класс для вывода свойств в консоль. Не используется
 * 
 * @author Denis Vodolazskiy
 */
public class ComputerProperties {
	public ComputerProperties() {
		java.util.Properties properties = System.getProperties();
		// Вывод всех свойств.
		// properties.list(System.out);
		//
		// System.out.println(properties.getProperty("user.home"));
		System.out.println("User name: " + properties.getProperty("user.name"));
		// System.out.println("User country: "+properties.getProperty("user.country"));
		System.out.println("OS: " + properties.getProperty("os.name"));
		System.out.println("OS version: "
				+ properties.getProperty("os.version"));
		System.out.println("OS architecture: "
				+ properties.getProperty("os.arch"));
		System.out.println("Java version: "
				+ properties.getProperty("java.version"));
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\properties\JCudaDeviceQuery.java

package ua.edu.donntu.cs.cuda.properties;

import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_CLOCK_RATE;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_COMPUTE_MODE;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_ECC_ENABLED;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_INTEGRATED;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAX_PITCH;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_PCI_BUS_ID;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_TCC_DRIVER;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING;
import static jcuda.driver.CUdevice_attribute.CU_DEVICE_ATTRIBUTE_WARP_SIZE;
import static jcuda.driver.JCudaDriver.cuDeviceComputeCapability;
import static jcuda.driver.JCudaDriver.cuDeviceGet;
import static jcuda.driver.JCudaDriver.cuDeviceGetAttribute;
import static jcuda.driver.JCudaDriver.cuDeviceGetCount;
import static jcuda.driver.JCudaDriver.cuDeviceGetName;
import static jcuda.driver.JCudaDriver.cuInit;

import java.util.ArrayList;
import java.util.List;

import jcuda.driver.CUdevice;
import jcuda.driver.JCudaDriver;

/*
 * JCuda - Java bindings for NVIDIA CUDA driver and runtime API
 * http://www.jcuda.org
 *
 * Copyright 2011 Marco Hutter - http://www.jcuda.org
 */
/**
 * An example that queries and prints all attributes of all available devices
 * 
 * @author Marco Hutter
 */
public class JCudaDeviceQuery {
	/**
	 * Entry point of this program
	 * 
	 * @param args
	 *            Not used
	 */
	private String cudaProperties = "";

	public JCudaDeviceQuery() {
		JCudaDriver.setExceptionsEnabled(true);
		cuInit(0);

		// Obtain the number of devices
		int deviceCountArray[] = { 0 };
		cuDeviceGetCount(deviceCountArray);
		int deviceCount = deviceCountArray[0];
		// System.out.println("Found " + deviceCount + " devices");
		cudaProperties += "Found " + deviceCount + " NVIDIA devices" + "\n";

		for (int i = 0; i < deviceCount; i++) {
			CUdevice device = new CUdevice();
			cuDeviceGet(device, i);

			// Obtain the device name
			byte deviceName[] = new byte[1024];
			cuDeviceGetName(deviceName, deviceName.length, device);
			String name = createString(deviceName);

			// Obtain the compute capability
			int majorArray[] = { 0 };
			int minorArray[] = { 0 };
			cuDeviceComputeCapability(majorArray, minorArray, device);
			int major = majorArray[0];
			int minor = minorArray[0];

			// System.out.println("Device " + i + ": " + name +
			// " with Compute Capability " + major + "." + minor);
			cudaProperties += "Device " + i + ": " + name
					+ " with Compute Capability " + major + "." + minor
					+ "\n\n";

			// Obtain the device attributes
			int array[] = { 0 };
			List<Integer> attributes = getAttributes();
			for (Integer attribute : attributes) {
				String description = getAttributeDescription(attribute);
				cuDeviceGetAttribute(array, attribute, device);
				int value = array[0];

				// System.out.printf("    %-52s : %d\n", description, value);
				cudaProperties += String.format("   %-52s : %d\n", description,
						value);
			}
			cudaProperties += "\n\n";
		}
	}

	/**
	 * Returns a short description of the given CUdevice_attribute constant
	 * 
	 * @return A short description of the given constant
	 */
	private static String getAttributeDescription(int attribute) {
		switch (attribute) {
		case CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK:
			return "Maximum number of threads per block";
		case CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X:
			return "Maximum x-dimension of a block";
		case CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y:
			return "Maximum y-dimension of a block";
		case CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z:
			return "Maximum z-dimension of a block";
		case CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X:
			return "Maximum x-dimension of a grid";
		case CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y:
			return "Maximum y-dimension of a grid";
		case CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z:
			return "Maximum z-dimension of a grid";
		case CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK:
			return "Maximum shared memory per thread block in bytes";
		case CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY:
			return "Total constant memory on the device in bytes";
		case CU_DEVICE_ATTRIBUTE_WARP_SIZE:
			return "Warp size in threads";
		case CU_DEVICE_ATTRIBUTE_MAX_PITCH:
			return "Maximum pitch in bytes allowed for memory copies";
		case CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK:
			return "Maximum number of 32-bit registers per thread block";
		case CU_DEVICE_ATTRIBUTE_CLOCK_RATE:
			return "Clock frequency in kilohertz";
		case CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT:
			return "Alignment requirement";
		case CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT:
			return "Number of multiprocessors on the device";
		case CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT:
			return "Whether there is a run time limit on kernels";
		case CU_DEVICE_ATTRIBUTE_INTEGRATED:
			return "Device is integrated with host memory";
		case CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY:
			return "Device can map host memory into CUDA address space";
		case CU_DEVICE_ATTRIBUTE_COMPUTE_MODE:
			return "Compute mode";
		case CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH:
			return "Maximum 1D texture width";
		case CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH:
			return "Maximum 2D texture width";
		case CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT:
			return "aximum 2D texture height";
		case CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH:
			return "Maximum 3D texture width";
		case CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT:
			return "Maximum 3D texture height";
		case CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH:
			return "Maximum 3D texture depth";
		case CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH:
			return "Maximum 2D layered texture width";
		case CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT:
			return "Maximum 2D layered texture height";
		case CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS:
			return "Maximum layers in a 2D layered texture";
		case CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT:
			return "Alignment requirement for surfaces";
		case CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS:
			return "Device can execute multiple kernels concurrently";
		case CU_DEVICE_ATTRIBUTE_ECC_ENABLED:
			return "Device has ECC support enabled";
		case CU_DEVICE_ATTRIBUTE_PCI_BUS_ID:
			return "PCI bus ID of the device";
		case CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID:
			return "PCI device ID of the device";
		case CU_DEVICE_ATTRIBUTE_TCC_DRIVER:
			return "Device is using TCC driver model";
		case CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE:
			return "Peak memory clock frequency in kilohertz";
		case CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH:
			return "Global memory bus width in bits";
		case CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE:
			return "Size of L2 cache in bytes";
		case CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR:
			return "Maximum resident threads per multiprocessor";
		case CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT:
			return "Number of asynchronous engines";
		case CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING:
			return "Device shares a unified address space with the host";
		case CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH:
			return "Maximum 1D layered texture width";
		case CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS:
			return "Maximum layers in a 1D layered texture";
		case CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID:
			return "PCI domain ID of the device";
		}
		return "(UNKNOWN ATTRIBUTE)";
	}

	/**
	 * Returns a list of all CUdevice_attribute constants
	 * 
	 * @return A list of all CUdevice_attribute constants
	 */
	private static List<Integer> getAttributes() {
		List<Integer> list = new ArrayList<Integer>();
		list.add(CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK);
		list.add(CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X);
		list.add(CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y);
		list.add(CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z);
		list.add(CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X);
		list.add(CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y);
		list.add(CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z);
		list.add(CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK);
		list.add(CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY);
		list.add(CU_DEVICE_ATTRIBUTE_WARP_SIZE);
		list.add(CU_DEVICE_ATTRIBUTE_MAX_PITCH);
		list.add(CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK);
		list.add(CU_DEVICE_ATTRIBUTE_CLOCK_RATE);
		list.add(CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT);
		list.add(CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT);
		list.add(CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT);
		list.add(CU_DEVICE_ATTRIBUTE_INTEGRATED);
		list.add(CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY);
		list.add(CU_DEVICE_ATTRIBUTE_COMPUTE_MODE);
		list.add(CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH);
		list.add(CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH);
		list.add(CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT);
		list.add(CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH);
		list.add(CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT);
		list.add(CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH);
		list.add(CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH);
		list.add(CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT);
		list.add(CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS);
		list.add(CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT);
		list.add(CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS);
		list.add(CU_DEVICE_ATTRIBUTE_ECC_ENABLED);
		list.add(CU_DEVICE_ATTRIBUTE_PCI_BUS_ID);
		list.add(CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID);
		list.add(CU_DEVICE_ATTRIBUTE_TCC_DRIVER);
		list.add(CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE);
		list.add(CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH);
		list.add(CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE);
		list.add(CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR);
		list.add(CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT);
		list.add(CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING);
		list.add(CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH);
		list.add(CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS);
		list.add(CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID);
		return list;
	}

	/**
	 * Creates a String from a zero-terminated string in a byte array
	 * 
	 * @param bytes
	 *            The byte array
	 * @return The String
	 */
	private static String createString(byte bytes[]) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < bytes.length; i++) {
			char c = (char) bytes[i];
			if (c == 0) {
				break;
			}
			sb.append(c);
		}
		return sb.toString();
	}

	public String getCudaProperties() {
		return cudaProperties;
	}

}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\properties\ShowDeviceProperties.java

package ua.edu.donntu.cs.cuda.properties;

import java.awt.Dimension;
import java.awt.Font;
import java.awt.TextArea;
import java.awt.Toolkit;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.UIManager;

/**
 * Окно свойств системы
 * 
 * @author Denis Vodolazskiy
 */
public class ShowDeviceProperties extends JFrame {
	/**
	 * Панель для размещения компонентов
	 */
	private JPanel panel = new JPanel();

	/**
	 * Конструктор, задаёт расположение окна и его свойства. Выводит свойства в
	 * текстовую область
	 */
	public ShowDeviceProperties() {
		super("Свойства системы:");
		// System Look-And-Feel:
		try {
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (Exception e) {
			// Exception handle
		}
		panel.setLayout(null);
		setSize(600, 650); // задание размеров
		setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); // задание параметров
															// // главного окна
															// при закрытии

		Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();
		int width = getSize().width;
		int height = getSize().height;
		int x = (dim.width - width) / 2;
		int y = (dim.height - height) / 2;
		setLocation(x, y);
		//
		TextArea ta = new TextArea();
		ta.setSize(width, height);
		Font font = new Font(Font.MONOSPACED, 1, 13);
		ta.setFont(font);
		//
		String compProperties = "";
		java.util.Properties properties = System.getProperties();
		compProperties += String.format("   %-20s %s", "User name: ",
				properties.getProperty("user.name") + "\n");
		compProperties += String.format("   %-20s %s", "OS: ",
				properties.getProperty("os.name") + "\n");
		compProperties += String.format("   %-20s %s", "OS version: ",
				properties.getProperty("os.version") + "\n");
		compProperties += String.format("   %-20s %s", "OS architecture: ",
				properties.getProperty("os.arch") + "\n");
		compProperties += String.format("   %-20s %s", "Java version: ",
				properties.getProperty("java.version") + "\n");
		compProperties += "\n";
		//

		ta.setText(compProperties + new JCudaDeviceQuery().getCudaProperties());
		ta.setCaretPosition(0);
		ta.setEditable(false);
		panel.add(ta);
		//
		setResizable(false);
		setVisible(true);
		setContentPane(panel);
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\service\CUDATiming.java

/*Class to view time of CUDA-execution*/
package ua.edu.donntu.cs.cuda.service;

import jcuda.CudaException;
import jcuda.driver.JCudaDriver;
import jcuda.runtime.JCuda;
import jcuda.runtime.cudaEvent_t;
import jcuda.runtime.cudaStream_t;

/**
 * Class, to provide CUDA-timing methods.<br>
 * Altough it is possible to reuse an object of this class it has not been
 * tested extensively and it is advised to instantiate a new object for every
 * timing.
 * 
 * @author Manuel Schaeidt
 * @version $Date$ - $Rev$
 */
public final class CUDATiming {

	/**
	 * Start-Event
	 */
	private cudaEvent_t start;

	/**
	 * Stop-Event
	 */
	private cudaEvent_t stop;

	/**
	 * Stream-Object
	 */
	private cudaStream_t stream;

	/**
	 * Standard-constructor, activates exceptions
	 */
	public CUDATiming() {
		this(new cudaStream_t());
	}

	/**
	 * Full-constructor, activates exceptions
	 * 
	 * @param stream
	 *            Stream-Object for this timing
	 */
	public CUDATiming(cudaStream_t stream) {
		this.start = new cudaEvent_t();
		this.stop = new cudaEvent_t();
		this.stream = stream;

		// Enable exceptions
		JCuda.setExceptionsEnabled(true);
		JCudaDriver.setExceptionsEnabled(true);
	}

	/**
	 * Starts a CUDA-Timing
	 * 
	 * @throws CudaException
	 *             If an error occured
	 */
	public void startTiming() throws CudaException {

		// Create events
		JCuda.cudaEventCreate(this.start);
		JCuda.cudaEventCreate(this.stop);

		// Start recording
		JCuda.cudaEventRecord(this.start, this.stream);
	}

	/**
	 * Stops a CUDA-Timing
	 * 
	 * @return Duration in ms rounded to 0.5 micro-seconds
	 * @throws CudaException
	 *             If an error occured
	 */
	public float stopTiming() throws CudaException {
		float[] elapsedTime = new float[1];

		// Stop recording
		JCuda.cudaEventRecord(this.stop, this.stream);
		JCuda.cudaEventSynchronize(this.stop);

		// Calculate duration
		JCuda.cudaEventElapsedTime(elapsedTime, this.start, this.stop);

		// Free memory
		JCuda.cudaEventDestroy(this.start);
		JCuda.cudaEventDestroy(this.stop);

		return elapsedTime[0];
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\cuda\service\TransformArray.java

/*Transforms 2D array in 1D array*/
package ua.edu.donntu.cs.cuda.service;


/**
 * Класс для преобразования двумерного массива в одномерный. Функции JCUDA
 * работают только с одномерными массивами
 * 
 * @author Denis Vodolazskiy
 */
public class TransformArray {
	/**
	 * Преобразование двумерного массива в одномерный
	 * 
	 * @return одномерный массив
	 * @param b
	 *            двумерный массив
	 * @param N
	 *            размерность второго измерения
	 */
	public int[] in1D(int[][] b, int N) {
		int a[] = new int[3 * N];
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < 3; j++) {
				a[3 * i + j] = b[i][j];
			}
		}
		return a;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\draw\animation\AnimateShip.java

/*Class to animate 1 ship*/
package ua.edu.donntu.cs.draw.animation;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Toolkit;

import ua.edu.donntu.cs.draw.main.DrawShip;
import ua.edu.donntu.cs.service.transform_pixels_meters.MetMmTransform;

/**
 * Панель для анимации (вращения) одного объекта
 * 
 * @author Denis Vodolazskiy
 */
public class AnimateShip extends DrawShip implements Runnable {

	private static final long serialVersionUID = 1L;
	//
	private Thread animator;
	private final int DELAY = 20;

	/**
	 * Конструктор
	 */
	public AnimateShip() {
		// decrease default distance
		distanceX = new MetMmTransform().meter2mm(-205);//-80
		Color cBack = new Color(0, 0, 0);
		setBackground(cBack);
		setDoubleBuffered(true);
	}

	/**
	 * Создание потока
	 */
	public void addNotify() {
		super.addNotify();
		animator = new Thread(this);
		animator.start();
	}

	/**
	 * инкремент угла пси
	 */
	private void cycle() {
		psi++;
	}

	/**
	 * Перерисовка экрана
	 */
	@Override
	public void paint(Graphics g) {
		super.paint(g);

		Graphics2D g2 = (Graphics2D) g;
		// setAntialiasing(g2);

		calc(points, polygons, normals, pr);

		makeAllPolygons(g2);

		Toolkit.getDefaultToolkit().sync();
		g.dispose();
	}

	/**
	 * Запуск потока
	 */
	public void run() {
		long beforeTime, timeDiff, sleep;

		beforeTime = System.currentTimeMillis();

		while (true) {

			cycle();
			repaint();

			timeDiff = System.currentTimeMillis() - beforeTime;
			sleep = DELAY - timeDiff;

			if (sleep < 0) {// delay (sleep) must be positive
				sleep = 2;
			}
			try {
				Thread.sleep(sleep);
			} catch (InterruptedException e) {
				System.out.println("interrupted");
			}

			beforeTime = System.currentTimeMillis();
		}
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\draw\animation\SwimShipThread.java

package ua.edu.donntu.cs.draw.animation;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Toolkit;

import ua.edu.donntu.cs.draw.main.DrawShip;
import ua.edu.donntu.cs.path.calculations_kutt.Coordinates;
import ua.edu.donntu.cs.service.transform_pixels_meters.MetMmTransform;

/**
 * Панель для анимации (плывёт) одного объекта
 * 
 * @author Denis Vodolazskiy
 */
public class SwimShipThread extends DrawShip implements Runnable {

	private static final long serialVersionUID = 1L;
	//
	private Thread animator;
	private final int DELAY = 5;
	private int i = 0;
	private int distX = new MetMmTransform().meter2mm(1000);// +

	/**
	 * Конструктор
	 */
	public SwimShipThread() {
		// decrease default distance
		Color cBack = new Color(0, 0, 0);
		setBackground(cBack);
		setDoubleBuffered(true);
	}

	/**
	 * Создание потока
	 */
	public void addNotify() {
		super.addNotify();
		animator = new Thread(this);
		animator.start();
	}

	/**
	 * Изменение координат и угла пси
	 * 
	 * @param i
	 *            шаг
	 */
	public void cycle(int i) {
		// psi++;
		if (i < new Coordinates().byX().length) {
			distanceX = -(new MetMmTransform().meter2mm(new Coordinates()
					.byX()[i]) + distX);
			distanceZ = -(new MetMmTransform().meter2mm(new Coordinates()
					.byZ()[i]));
			// *3
			psi = (float) (180 * (new Coordinates().byW()[i]) / (Math.PI * 3));
			// System.out.println(new Coordinates().byX()[i]);
			// System.out.println(new Coordinates().byZ()[i]);
			// System.out.println(new Coordinates().byW()[i]);
		}
	}

	/**
	 * Перерисовка экрана
	 */
	@Override
	public void paint(Graphics g) {
		super.paint(g);

		Graphics2D g2 = (Graphics2D) g;
		// setAntialiasing(g2);

		calc(points, polygons, normals, pr);

		makeAllPolygons(g2);

		Toolkit.getDefaultToolkit().sync();
		g.dispose();
	}

	/**
	 * Запуск потока
	 */
	public void run() {
		long beforeTime, timeDiff, sleep;

		beforeTime = System.currentTimeMillis();

		while (true) {

			cycle(i);
			i++;
			repaint();

			timeDiff = System.currentTimeMillis() - beforeTime;
			sleep = DELAY - timeDiff;

			if (sleep < 0) {// delay (sleep) must be positive
				sleep = 2;
			}
			try {
				Thread.sleep(sleep);
			} catch (InterruptedException e) {
				System.out.println("interrupted");
			}

			beforeTime = System.currentTimeMillis();
		}
	}

}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\draw\information\InfoPrint.java

/*Information about keys and current state of object*/
package ua.edu.donntu.cs.draw.information;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;

import ua.edu.donntu.cs.key_manager.Craft;
import ua.edu.donntu.cs.ray.ray_key_manager.CraftFast;
import ua.edu.donntu.cs.service.transform_pixels_meters.MetMmTransform;

/**
 * Этот класс выводит на панель пояснения по упралению объектами
 * 
 * @author Denis Vodolazskiy
 */
public class InfoPrint {
	private Graphics2D g2;
	private Craft craft;

	/**
	 * Конструктор класса InfoPrint
	 * 
	 * @param g2
	 *            графический контент
	 * @param craft
	 *            менеджер клавиатуры
	 */
	public InfoPrint(Graphics2D g2, Craft craft) {
		this.g2 = g2;
		this.craft = craft;
		Font font = new Font("Serif", Font.PLAIN, 14);
		Color words = new Color(255, 0, 255);
		g2.setPaint(words);
		g2.setFont(font);
		g2.drawString("\u2190 psi--", 10, 20);
		g2.drawString("\u2192 psi++", 140, 20);
		g2.drawString("\u2191 gamma--", 10, 40);
		g2.drawString("\u2193 gamma++", 140, 40);
		g2.drawString("PageUP   teta--", 10, 60);
		g2.drawString("PageDown   teta++", 140, 60);
		g2.drawString("F12   distanceX--", 10, 80);
		g2.drawString("F11   distanceX++", 140, 80);
		g2.drawString("F8   distanceZ--", 10, 100);
		g2.drawString("F7   distanceZ++", 140, 100);
		g2.drawString("F6   distanceY--", 10, 120);
		g2.drawString("F5   distanceY++", 140, 120);
		g2.drawString(
				"distX = "
						+ new MetMmTransform().mm2meter(craft.getDistX())
						+ " m", 10, 140);
		g2.drawString(
				"distY = "
						+ new MetMmTransform().mm2meter(craft.getDistY())
						+ " m", 140, 140);
		g2.drawString(
				"distZ = "
						+ new MetMmTransform().mm2meter(craft.getDistZ())
						+ " m", 10, 160);
		// Axes
		g2.drawLine(600, 10, 600, 60);
		g2.drawLine(595, 20, 600, 10);
		g2.drawLine(605, 20, 600, 10);
		g2.drawString("X", 615, 20);
		g2.drawLine(600, 60, 650, 60);
		g2.drawLine(640, 55, 650, 60);
		g2.drawLine(640, 65, 650, 60);
		g2.drawString("Z", 660, 70);

	}
        /**
	 * Конструктор класса InfoPrint (CraftFast)
	 * 
	 * @param g2
	 *            графический контент
	 * @param craft
	 *            менеджер клавиатуры
	 */
	public InfoPrint(Graphics2D g2, CraftFast craft) {
		this.g2 = g2;		
		Font font = new Font("Serif", Font.PLAIN, 14);
		Color words = new Color(255, 0, 255);
		g2.setPaint(words);
		g2.setFont(font);
		g2.drawString("\u2190 psi--", 10, 20);
		g2.drawString("\u2192 psi++", 140, 20);
		g2.drawString("\u2191 gamma--", 10, 40);
		g2.drawString("\u2193 gamma++", 140, 40);
		g2.drawString("PageUP   teta--", 10, 60);
		g2.drawString("PageDown   teta++", 140, 60);
		g2.drawString("F12   distanceX--", 10, 80);
		g2.drawString("F11   distanceX++", 140, 80);
		g2.drawString("F8   distanceZ--", 10, 100);
		g2.drawString("F7   distanceZ++", 140, 100);
		g2.drawString("F6   distanceY--", 10, 120);
		g2.drawString("F5   distanceY++", 140, 120);
		g2.drawString(
				"distX = "
						+ new MetMmTransform().mm2meter(craft.getDistX())
						+ " m", 10, 140);
		g2.drawString(
				"distY = "
						+ new MetMmTransform().mm2meter(craft.getDistY())
						+ " m", 140, 140);
		g2.drawString(
				"distZ = "
						+ new MetMmTransform().mm2meter(craft.getDistZ())
						+ " m", 10, 160);
		// Axes
		g2.drawLine(600, 10, 600, 60);
		g2.drawLine(595, 20, 600, 10);
		g2.drawLine(605, 20, 600, 10);
		g2.drawString("X", 615, 20);
		g2.drawLine(600, 60, 650, 60);
		g2.drawLine(640, 55, 650, 60);
		g2.drawLine(640, 65, 650, 60);
		g2.drawString("Z", 660, 70);

	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\draw\information\InfoSwimPrint.java

package ua.edu.donntu.cs.draw.information;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;

import ua.edu.donntu.cs.key_manager.Craft;
import ua.edu.donntu.cs.service.transform_pixels_meters.MetMmTransform;

/**
 * Этот класс выводит на панель пояснения по упралению объектами и текущее
 * состояние объектов
 * 
 * @author Denis Vodolazskiy
 */
public class InfoSwimPrint {
	private Graphics2D g2;
	private Craft craft;

	/**
	 * Конструктор
	 * 
	 * @param g2
	 *            графический контент
	 * @param craft
	 *            менеджер клавиатуры
	 * @param xObs
	 *            x-координата в системе наблюдателя
	 * @param zObs
	 *            z-координата в системе наблюдателя
	 * @param xFixed
	 *            x-координата в мировой системе
	 * @param zFixed
	 *            z-координата в мировой системе
	 * @param VxShip
	 *            скорость корабля по оси X
	 * @param VzShip
	 *            скорость корабля по оси Z
	 * @param Rcirculation
	 *            радиус циркуляции
	 */
	public InfoSwimPrint(Graphics2D g2, Craft craft, int xObs, int zObs,
			int xFixed, int zFixed, double VxShip, double VzShip,
			double Rcirculation) {
		this.g2 = g2;
		this.craft = craft;

		// for double
		DecimalFormatSymbols decimalFormatSymbols = new DecimalFormatSymbols();
		decimalFormatSymbols.setDecimalSeparator('.');
		decimalFormatSymbols.setGroupingSeparator(',');
		DecimalFormat decimalFormat = new DecimalFormat("#,##0.00",
				decimalFormatSymbols);

		Font font = new Font("Serif", Font.PLAIN, 14);
		Color words = new Color(255, 0, 255);
		g2.setPaint(words);
		g2.setFont(font);
		g2.drawString("xObs = " + new MetMmTransform().mm2meter(-xObs)// -
				+ " m", 10, 20);
		g2.drawString("zObs = " + new MetMmTransform().mm2meter(-zObs)// -
				+ " m", 140, 20);
		g2.drawString("xFixed = " + new MetMmTransform().mm2meter(xFixed)
				+ " m", 270, 20);
		g2.drawString("zFixed = " + new MetMmTransform().mm2meter(zFixed)
				+ " m", 410, 20);
		g2.drawString(
				"dObsX = "
						+ new MetMmTransform().mm2meter(-craft.getDistX())// -
						+ " m", 10, 40);
		g2.drawString(
				"dObsY = "
						+ new MetMmTransform().mm2meter(craft.getDistY())
						+ " m", 140, 40);
		g2.drawString(
				"dObsZ = "
						+ new MetMmTransform().mm2meter(-craft.getDistZ())// -
						+ " m", 10, 60);
		g2.drawString("Rcirc = " + decimalFormat.format(Rcirculation) + " m",
				140, 60);
		g2.drawString("VxShip = " + decimalFormat.format(VxShip) + " m/s", 270,
				40);
		g2.drawString("VzShip = " + decimalFormat.format(VzShip) + " m/s", 410,
				40);
		g2.drawString("F12  distX++", 10, 80);
		g2.drawString("F11  distX--", 140, 80);
		g2.drawString("F8    distZ++", 10, 100);
		g2.drawString("F7    distZ--", 140, 100);
		g2.drawString("F6    distY++", 10, 120);
		g2.drawString("F5    distY--", 140, 120);
		// Axes
		g2.drawLine(600, 10, 600, 60);
		g2.drawLine(595, 20, 600, 10);
		g2.drawLine(605, 20, 600, 10);
		g2.drawString("X", 615, 20);
		g2.drawLine(600, 60, 650, 60);
		g2.drawLine(640, 55, 650, 60);
		g2.drawLine(640, 65, 650, 60);
		g2.drawString("Z", 660, 70);

	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\draw\main\DrawShip.java

/*This class contains base instruments to calculate and draw*/
package ua.edu.donntu.cs.draw.main;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.RenderingHints;

import javax.swing.JPanel;

import ua.edu.donntu.cs.draw.matrix_transform.MatrixTransform;
import ua.edu.donntu.cs.inout.IPrepareData;
import ua.edu.donntu.cs.service.transform_pixels_meters.MetMmTransform;

/**
 * Базовая пнель для отрисовки кораблей. Суперкласс
 *
 * @author Denis Vodolazskiy
 */
public class DrawShip extends JPanel implements IPrepareData {

    /**
     *
     */
    private static final long serialVersionUID = 1L;
    // start corners
    protected float psi = 0;// -30;
    protected float teta = 0;// 30;
    protected float gamma = 0;
    protected int pr = 1;
    protected boolean Vis[] = new boolean[Q_POLYGONS];
    protected int polygonToFillX[][] = new int[Q_POLYGONS][3];
    protected int polygonToFillY[][] = new int[Q_POLYGONS][3];
    // start distances
    protected int distanceX = new MetMmTransform().meter2mm(-500);// 60000;
    protected int distanceY = 0;
    protected int distanceZ = 0;

    /**
     * Конструктор суперкласса отрисовки кораблей
     */
    public DrawShip() {
    }

    /**
     * Сокращённый println
     *
     * @param string строка для вывода
     */
    protected void p(Object string) {
        System.out.println(string);
    }

    // obtain visible polygons
    /**
     * Функции для определения видимых полигонов
     */
    protected void calc(int points[][], int polygons[][], int normals[][],
            int pr) {
        // if (distanceX>new MetPixTransform().meter2pixel(-1)){
        // if (distanceX>points[25][0]||distanceX>points[15][0]){
        // for (int i = 0; i < Q_POLYGONS; i++) {
        // Vis[i] = false;
        // }
        // }else{
        // matrix A B C
        double matrixA[][] = new double[3][3];
        MatrixTransform mt = new MatrixTransform();
        matrixA = mt.matr(psi, teta, gamma, 1);
        double matrixB[][] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
        double matrixC[][] = new double[3][4];
        double pcs[] = {0, 0, 0};// вектор сцены 0,0,0

        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                matrixC[i][j] = matrixA[i][0] * matrixB[j][0] + matrixA[i][1]
                        * matrixB[j][1] + matrixA[i][2] * matrixB[j][2];
            }
        }
        pcs[0] = pcs[0] - distanceX;
        pcs[1] = pcs[1] - distanceY;
        pcs[2] = pcs[2] - distanceZ;
        matrixC[0][3] = pcs[0] * matrixB[0][0] + pcs[1] * matrixB[1][0]
                + pcs[2] * matrixB[2][0];// 1350//150
        matrixC[1][3] = pcs[0] * matrixB[0][1] + pcs[1] * matrixB[1][1]
                + pcs[2] * matrixB[2][1];// -150
        matrixC[2][3] = pcs[0] * matrixB[0][2] + pcs[1] * matrixB[1][2]
                + pcs[2] * matrixB[2][2];// -150

        // observer coordinates
        double observerCoord[][] = new double[Q_POINTS][3];
        for (int i = 0; i < Q_POINTS; i++) {
            observerCoord[i][0] = points[i][0] * matrixC[0][0] + points[i][1]
                    * matrixC[0][1] + points[i][2] * matrixC[0][2]
                    + matrixC[0][3];
            observerCoord[i][1] = points[i][0] * matrixC[1][0] + points[i][1]
                    * matrixC[1][1] + points[i][2] * matrixC[1][2]
                    + matrixC[1][3];
            observerCoord[i][2] = points[i][0] * matrixC[2][0] + points[i][1]
                    * matrixC[2][1] + points[i][2] * matrixC[2][2]
                    + matrixC[2][3];
        }

        // 2d
        double to2d[][] = new double[Q_POINTS][2];
        for (int i = 0; i < Q_POINTS; i++) {
            to2d[i][0] = 0.6 * observerCoord[i][2] / observerCoord[i][0];//d0=0.6
            to2d[i][1] = 0.6 * observerCoord[i][1] / observerCoord[i][0];
        }
        // to2dmm
        double to2dmm[][] = new double[Q_POINTS][2];
        for (int i = 0; i < Q_POINTS; i++) {
            to2dmm[i][0] = 160 * to2d[i][0];//Xe=160mm, a0=1m; S=Xe/a0=160
            to2dmm[i][1] = 160 * to2d[i][1];//Ye=160mm, b0=1m; S=Ye/b0=160
        }
        // spX, spY
        int spX[] = new int[Q_POINTS];
        int spY[] = new int[Q_POINTS];
        for (int i = 0; i < Q_POINTS; i++) {
            spX[i] = (int) Math.round(4.35 * to2dmm[i][0]);//700/160=4.35
            spY[i] = (int) Math.round(4.35 * to2dmm[i][1]);//700/160=4.35
        }

        // xp,yp
        int xp[] = new int[Q_POINTS];
        int yp[] = new int[Q_POINTS];
        for (int i = 0; i < Q_POINTS; i++) {
            xp[i] = spX[i] + 350;
            yp[i] = -spY[i] + 350;
        }

        // Nvec obs
        double NormalObs[][] = new double[Q_POLYGONS][3];
        for (int i = 0; i < Q_POLYGONS; i++) {
            NormalObs[i][0] = normals[i][0] * matrixC[0][0] + normals[i][1]
                    * matrixC[0][1] + normals[i][2] * matrixC[0][2];
            NormalObs[i][1] = normals[i][0] * matrixC[1][0] + normals[i][1]
                    * matrixC[1][1] + normals[i][2] * matrixC[1][2];
            NormalObs[i][2] = normals[i][0] * matrixC[2][0] + normals[i][1]
                    * matrixC[2][1] + normals[i][2] * matrixC[2][2];
        }

        // vector V
        double V[][] = new double[Q_POINTS][3];
        V = observerCoord;

        // S
        double S[] = new double[Q_POLYGONS];
        for (int i = 0; i < Q_POLYGONS; i++) {
            S[i] = NormalObs[i][0] * V[polygons[i][0]][0] + NormalObs[i][1]
                    * V[polygons[i][0]][1] + NormalObs[i][2]
                    * V[polygons[i][0]][2];
        }

        // visibility
        for (int i = 0; i < Q_POLYGONS; i++) {
            if (S[i] < 0) {
                Vis[i] = true;
            } else {
                Vis[i] = false;
            }
        }

        // points to draw
        for (int i = 0; i < Q_POLYGONS; i++) {
            polygonToFillX[i][0] = xp[polygons[i][0]];
            polygonToFillX[i][1] = xp[polygons[i][1]];
            polygonToFillX[i][2] = xp[polygons[i][2]];

            polygonToFillY[i][0] = yp[polygons[i][0]];
            polygonToFillY[i][1] = yp[polygons[i][1]];
            polygonToFillY[i][2] = yp[polygons[i][2]];

        }
        // }
    }

    // Turn on antialiasing
    /**
     * Включение антиалиасинга
     */
    protected void setAntialiasing(Graphics2D g2) {
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                RenderingHints.VALUE_ANTIALIAS_ON);
    }

    // draw polygons in default color
    /**
     *
     * Выделяет три точки, разносит из координаты по массивам polygonToFillX и
     * polygonToFillY
     */
    protected void makeAllPolygons(Graphics2D g2) {
        for (int i = 0; i < Q_POLYGONS; i++) {
            if (Vis[i]) {
                makePolygon(g2, polygonToFillX[i], polygonToFillY[i], 3);
            }
        }
    }

    // draw polygons in set color
    /**
     *
     * Выделяет три точки, разносит из координаты по массивам polygonToFillX и
     * polygonToFillY, передаёт цвет
     */
    protected void makeAllPolygons(Graphics2D g2, Color col) {
        for (int i = 0; i < Q_POLYGONS; i++) {
            if (Vis[i]) {
                makePolygon(g2, polygonToFillX[i], polygonToFillY[i], 3, col);
            }
        }
    }

    // draw one polygon in default color
    /**
     * draw one polygon in default color
     * @param g2 графический контент
     * @param x x-координаты точек полигона
     * @param y y-координаты точек полигона
     * @param num количество вершин в полигоне
     */
    protected void makePolygon(Graphics2D g2, int x[], int y[], int num) {
        Color cFigure = new Color(0, 255, 0);
        Color cFill = new Color(255, 255, 255);
        g2.setPaint(cFigure);
        g2.drawPolygon(x, y, num);
        g2.setPaint(cFill);
        g2.fillPolygon(x, y, num);
    }

    // draw one polygon in set color
    /**
     * draw one polygon in set color
     * @param g2 графический контент
     * @param x x-координаты точек полигона
     * @param y y-координаты точек полигона
     * @param num количество вершин в полигоне
     * @param col цвет полигонов
     */
    protected void makePolygon(Graphics2D g2, int x[], int y[], int num,
            Color col) {
        g2.setPaint(col);
        g2.fillPolygon(x, y, num);
    }
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\draw\main\StartDrawClass.java

/*Class to set window properties*/
package ua.edu.donntu.cs.draw.main;

import java.awt.Dimension;

import javax.swing.JFrame;
import javax.swing.JPanel;

/**
 * Окно для панели с отрисовкой кораблей
 * 
 * @author Denis Vodolazskiy
 */
public class StartDrawClass extends JFrame {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	JPanel jp;

	/**
	 * Конструктор, задаёт расположение окна и его свойства
	 */
	public StartDrawClass(JPanel jp) {
		this.jp = jp;
		add(jp);
		setTitle("Ship 9.1");
		setSize(new Dimension(700, 700));
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		setLocationRelativeTo(null);
		setResizable(false);
		setVisible(true);
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\draw\matrix_transform\MatrixTransform.java

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ua.edu.donntu.cs.draw.matrix_transform;

/**
 * Класс для преобразования локальной и глобальной матрицы
 * 
 * @author Denis Vodolazskiy
 */
public class MatrixTransform {

	// ---------------Transformation
	// Matrix-----------------------------------------
	/**
	 * Функция для преобразования данных локальной и глобальной матриц
	 * 
	 * @param psi
	 *            угол пси (вокруг оси Y)
	 * @param teta
	 *            угол тэта (вокруг оси Z)
	 * @param gamma
	 *            угол гамма (вокруг оси X)
	 * @param pr
	 *            приоритет (1 или 2)
	 * @return преобразованная матрица
	 */
	public double[][] matr(double psi, double teta, double gamma, int pr) {
		double m[][] = new double[3][3]; // опис
		{
			m[0][0] = m[1][1] = m[2][2] = 1;
			m[1][0] = m[0][1] = m[1][2] = 0;
			m[2][0] = m[2][1] = m[0][2] = 0;
		}
		// double psi = 0, gamma = 0, teta = 0;// – кути системи
		// координат, град;
		// double pr = 1;// - тип матриці
		// pr=1 з локальної до глобальної (типу A)
		// pr=2 з глобальної до локальної (типу В)
		double psir, ter, gammar;
		double psi_s, psi_c;
		double te_s, te_c;
		double gamma_s, gamma_c;
		double psigamma_ss, psigamma_sc, psigamma_cs, psigamma_cc;
		// градуси до радіан 0,017454=3.14/180
		psir = psi * 0.017454;
		ter = teta * 0.017454;
		gammar = gamma * 0.017454;
		// sin and cos
		psi_c = Math.cos(psir);
		psi_s = Math.sin(psir);
		te_c = Math.cos(ter);
		te_s = Math.sin(ter);
		gamma_c = Math.cos(gammar);
		gamma_s = Math.sin(gammar);
		// часткові додатки, які
		// використовуються двічі
		psigamma_ss = psi_s * gamma_s;
		psigamma_cc = psi_c * gamma_c;
		psigamma_sc = psi_s * gamma_c;
		psigamma_cs = psi_c * gamma_s;
		if (pr == 1) {
			m[0][0] = psi_c * te_c;
			m[0][1] = psigamma_ss - psigamma_cc * te_s;
			m[0][2] = psigamma_cs * te_s + psigamma_sc;
			m[1][0] = te_s;
			m[1][1] = te_c * gamma_c;
			m[1][2] = -te_c * gamma_s;
			m[2][0] = -psi_s * te_c;
			m[2][1] = te_s * psigamma_sc + psigamma_cs;
			m[2][2] = psigamma_cc - te_s * psigamma_ss;
		}
		// трансформована матриця
		if (pr == 2) {
			m[0][0] = te_c * psi_c;
			m[0][1] = te_s;
			m[0][2] = -te_c * psi_s;
			m[1][0] = psigamma_ss - psigamma_cc * te_s;
			m[1][1] = gamma_c * te_c;
			m[1][2] = psigamma_sc * te_s + psigamma_cs;
			m[2][0] = psigamma_cs * te_s + psigamma_sc;
			m[2][1] = -gamma_s * te_c;
			m[2][2] = psigamma_cc - psigamma_ss * te_s;
		}
		return m;
	}

}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\draw\move\MoveShip.java

/*This class allows to move 1 ship*/
package ua.edu.donntu.cs.draw.move;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;

import javax.swing.Timer;

import ua.edu.donntu.cs.draw.information.InfoPrint;
import ua.edu.donntu.cs.draw.main.DrawShip;
import ua.edu.donntu.cs.key_manager.Craft;
import ua.edu.donntu.cs.service.transform_pixels_meters.MetMmTransform;

/**
 * Класс управляет неподвижным кораблём
 * 
 * @author Denis Vodolazskiy
 */
public class MoveShip extends DrawShip implements ActionListener {

	private static final long serialVersionUID = 1L;
	//
	private Timer timer;
	private Craft craft;

	/**
	 * Конструктор для управления неподвижным кораблём
	 * 
	 */
	public MoveShip() {
		// decrease default distance
		final int distX = new MetMmTransform().meter2mm(-150);//-165
		addKeyListener(new TAdapter());
		setFocusable(true);
		setBackground(Color.BLACK);
		// Color cFill = new Color(20, 80, 255);
		// setBackground(cFill);
		setDoubleBuffered(true);
		// init key_manager
		craft = new Craft(psi, teta, gamma, distX, distanceY, distanceZ);
		// init delay between key events
		timer = new Timer(5, this);
		timer.start();
	}

        @Override
	public void actionPerformed(ActionEvent e) {
		craft.move();
		repaint();
	}

	/**
	 * Выполняет перерисовку экрана
	 */
	@Override
	public void paint(Graphics g) {
		super.paint(g);

		Graphics2D g2 = (Graphics2D) g;
		// setAntialiasing(g2);
		psi = craft.getPsi();
		teta = craft.getTeta();
		gamma = craft.getGamma();
		distanceX = craft.getDistX();
		distanceY = craft.getDistY();
		distanceZ = craft.getDistZ();
		// make calculations
		calc(points, polygons, normals, pr);
		// draw polygons
		makeAllPolygons(g2);
		// draw information
		new InfoPrint(g2, craft);
		Toolkit.getDefaultToolkit().sync();
		g.dispose();
	}

	// key adapter
	/**
	 * Обрабатывает нажатие клавиш
	 * 
	 * @author Denis Vodolazskiy
	 * 
	 */
	private class TAdapter extends KeyAdapter {

                @Override
		public void keyReleased(KeyEvent e) {
			craft.keyReleased(e);
		}

                @Override
		public void keyPressed(KeyEvent e) {
			craft.keyPressed(e);
		}
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\draw\move\SwimShip.java

package ua.edu.donntu.cs.draw.move;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;

import javax.swing.Timer;

import ua.edu.donntu.cs.draw.information.InfoSwimPrint;
import ua.edu.donntu.cs.draw.main.DrawShip;
import ua.edu.donntu.cs.key_manager.Craft;
import ua.edu.donntu.cs.path.calculations_kutt.Coordinates;
import ua.edu.donntu.cs.service.transform_pixels_meters.MetMmTransform;

/**
 * Класс управляет движущимся кораблём
 * 
 * @author Denis Vodolazskiy
 */
public class SwimShip extends DrawShip implements ActionListener {

	private static final long serialVersionUID = 1L;
	private int i = 0;
	private int obsDistX = new MetMmTransform().meter2mm(1000);// здесь
																	// положительное
																	// число!!!
	private int shipDistX = 0;
	private int shipDistZ = 0;
	private double shipSpeedX = 0;
	private double shipSpeedZ = 0;
	//
	private Timer timer;
	private Craft craft;
	//
	private Coordinates coord = new Coordinates();

	/**
	 * Конструктор для управления движущимся кораблём
	 * 
	 */
	public SwimShip() {

		addKeyListener(new TAdapter());
		setFocusable(true);
		setBackground(Color.BLACK);
		// Color cFill = new Color(20, 80, 255);
		// setBackground(cFill);
		setDoubleBuffered(true);

		// init key_manager
		craft = new Craft(psi, teta, gamma, obsDistX, distanceY, distanceZ);
		// init delay between key events
		timer = new Timer(5, this);
		timer.start();
	}

	@Override
	public void actionPerformed(ActionEvent e) {

		//
		cycle(i);
		i++;
		craft.move();
		//
		repaint();
	}

	@Override
	/**
	 * Выполняет перерисовку экрана
	 */
	public void paint(Graphics g) {
		super.paint(g);

		Graphics2D g2 = (Graphics2D) g;

		// setAntialiasing(g2);
		// psi = craft.getPsi();
		// teta = craft.getTeta();
		// gamma = craft.getGamma();
		distanceX = -(shipDistX + craft.getDistX());
		distanceY = craft.getDistY();
		distanceZ = -(shipDistZ + craft.getDistZ());
		// make calculations
		calc(points, polygons, normals, pr);
		// draw polygons
		makeAllPolygons(g2);
		// draw information
		new InfoSwimPrint(g2, craft, distanceX, distanceZ, shipDistX,
				shipDistZ, shipSpeedX, shipSpeedZ, coord.getRc());// -
		Toolkit.getDefaultToolkit().sync();
		g.dispose();
	}

	// key adapter
	/**
	 * Обрабатывает нажатие клавиш
	 * 
	 * @author Denis Vodolazskiy
	 * 
	 */
	private class TAdapter extends KeyAdapter {

		public void keyReleased(KeyEvent e) {
			craft.keyReleased(e);
		}

		public void keyPressed(KeyEvent e) {
			craft.keyPressed(e);
		}
	}

	/**
	 * Изменение координат и угла пси
	 * 
	 * @param i
	 *            шаг
	 */
	private void cycle(int i) {

		if (i < coord.byX().length) {// i< length of algorithm
			shipDistX = new MetMmTransform().meter2mm(coord.byX()[i]);
			shipDistZ = new MetMmTransform().meter2mm(coord.byZ()[i]);
			shipSpeedX = coord.byVx()[i];
			shipSpeedZ = coord.byVz()[i];
			// *3
			// psi =(float) (180*(new Coordinates().byW()[i])/(Math.PI));

		}
	}

}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\inout\IPrepareData.java

/*Class with constant arrays*/
package ua.edu.donntu.cs.inout;

import ua.edu.donntu.cs.cuda.service.TransformArray;

/**
 * Этот интерфейс создаёт константные массивы точек, полигонов и нормалей
 * 
 * @author Denis Vodolazskiy
 */
public interface IPrepareData {
	public final LoadData data = new LoadData();//для остальных классов путь задан в их коде
	public final int points[][] = data.loadPoints("data/inputfiles/points2.txt");
	public final int polygons[][] = data.loadPolygons("data/inputfiles/pointsAndPolygons2.txt");
	public final int normals[][] = data.loadNormals(points, polygons);

	// obtain normals using CUDA
	// public final LoadNormalsCuda2D lnc = new LoadNormalsCuda2D();
	// public final int normals[][] = new LoadNormalsCuda2D().loadNormalsCuda(
	// points, polygons, data.getCountPoints(), data.getCountPolygons());

	// set Q_POINTS and Q_POLYGONS
	public final int Q_POINTS = data.getCountPoints();
	public final int Q_POLYGONS = data.getCountPolygons();

	// Load Cuda data
	// public final LoadDataCuda dataCuda = new LoadDataCuda();
	// public final int pointsBaseCuda[] = dataCuda.loadPoints();
	public final int pointsBaseCuda[] = new TransformArray().in1D(points,
			Q_POINTS);
	// public final int polygonsCuda[] = dataCuda.loadPolygons();
	public final int polygonsCuda[] = new TransformArray().in1D(polygons,
			Q_POLYGONS);
	// public final int normalsCuda[] = dataCuda.loadNormals(pointsBaseCuda,
	// polygonsCuda);
	// public final int normalsCuda[] = new LoadNormalsCuda1D().loadNormalsCuda(
	// pointsBaseCuda, polygonsCuda, Q_POINTS, Q_POLYGONS);
	public final int normalsCuda[] = new TransformArray().in1D(normals,
			Q_POLYGONS);
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\inout\IQuantityOfPointsAndPolygons.java

/*Class to get number of points and polygons*/

/*Not used*/
package ua.edu.donntu.cs.inout;

/**
 * Этот класс устанавливает количество точек и полигонов. Не используется
 * 
 * @author Denis Vodolazskiy
 */
public interface IQuantityOfPointsAndPolygons {
	// public final int Q_POLYGONS = 96;
	// public final int Q_POINTS = 58;

	public final int Q_POINTS = new QuantityOfStringsInFile()
			.quantityOfPoints();
	public final int Q_POLYGONS = new QuantityOfStringsInFile()
			.quantityOfPolygons();

}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\inout\LoadData.java

/*Class to load data*/
package ua.edu.donntu.cs.inout;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Этот класс загружает данные из файлов и сохраняет их в двумерные массивы.
 * 
 * @author Denis Vodolazskiy
 */
public class LoadData {
	private int countPoints = 0;
	private int countPolygons = 0;

	// ----------------------load points-------------------------
	/**
	 * Загружает координаты точек из файла
	 * 
	 * @return двумерный массив координат точек
	 */
	public int[][] loadPoints(String path) {
		ArrayList<Integer> p = new ArrayList<Integer>();
		try {
			Scanner scanner = new Scanner(new File(path));
			while (scanner.hasNext()) {
				p.add(scanner.nextInt());
				p.add(scanner.nextInt());
				p.add(scanner.nextInt());
				countPoints++;
			}
		} catch (FileNotFoundException ex) {
			System.out.println("som");
			Logger.getLogger(LoadData.class.getName()).log(Level.SEVERE, null,
					ex);
		}
		int points[][] = new int[countPoints][3];
		int i = 0;
		while (i < countPoints) {
			points[i][0] = p.get(3 * i);
			points[i][1] = p.get(3 * i + 1);
			points[i][2] = p.get(3 * i + 2);
			i++;
		}
		// System.out.println(countPoints);
		return points;
	}

	// ----------------------load polygons-------------------------
	/**
	 * Загружает список точек для каждого треугольника
	 * 
	 * @return массив треугольников
	 */
	public int[][] loadPolygons(String path) {
		ArrayList<Integer> p = new ArrayList<Integer>();
		try {
			Scanner scanner = new Scanner(new File(path));
			while (scanner.hasNext()) {
				p.add(scanner.nextInt());
				p.add(scanner.nextInt());
				p.add(scanner.nextInt());
				countPolygons++;
			}
		} catch (FileNotFoundException ex) {
			System.out.println("som");
			Logger.getLogger(LoadData.class.getName()).log(Level.SEVERE, null,
					ex);
		}
		int i = 0;
		int polygons[][] = new int[countPolygons][3];
		while (i < countPolygons) {
			polygons[i][0] = p.get(3 * i);
			polygons[i][1] = p.get(3 * i + 1);
			polygons[i][2] = p.get(3 * i + 2);
			i++;
		}
		// System.out.println(countPolygons);
		return polygons;
	}

	/**
	 * Обрабатывает массивы точек и полигонов. Вызывается функция
	 * createNewNormal
	 * 
	 * @param points
	 *            массив координат точек
	 * @param polygons
	 *            массив точек для полигонов
	 * @return вектор нормали
	 */
	public int[][] loadNormals(int[][] points, int[][] polygons) {
		int normals[][] = new int[countPolygons][3];
		for (int i = 0; i < countPolygons; i++) {
			normals[i] = createNewNormal(points[polygons[i][0]],
					points[polygons[i][1]], points[polygons[i][2]]);
		}
		new WriteToFile(normals, "normal2.txt");
		return normals;
	}

	// ----------method for normal creation----------------------------
	/**
	 * Вычисление вектора нормали
	 * 
	 * @param b
	 *            координаты первой точки
	 * @param c
	 *            координаты второй точки
	 * @param d
	 *            координаты третей точки
	 * @return вектор нормали
	 */
	private int[] createNewNormal(int b[], int c[], int d[]) {
		int normal[] = new int[3];
		int x[] = new int[3];
		int y[] = new int[3];
		int z[] = new int[3];
		// for (int i=0;i<4;i++){
		x[0] = b[0];
		x[1] = c[0];
		x[2] = d[0];

		y[0] = b[1];
		y[1] = c[1];
		y[2] = d[1];

		z[0] = b[2];
		z[1] = c[2];
		z[2] = d[2];
		// }
		int j = 0;
		for (int i = 0; i < 3; i++) {
			if (i < 2) {
				j = i + 1;
				normal[0] += -(y[i] - y[j]) * (z[i] + z[j]);
				normal[1] += -(z[i] - z[j]) * (x[i] + x[j]);
				normal[2] += -(x[i] - x[j]) * (y[i] + y[j]);
			} else {
				j = 0;
				normal[0] += -(y[i] - y[j]) * (z[i] + z[j]);
				normal[1] += -(z[i] - z[j]) * (x[i] + x[j]);
				normal[2] += -(x[i] - x[j]) * (y[i] + y[j]);
			}
		}
		return normal;
	}

	/**
	 * Взять количество точек
	 * 
	 * @return количество точек
	 */
	public int getCountPoints() {
		return countPoints;
	}

	/**
	 * Взять количество полигонов
	 * 
	 * @return количество полигонов
	 */
	public int getCountPolygons() {
		return countPolygons;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\inout\LoadTimeValues.java

package ua.edu.donntu.cs.inout;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Этот класс загружает из файла данные о времени выполнения на GPU и CPU для
 * различного количества кораблей.
 * 
 * @author Denis Vodolazskiy
 */
public class LoadTimeValues {

	// for CompareFrame !!! outfiles
	/**
	 * Загрузка данных о времени выполнения
	 * 
	 * @param name
	 *            имя файла
	 * @return массив времени выполнения
	 */
	public float[] loadTimes(String name) {
		int countPoints = 0;
		ArrayList<Float> p = new ArrayList<Float>();
		FileReader fr;
		try {
			fr = new FileReader("data/outfiles/" + name);
			BufferedReader br = new BufferedReader(fr);
			String S = br.readLine();
			while (S != null) {
				countPoints++;
				p.add(Float.parseFloat(S));
				S = br.readLine();
			}
			br.close();
		} catch (FileNotFoundException ex) {
			System.out.println("som");
			Logger.getLogger(LoadData.class.getName()).log(Level.SEVERE, null,
					ex);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		float[] points = new float[countPoints];
		int i = 0;
		while (i < countPoints) {
			points[i] = p.get(i);
			i++;
		}
		return points;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\inout\QuantityOfStringsInFile.java

/*Calc number of strings*/

package ua.edu.donntu.cs.inout;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

/**
 * Этот класс определяет количество строк в файле
 * 
 * @author Denis Vodolazskiy
 */
public class QuantityOfStringsInFile {

	// for CompareFrame !!! outfiles
	/**
	 * Количество строк в файле времени выполнения
	 * 
	 * @param name
	 *            имя файла
	 * @return количество строк
	 */
	public int quantityOfStringsTime(String name) {
		int count = 0;
		FileReader fr;
		try {
			fr = new FileReader("data/outfiles/" + name);
			BufferedReader br = new BufferedReader(fr);
			while (br.readLine() != null) {
				count++;
			}
			br.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			System.out.println("File not found");
			// e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return count;
	}

	/**
	 * Не используется
	 */
	public int quantityOfPoints() {
		int count = 0;
		FileReader fr;
		try {
			fr = new FileReader("data/inputfiles/points2.txt");
			BufferedReader br = new BufferedReader(fr);
			while (br.readLine() != null) {
				count++;
			}
			br.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return count;
	}

	/**
	 * Не используется
	 */
	public int quantityOfPolygons() {
		int count = 0;
		FileReader fr;
		try {
			fr = new FileReader("data/inputfiles/pointsAndPolygons2.txt");
			BufferedReader br = new BufferedReader(fr);
			while (br.readLine() != null) {
				count++;
			}
			br.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return count;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\inout\WriteToFile.java

/*Class to write data*/
package ua.edu.donntu.cs.inout;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Этот класс записывает данные в файл
 * 
 * @author Denis Vodolazskiy
 */
public class WriteToFile {
	/**
	 * 
	 * @param a
	 *            массив входных данных
	 * @param name
	 *            имя файла
	 */
	public WriteToFile(int a[][], String name) {
		BufferedWriter out = null;
		try {
			out = new BufferedWriter(new FileWriter("data/outfiles/" + name));
			for (int i = 0; i < a.length; i++) {
				out.write(i + "   ");
				for (int j = 0; j < a[i].length; j++) {
					out.write(a[i][j] + "   ");
				}
				out.write("\n");
			}
		} catch (IOException ex) {
			Logger.getLogger(WriteToFile.class.getName()).log(Level.SEVERE,
					null, ex);
		} finally {
			try {
				out.close();
			} catch (IOException ex) {
				System.out.println(ex);
			}

		}
	}

	// -----------------------------------------------------------------------------
	/**
	 * 
	 * @param a
	 *            массив входных данных
	 * @param name
	 *            имя файла
	 */
	public WriteToFile(double a[][], String name) {
		BufferedWriter out = null;
		try {
			out = new BufferedWriter(new FileWriter("data/outfiles/" + name));
			for (int i = 0; i < a.length; i++) {
				out.write(i + "   ");
				for (int j = 0; j < a[i].length; j++) {
					out.write(a[i][j] + "   ");
				}
				out.write("\n");
			}
		} catch (IOException ex) {
			Logger.getLogger(WriteToFile.class.getName()).log(Level.SEVERE,
					null, ex);
		} finally {
			try {
				out.close();
			} catch (IOException ex) {
				System.out.println(ex);
			}

		}
	}

	// -------------------------------------------------------------------------------
	/**
	 * 
	 * @param a
	 *            входное число
	 * @param name
	 *            имя файла
	 */
	public WriteToFile(int a, String name) {// �������� �� ������ �����

		try {
			BufferedWriter out = null;
			out = new BufferedWriter(new FileWriter("data/outfiles/" + name,
					false));
			out.write(a + "   ");
			out.close();
		} catch (IOException ex) {
			Logger.getLogger(WriteToFile.class.getName()).log(Level.SEVERE,
					null, ex);
		} finally {

		}
	}

	/**
	 * 
	 * @param a
	 *            массив входных данных
	 * @param name
	 *            имя файла
	 */
	public WriteToFile(float[] a, String name) {// �������� �� ������ �����

		try {
			BufferedWriter out = null;
			out = new BufferedWriter(new FileWriter("data/outfiles/" + name,
					false));
			for (int i = 0; i < a.length; i++) {
				out.write(a[i] + "\n");
			}
			out.close();
		} catch (IOException ex) {
			Logger.getLogger(WriteToFile.class.getName()).log(Level.SEVERE,
					null, ex);
		} finally {

		}
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\key_manager\Craft.java

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ua.edu.donntu.cs.key_manager;

/**
 * Менеджер клавиатуры. По нажатию клавиш меняются углы вращения корабля вокру осей,
 *  а также расстояния от объекта до наблюдателя по осям
 * 
 * @author Denis Vodolazskiy
 */
import java.awt.event.KeyEvent;

public class Craft {

	private float psi;// = 0;// -30;
	private float teta;// = 0;// 30;
	private float gamma;// = 0;
	private float dpsi = 0;
	private float dteta = 0;
	private float dgamma = 0;
	private int distX;// = 60000;
	private int distY;// = 0;
	private int distZ;// = 0;
	private int deltadistX = 0;
	private int deltadistY = 0;
	private int deltadistZ = 0;

	/**
	 * Конструктор менеджера клавиатуры
	 * 
	 * @param psi
	 *            угол пси (вокруг оси Y)
	 * @param teta
	 *            угол тэта (вокруг оси Z)
	 * @param gamma
	 *            угол гамма (вокруг оси X)
	 * @param distX
	 *            текущее расстояние по оси X
	 * @param distY
	 *            текущее расстояние по оси Y
	 * @param distZ
	 *            текущее расстояние по оси Z
	 */
	public Craft(float psi, float teta, float gamma, int distX, int distY,
			int distZ) {
		this.psi = psi;
		this.teta = teta;
		this.gamma = gamma;
		this.distX = distX;
		this.distY = distY;
		this.distZ = distZ;
	}

	/**
	 * Если произошло событие
	 */
	public void move() {
		psi += dpsi;
		gamma += dgamma;
		teta += dteta;
		distX += deltadistX;
		distY += deltadistY;
		distZ += deltadistZ;
	}

	/**
	 * Взять psi
	 * 
	 * @return угол пси (вокруг оси Y)
	 */
	public float getPsi() {
		return psi;
	}

	/**
	 * Взять teta
	 * 
	 * @return угол тэта (вокруг оси Z)
	 */
	public float getTeta() {
		return teta;
	}

	/**
	 * Взять gamma
	 * 
	 * @return угол гамма (вокруг оси X)
	 */
	public float getGamma() {
		return gamma;
	}

	/**
	 * Взять distX
	 * 
	 * @return текущее расстояние по оси X
	 */
	public int getDistX() {
		return distX;
	}

	/**
	 * Взять distY
	 * 
	 * @return текущее расстояние по оси Y
	 */
	public int getDistY() {
		return distY;
	}

	/**
	 * Взять distZ
	 * 
	 * @return текущее расстояние по оси Z
	 */
	public int getDistZ() {
		return distZ;
	}

	/**
	 * Клавиша нажата
	 * 
	 * @param e
	 *            событие
	 */
	public void keyPressed(KeyEvent e) {

		int key = e.getKeyCode();

		if (key == KeyEvent.VK_LEFT) {
			dpsi = -1;
		}

		if (key == KeyEvent.VK_RIGHT) {
			dpsi = 1;
		}

		if (key == KeyEvent.VK_UP) {
			dgamma = -1;
		}

		if (key == KeyEvent.VK_DOWN) {
			dgamma = 1;
		}
		if (key == KeyEvent.VK_PAGE_UP) {
			dteta = -1;
		}

		if (key == KeyEvent.VK_PAGE_DOWN) {
			dteta = 1;
		}
		if (key == KeyEvent.VK_F11) {
			deltadistX = -100;
		}

		if (key == KeyEvent.VK_F12) {
			deltadistX = 100;
		}
		if (key == KeyEvent.VK_F5) {
			deltadistY = -100;
		}

		if (key == KeyEvent.VK_F6) {
			deltadistY = 100;
		}
		if (key == KeyEvent.VK_F7) {
			deltadistZ = -100;
		}

		if (key == KeyEvent.VK_F8) {
			deltadistZ = 100;
		}
	}

	/**
	 * Клавиша нажата
	 * 
	 * @param e
	 *            событие
	 */
	public void keyReleased(KeyEvent e) {
		int key = e.getKeyCode();

		if (key == KeyEvent.VK_LEFT) {
			dpsi = 0;
		}

		if (key == KeyEvent.VK_RIGHT) {
			dpsi = 0;
		}

		if (key == KeyEvent.VK_UP) {
			dgamma = 0;
		}

		if (key == KeyEvent.VK_DOWN) {
			dgamma = 0;
		}
		if (key == KeyEvent.VK_PAGE_UP) {
			dteta = 0;
		}

		if (key == KeyEvent.VK_PAGE_DOWN) {
			dteta = 0;
		}
		if (key == KeyEvent.VK_F11) {
			deltadistX = 0;
		}

		if (key == KeyEvent.VK_F12) {
			deltadistX = 0;
		}
		if (key == KeyEvent.VK_F5) {
			deltadistY = 0;
		}

		if (key == KeyEvent.VK_F6) {
			deltadistY = 0;
		}
		if (key == KeyEvent.VK_F7) {
			deltadistZ = 0;
		}

		if (key == KeyEvent.VK_F8) {
			deltadistZ = 0;
		}
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\path\calculations_kutt\Coordinates.java

/*gets coordinates and transform it to lehgth*/
package ua.edu.donntu.cs.path.calculations_kutt;

/**
 * Этот класс переводит значения координат в относительные. Например, вместо
 * скоростей V[0]=5,V[1]=4,V[2]=3 будет V[0]=5,V[1]=V[0]+4,V[2]=V[1]+3, то есть
 * 5, 9, 12. Скорости не переводятся
 * 
 * @author Denis Vodolazskiy
 */
public class Coordinates implements IKuttCalc {
	/**
	 * 
	 * @return координата по оси X в системе наблюдателя
	 */
	public float[] byX() {
		float[] x = new float[MC.getXobs().length];
		x[0] = MC.getXobs()[0];
		for (int i = 1; i < x.length; i++) {
			x[i] = x[i - 1] + MC.getXobs()[i];
		}
		return x;
	}

	/**
	 * 
	 * @return скорость по оси X в системе наблюдателя
	 */
	public float[] byVx() {
		return MC.getVX();
	}

	// Zpaint=Ymath
	/**
	 * 
	 * @return координата по оси Y в системе наблюдателя
	 */
	public float[] byZ() {
		float[] y = new float[MC.getYobs().length];
		y[0] = MC.getYobs()[0];
		for (int i = 1; i < y.length; i++) {
			y[i] = y[i - 1] + MC.getYobs()[i];
		}
		return y;
	}

	/**
	 * 
	 * @return скорость по оси Z в системе наблюдателя
	 */
	public float[] byVz() {
		return MC.getVY();
	}

	/**
	 * 
	 * @return угловая координата в системе наблюдателя
	 */
	public float[] byW() {
		float[] w = new float[MC.getW().length];
		w[0] = MC.getW()[0];
		for (int i = 1; i < w.length; i++) {
			w[i] = w[i - 1] + MC.getW()[i];
		}
		return w;
	}

	/**
	 * 
	 * @return угловая скорость в системе наблюдателя
	 */
	public float[] byW2() {
		return MC.getW();
	}

	/**
	 * 
	 * @return установившийся радиус циркуляции
	 */
	public float getRc() {
		return MC.getRc();
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\path\calculations_kutt\IKuttCalc.java

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ua.edu.donntu.cs.path.calculations_kutt;

/**
 * Этот интерфейс создаёт объект класса, содержащего параметры движения корабля
 * 
 * @author Denis Vodolazskiy
 */
public interface IKuttCalc {
	ModelCalcFullEngine MC = new ModelCalcFullEngine();
	// ModelCalcFullEngineCuda MC=new ModelCalcFullEngineCuda();
	// ModelCalcXrEngine MC =new ModelCalcXrEngine();
	// ModelCalcNoEngine MC=new ModelCalcNoEngine();
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\path\calculations_kutt\ModelCalcFullEngine.java

/*Calculate path of ship. define n, qPoints, qPolygons in cu-file */
package ua.edu.donntu.cs.path.calculations_kutt;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

/**
 * Этот класс вычисляет конечные скорости для одного корабля. Основной класс для
 * вычисления траектории движения
 * 
 * @author Denis Vodolazskiy
 */
public class ModelCalcFullEngine {

	// with k11 - 580.91; coef Vx, Vy
	final private float T = 4.0f, L = 80.0f, B = 15.0f;// осадка, длина, ширина
														// c 323, 321
	final private float m = 2_0_000_000_000.0f; // масса судна
	final private float lr = 40.0f; // расстояние от ДРК до ЦТ судна
	private float Vx = 0.0f, Vy = 0.0f;// скорости по осям
	private float v = 0.0f, w = 0.0f;// линейная и угловая скорости
	private float Rc;// радиус циркуляции
	final private int size = 40_000;
	private float VX[] = new float[size];
	private float VY[] = new float[size];
	private float ww[] = new float[size];
	// для второго интеграла
	private float X[] = new float[size];
	private float Y[] = new float[size];
	private float W[] = new float[size];
	// неподвижная система координат
	private float Xobs[] = new float[size];
	private float Yobs[] = new float[size];
	private float Wmov[] = new float[size];

	/**
	 * Конструктор, выполняющий вычисления координат и скоростей для одного
	 * корабля
	 */
	public ModelCalcFullEngine() {
		float k11, k22, k66, k26;

		final float delta = 0.7f;// коэффициент общей полноты
		float c1, c2, c3, m1, m2;// коэффициеты Р.Я.Першица
		float w_ = 0.0f;// угол дрейфа approx
		float betta_d = 0.0f;// угол дрейфа в центре тяжести (rad)
		float Cxr, Cyr, Cmr;// коэффициенты Cxr, боковой силы, момента
		// float L1=B,T1=L/2;//хорда, полудлина вертикального крыла
		// ????????????????????
		final float p = 1000.0f;// плотность воды
		float Xr, Yr, Mr;// гидродинамические усилия
		float ZpTei = 0;// полезная тяга винтов при равномерном прямолинейном
						// движении =R+Xa
		float Jz;// момент инерции массы судна относительно оси Gz
		float ZpYri;// боковая сила ДРК
		final float a66 = 0.31f;// числовой коэффициент
		float Ramp = 0.0f;// для одиночных рулей
		float lyamdaR = 1.4f;// удлинение c 335 //0.5--1.4 //1

		float deltaR = 0.349f;// угол перекладки руля - 20% //0.349f

		// float Va;//скорость натекания воды на руль
		float Yri, Ysi;// боковая и стабилизирубщая силы
		final float Ar = 6.0f;// площадь перьев//5 можно увеличить
		final float D = 1.5f;// диаметр диска винта//2 можно уменьшить
		final float Cta = 10.0f, Ctt = 50.0f;// c 334 //Cta<=20, 0.5--30,
												// Ctt<=20, 1--50 UP!!!
		// Ctt =30
		float Kvx, Kvy, Kw;// коэффиценты для производных
		final float No = 3.0f;// обороты двигателя //Першин//3 оборота
		final float Re = 5000000.0f;// Число Рейнольда >5E8
		float K_betta;
		float fit;
		final float xk = 1.0f;
		final float bettar = 0.9f;
		final float fik = 0.95f;
		float ld_;// относительная длина насадки c228
		float betta_D;// коэффициент расширения
		float fiD;// c 338
		float CyD1;
		float CyD;
		float A0;// площадь диска винта
		float xD;// c 339
		float viv = 0.0f;// угол для неподвижной системы координат с 27 ch3_2
		float[][] Rmatr = new float[][] {
				{ (float) Math.cos(viv), -(float) Math.sin(viv), 0.0f },
				{ (float) Math.sin(viv), (float) Math.cos(viv), 0.0f },
				{ 0.0f, 0.0f, 1.0f } };
		// Math.cos(viv),-Math.sin(viv),0.0f,Math.sin(viv),Math.cos(viv),0.0f,0.0f,0.0f,1.0f};
		// ------------------------------------------------------------
		// c 330 5.91-в книге, 580.91 - выравнять Х
		k11 = (580.91f * (float) Math.pow(B / L, 2.0f) + 7.76f * (B / L) - 0.259f)
				/ (48.4f - 6.89f * (B / T) + 1.47f
						* (float) Math.pow(B / T, 2.0f) - 0.0475f * (float) Math
						.pow(B / T, 3.0f));

		k22 = ((0.722f + 0.224f * delta) * (1.022f - (float) Math.pow(B / L,
				2.0f))) / (0.264f + 0.368f * (B / T));
		k66 = (2.0f * T / B) * (2.59f + 0.781f * delta)
				* (0.357f - 1.77f * (float) Math.pow(B / L, 2.0f));
		k26 = k22;
		// k26=0;
		// System.out.printf("k11=%f\tk22=%f\tk66=%f\tk26=%f\n", k11, k22, k66,
		// k26);
		// c 323
		c1 = 3.14f * (T / L) * (float) Math.pow((0.63f / delta), (5.0f / 2.0f))
				* (float) Math.pow(L / (6.0f * B), (1.0f / 3.0f)) - 0.032f;
		c2 = -2.0f * k11 * delta * (B / L);
		c3 = 1.35f * (float) Math.pow(T / B, (1.0f / 2.0f))
				* (float) Math.pow((0.63f / delta), (3.0f / 2.0f)) - 0.029f;
		m1 = 1.67f * (T / L) - 0.56f * delta + 0.43f;
		m2 = -0.44f * (T / L) - 0.0375f;
		// System.out.printf("c1=%f\tc2=%f\tc3=%f\tm1=%f\tm2=%f\n", c1, c2, c3,
		// m1, m2);
		Jz = (m * (float) Math.pow(L, 2.0f) / 12.4f)
				* (0.463f + 0.574f * (float) Math.pow(delta, a66) + (float) Math
						.pow(B / L, 2.0f));// c 330
		/*
		 * коэффиценты для производных: 1/m(1+k11) 1/m(1+k22) 1/Jz(1+k26)
		 */
		Kvx = 1 / (m * (1 + k11));
		Kvy = 1 / (m * (1 + k22));
		Kw = 1 / (Jz * (1 + k66));// ????? m
		// System.out.printf("Kvx=%g\tKvy=%g\tKw=%g\n", Kvx, Kvy, Kw);
		// ----------------------------------------------------------------

		float k1, k2, k3, k4;
		float q1, q2, q3, q4;
		float z1, z2, z3, z4;
		float j1, j2, j3, j4;
		// t = 0.0f; // шаг времени
		int t = 0;
		float h = 1f;
		// System.out.printf("\tVx\t\tVy\t\tw\tt\n");
		Vx = 5.0f;
		Vy = 0.0f;
		w = 0.0f;
		// -------------------------------------
		try {
			BufferedWriter outfile = new BufferedWriter(new FileWriter(
					"data/outfiles/VxVy.txt"));
			BufferedWriter outfile2 = new BufferedWriter(new FileWriter(
					"data/outfiles/viv.txt"));
			BufferedWriter outfile3 = new BufferedWriter(new FileWriter(
					"data/outfiles/XY.txt"));
			BufferedWriter outfile4 = new BufferedWriter(new FileWriter(
					"data/outfiles/XYmov.txt"));
			//
			outfile.write("\t Vx\t\t\t\t Vy\t\t\t\t w\t\t\t t\n");
			//
			outfile3.write("X\t\t Y\t\t W" + "\n");
			//
			outfile4.write("Xmov\t\t Ymov\t\t Wmov" + "\n");
			// ------------------------
			for (int i = 0; i < size; i++) { // 16550
				v = (float) Math.sqrt((float) Math.pow(Vx, 2.0f)
						+ (float) Math.pow(Vy, 2.0f));
				// assert(Vx==0);
				if (Vx != 0) {
					// c 353 ?????????????????????????
					w_ = w * L / v;// ??????????????????????
					betta_d = -(float) Math.atan(Vy / Vx);// c 350
				} else {
					w_ = w * L / v;
					// betta_d = 0;
					betta_d = -(float) Math.atan(Vy / Vx);// c 350
				}
				// System.out.println(w_);
				Cxr = 0.01f * (1.0f + 170.0f * (T / L));// для плота c 119
				Cyr = c1 * betta_d + c2 * w_ + c3 * betta_d * Math.abs(betta_d);// c
																				// 323
				Cmr = m1 * betta_d + m2 * w_;

				Xr = Cxr * L * T * (float) Math.pow(v, 2.0f) * p / 2.0f;// c 320
				Yr = Cyr * L * T * (float) Math.pow(v, 2.0f) * p / 2.0f;
				Mr = Cmr * L * T * (float) Math.pow(v, 2.0f) * p / 2.0f;

				K_betta = 0.43f * (float) Math.pow(Ctt, -0.6f);
				fit = (float) Math.pow(1.0f + Ctt, 0.508f);
				// Yri = 3.14f * (lyamdaR - K_betta * xk * (betta_d + lr * w_))
				// * p * Ar * (float) Math.pow(v * fik * fit, 2.0f) / (1.0f +
				// 2.2f / (float) Math.pow(lyamdaR, 2.0f / 3.0f));
				// Yri=(3.14f*2.0f)/(1.0f+2.2f/Math.pow(lyamdaR,2.0f/3.0f))*(deltaR-xk*bettar)*Ramp*Math.pow(v*fik,2.0f)*Ar*p/2.0f;//Va=V*fir
				// Yri = 3.14f * (lyamdaR - K_betta * xk * (betta_d + lr *
				// w_))*(deltaR-xk*bettar) * p * Ar * (float) Math.pow(v * fik *
				// fit, 2.0f) / (1.0f + 2.2f / (float) Math.pow(lyamdaR, 2.0f /
				// 3.0f));

				// IMPORTANT!!! deltaR
				Yri = 3.14f
						* (deltaR - K_betta * xk * (betta_d + lr * w_))
						* p
						* Ar
						* (float) Math.pow(v * fik * fit, 2.0f)
						/ (1.0f + 2.2f / (float) Math.pow(lyamdaR, 2.0f / 3.0f));

				ld_ = 0.77f - 0.125f * (float) Math.sqrt(Ctt)
						/ (1.65f * (float) Math.sqrt(Ctt) - 1.0f);
				betta_D = 1.22f - 0.0563f * (float) Math.sqrt(Ctt)
						/ (1.65f * (float) Math.sqrt(Ctt) - 1.0f);
				fiD = 0.5f * ((float) Math.sqrt(1.0f + 2.0f * Ctt / betta_D) + 1.0f);

				CyD1 = 12.0f * ld_ / (1.0f + 1.56f * ld_);
				CyD = CyD1 + 2.0f * betta_D * (float) Math.pow(fiD, 2.0f);
				xD = xk * (CyD1 + 2.0f * betta_D * fiD)
						/ (CyD1 + 2.0f * betta_D * (float) Math.pow(fiD, 2.0f));
				A0 = 3.14f * (float) Math.pow(D, 2.0f) / 4.0f;
				Ysi = CyD * (xD - 0.02f * xk) * (betta_d + lr * w_)
						* (p / 2.0f) * A0 * (float) Math.pow(v, 2.0f)
						* (float) Math.pow(fik, 2.0f);

				// ZpTei = Xr;//при прямолинейном движении Xr=R
				ZpTei = 1000_000f * (9.740f * (float) Math.pow(No, 2.0f) - 2.23f * v); // Пелевин//9.740f
				// ZpTei = 1000_000f * (4.115f * (float) Math.pow(No, 2.0f) -
				// 1.21f * v); //Пелевин//
				/*
				 * float dP = 10_000_000f; float Wt, Fr, xp = 2f; Fr = v /
				 * (Math.sqrt(9.8f * L)); Wt = 0.11f + (0.16f / xp) *
				 * Math.pow(delta, xp) * Math.sqrt(Math.pow(v, 1.0f / 3.0f) / D)
				 * - 0.3f * delta * (Fr - 0.2f);
				 * 
				 * ZpTei = 2.0f * dP * A0*(1.0f-0.8f*Wt*(1.0f+0.25f*Wt));
				 */

				ZpYri = 2.0f * (Yri - Ysi);// 2 винта
				// printf("ZpTei=%f\tZpYri=%f\t\n",ZpTei,ZpYri);

				k1 = h * vxd(Vy, w, ZpTei, Xr, Kvx);
				q1 = h * vyd(Vx, w, ZpYri, Yr, Kvy);
				z1 = h * wd(Mr, ZpTei, Yr, Kw);

				k2 = h * vxd(Vy + q1 / 2.0f, w + z1 / 2.0f, ZpTei, Xr, Kvx);
				q2 = h * vyd(Vx + k1 / 2.0f, w + z1 / 2.0f, ZpYri, Yr, Kvy);
				z2 = h * wd(Mr, ZpYri, Yr, Kw);

				k3 = h * vxd(Vy + q2 / 2.0f, w + z2 / 2.0f, ZpTei, Xr, Kvx);
				q3 = h * vyd(Vx + k2 / 2.0f, w + z2 / 2.0f, ZpYri, Yr, Kvy);
				z3 = h * wd(Mr, ZpYri, Yr, Kw);

				k4 = h * vxd(Vy + q3, w + z3, ZpTei, Xr, Kvx);
				q4 = h * vyd(Vx + k3, w + z3, ZpYri, Yr, Kvy);
				z4 = h * wd(Mr, ZpYri, Yr, Kw);

				Vx = Vx + (1.0f / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
				// VX[t] = Vx / 1.24;
				VX[t] = Vx;
				Vy = Vy + (1.0f / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
				VY[t] = Vy;
				w = w + (1.0f / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);
				ww[t] = w;

				// ---второй интеграл-----------------------------------------
				k1 = h * vxd(Vy, w, ZpTei, Xr, Kvx);
				q1 = h * vyd(Vx, w, ZpYri, Yr, Kvy);
				z1 = h * wd(Mr, ZpTei, Yr, Kw);

				k2 = h * vxd(Vy + q1 / 2.0f, w + z1 / 2.0f, ZpTei, Xr, Kvx);
				q2 = h * vyd(Vx + k1 / 2.0f, w + z1 / 2.0f, ZpYri, Yr, Kvy);
				z2 = h * wd(Mr, ZpYri, Yr, Kw);

				k3 = h * vxd(Vy + q2 / 2.0f, w + z2 / 2.0f, ZpTei, Xr, Kvx);
				q3 = h * vyd(Vx + k2 / 2.0f, w + z2 / 2.0f, ZpYri, Yr, Kvy);
				z3 = h * wd(Mr, ZpYri, Yr, Kw);

				k4 = h * vxd(Vy + q3, w + z3, ZpTei, Xr, Kvx);
				q4 = h * vyd(Vx + k3, w + z3, ZpYri, Yr, Kvy);
				z4 = h * wd(Mr, ZpYri, Yr, Kw);

				X[t] = Vx + (1.0f / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
				Y[t] = Vy + (1.0f / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
				W[t] = w + (1.0f / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);
				outfile3.write(X[t] + "\t" + Y[t] + "\t" + W[t] + "\n");
				// угол для неподвижной системы координат
				/*
				 * j1 = h * wd(Mr, ZpTei, Yr, Kw); j2 = h * wd(Mr, ZpYri, Yr,
				 * Kw); j3 = h * wd(Mr, ZpYri, Yr, Kw); j4 = h * wd(Mr, ZpYri,
				 * Yr, Kw); viv = w + (1.0f / 6.0f) * (j1 + 2.0f * j2 + 2.0f *
				 * j3 + j4);
				 */
				viv = W[t];
				outfile2.write("viv=" + viv + "\n");
				// System.out.println("viv="+viv);
				// -------
				Rmatr[0][0] = (float) Math.cos(viv);
				Rmatr[0][1] = -(float) Math.sin(viv);
				Rmatr[1][0] = (float) Math.sin(viv);
				Rmatr[1][1] = (float) Math.cos(viv);
				Xobs[t] = Rmatr[0][0] * X[t] + Rmatr[0][1] * Y[t];
				Yobs[t] = Rmatr[1][0] * X[t] + Rmatr[1][1] * Y[t];
				outfile4.write(Xobs[t] + "\t" + Yobs[t] + "\n");
				// ----------
				t += 1f;

				outfile.write(Vx + "\t\t" + Vy + "\t\t" + w + "\t\t" + t + "\n");
			}
			outfile.close();
			outfile2.close();
			outfile3.close();
			outfile4.close();
		} catch (IOException e) {
		}
		// Rc=v/w;
		// --------------------------------------------------------------------
	}

	/**
	 * Прирашение скорости по оси X
	 * 
	 * @param Vy
	 *            скорость по оси Y
	 * @param w
	 *            угловая скорость
	 * @param ZpTei
	 *            тяга в продольном направлениии
	 * @param Xr
	 *            гидродинамические усилия в продольном направлении
	 * @param Kvx
	 *            коэффициент по X
	 * @return приращение скорости
	 */
	private float vxd(float Vy, float w, float ZpTei, float Xr, float Kvx) {
		if (Vy > 0) {
			return ((m * Vy * w - Xr + ZpTei) * Kvx);
		} else {
			return ((m * Vy * w * 1.09f - Xr + ZpTei) * Kvx);// Vx*1.061
																// ;N0=3;k11=580.91f
																// Ubuntu
			// return ((m * Vy * w - Xr + ZpTei) * Kvx);
		}// *1.1045; k11=5.91f windows ; 1.09; k11=580.91f
	}

	/**
	 * Прирашение скорости по оси Y
	 * 
	 * @param Vx
	 *            скорость по оси x
	 * @param w
	 *            угловая скорость
	 * @param ZpYri
	 *            тяга в поперечном направлениии
	 * @param Yr
	 *            гидродинамические усилия в поперечном направлении
	 * @param Kvy
	 *            коэффициент по Y
	 * @return приращение скорости
	 */
	private float vyd(float Vx, float w, float ZpYri, float Yr, float Kvy) {
		if (Vx > 0) {
			return ((Yr - ZpYri - m * Vx * w * 1.0165f) * Kvy);// Vx*1.0179
			// return ((Yr - ZpYri - m * Vx * w) * Kvy);
		} else {// *1.0165; k11=5.91f windows
			return ((Yr - ZpYri - m * Vx * w) * Kvy);
		}
	}

	/**
	 * Прирашение угловой скорости
	 * 
	 * @param Mr
	 *            момент гидродинамических усилий
	 * @param ZpYri
	 *            тяга в поперечном направлениии
	 * @param Yr
	 *            гидродинамические усилия в поперечном направлении
	 * @param Kw
	 *            коэффициент для угловой скорости
	 * @return приращение угловой скорости
	 */
	private float wd(float Mr, float ZpYri, float Yr, float Kw) {
		return ((Mr + lr * ZpYri) * Kw);
	}

	/**
	 * Взять VX
	 * 
	 * @return скорость по оси X в системе объекта
	 */
	public float[] getVX() {
		return VX;
	}

	/**
	 * Взять VY
	 * 
	 * @return скорость по оси Y в системе объекта
	 */
	public float[] getVY() {
		return VY;
	}

	/**
	 * Взять ww
	 * 
	 * @return угловая скорость в системе объекта
	 */
	public float[] getw() {
		return ww;
	}

	/**
	 * Взять X
	 * 
	 * @return скорость по оси X в мировой системе
	 */
	public float[] getX() {
		return X;
	}

	/**
	 * Взять Y
	 * 
	 * @return скорость по оси Y в мировой системе
	 */
	public float[] getY() {
		return Y;
	}

	/**
	 * Взять W
	 * 
	 * @return угловая скорость в мировой системе
	 */
	public float[] getW() {
		return W;
	}

	/**
	 * Взять Xobs
	 * 
	 * @return скорость по оси X в системе наблюдателя
	 */
	public float[] getXobs() {
		return Xobs;
	}

	/**
	 * Взять Yobs
	 * 
	 * @return скорость по оси Y в системе наблюдателя
	 */
	public float[] getYobs() {
		return Yobs;
	}

	/**
	 * Взять Rc
	 * 
	 * @return установившийся радиус циркуляции
	 */
	public float getRc() {
		return Rc = v / w;
	}

	/**
	 * Взять T
	 * 
	 * @return осадка корабля
	 */
	public float getT() {
		return T;
	}

	/**
	 * Взять L
	 * 
	 * @return длина корабля
	 */
	public float getL() {
		return L;
	}

	/**
	 * Взять B
	 * 
	 * @return ширина корабля
	 */
	public float getB() {
		return B;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\path\frames\BigGraphicUniFrame.java

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ua.edu.donntu.cs.path.frames;

import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.UIManager;

import ua.edu.donntu.cs.path.calculations_kutt.IKuttCalc;
import ua.edu.donntu.cs.path.paint.PaintGraph;
import ua.edu.donntu.cs.path.paint.PaintGraphCoordCircle;

/**
 * Класс для построения графиков движения (увеличенный график)
 * 
 * @author Denis Vodolazskiy
 */
public class BigGraphicUniFrame extends JFrame implements ActionListener,
		IKuttCalc {

	private JButton jbt1;
	private JLabel jl1;
	private JTextField text1 = new JTextField(1);
	private PaintGraph pgXYmov;

	/**
	 * Выполняет действия при нажатии кнопок
	 */
	@Override
	public void actionPerformed(ActionEvent e) {
		if (e.getSource().equals(jbt1)) {
			pgXYmov.setDivideForRealModelingTime(Integer.parseInt(text1
					.getText()));
			pgXYmov.repaint();// перерисовка графика функции
		}
	}

	/**
	 * Конструктор, задаёт расположение окна и его свойства
	 */
	public BigGraphicUniFrame(PaintGraph pgXYmov) {
		super("Построение графика функции");
		this.pgXYmov = pgXYmov;
		// System Look-And-Feel:
		try {
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (Exception e) {
			// Exception handle
		}
		JPanel panel = new JPanel();
		panel.setLayout(null);
		setSize(1000, 730); // задание размеров
		setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
		// ----------------------
		jbt1 = new JButton("Paint");
		jbt1.setSize(140, 25);
		jbt1.setLocation(10, 30);
		panel.add(jbt1);
		jbt1.addActionListener(this);
		//
		jl1 = new JLabel("divide time by INT:");
		jl1.setHorizontalAlignment(0);
		jl1.setSize(140, 25);
		jl1.setLocation(10, 60);
		panel.add(jl1);
		//
		text1.setSize(140, 25);
		text1.setLocation(10, 90);
		text1.setText("1");
		panel.add(text1);

		if (pgXYmov instanceof PaintGraphCoordCircle) {
			JLabel jl2 = new JLabel("Rc=" + MC.getRc());
			jl2.setSize(140, 25);
			jl2.setHorizontalAlignment(0);
			jl2.setLocation(10, 150);
			panel.add(jl2);
		}

		pgXYmov.setSize(620, 620); // задание размеров
		pgXYmov.setBackground(Color.lightGray);// цвет
		pgXYmov.setLocation(200, 20);
		panel.add(pgXYmov);
		// ----------
		setResizable(false);
		setVisible(true);
		setContentPane(panel);
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\path\frames\ObjectCoordFrame.java

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ua.edu.donntu.cs.path.frames;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.UIManager;

import ua.edu.donntu.cs.path.calculations_kutt.IKuttCalc;
import ua.edu.donntu.cs.path.paint.PaintGraph;
import ua.edu.donntu.cs.path.paint.PaintGraphCoordCircle;
import ua.edu.donntu.cs.path.paint.PaintGraphLine;

/**
 * Класс для построения графиков движения (в системе мировой)
 * 
 * @author Denis Vodolazskiy
 */
public class ObjectCoordFrame extends JFrame implements ActionListener,
		IKuttCalc {

	private JButton jbt1, jbt2;
	private PaintGraph pgVx, pgVy, pgw, pgXY;// класс вывода графика функции

	/**
	 * Выполняет действия при нажатии кнопок
	 */
	@Override
	public void actionPerformed(ActionEvent e) {
		if (e.getSource().equals(jbt2)) {
			pgVx.repaint();// перерисовка графика функции
			pgVy.repaint();// перерисовка графика функции
			pgw.repaint();// перерисовка графика функции
			pgXY.repaint();// перерисовка графика функции
		}
		if (e.getSource().equals(jbt1)) {
		}
	}

	/**
	 * Конструктор, задаёт расположение окна и его свойства
	 */
	public ObjectCoordFrame() {
		super("Построение графика функции");
		// System Look-And-Feel:
		try {
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (Exception e) {
			// Exception handle
		}
		JPanel panel = new JPanel();
		panel.setLayout(null);
		setSize(1000, 730); // задание размеров
		// setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // задание параметров
		setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

		Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();
		int width = getSize().width;
		int height = getSize().height;
		int x = (dim.width - width) / 2;
		int y = (dim.height - height) / 2;
		setLocation(x, y);
		// ----------------------
		jbt2 = new JButton("Paint");
		jbt1 = new JButton("Do nothing");
		// -------------
		jbt2.setSize(100, 25);
		jbt2.setLocation(10, 20);
		panel.add(jbt2);
		// --
		jbt1.setSize(100, 25);
		jbt1.setLocation(10, 60);
		panel.add(jbt1);
		// --
		jbt2.addActionListener(this);
		jbt1.addActionListener(this);

		// ModelCalc2 MC = new ModelCalc2();

		pgVx = new PaintGraphLine("t", "X", MC.getX());
		pgVx.setSize(800, 160); // задание размеров
		pgVx.setBackground(Color.lightGray);// цвет
		pgVx.setLocation(180, 20);
		panel.add(pgVx);
		// --second graph
		pgVy = new PaintGraphLine("t", "Y", MC.getY()); // инициализация класса
														// построения графика
														// функции
		pgVy.setSize(800, 160); // задание размеров
		pgVy.setBackground(Color.lightGray);// цвет
		pgVy.setLocation(180, 190);
		panel.add(pgVy);
		// -------
		pgw = new PaintGraphLine("t", "w observer", MC.getW(), 100); // инициализация
																		// класса
																		// построения
																		// графика
																		// функции
		pgw.setSize(800, 160); // задание размеров
		pgw.setBackground(Color.lightGray);// цвет
		pgw.setLocation(180, 360);
		panel.add(pgw);
		// ----------
		pgXY = new PaintGraphCoordCircle("X", "Y", MC.getX(), MC.getY(), 1, 1,
				5000, 2000, 1);
		pgXY.setSize(800, 160); // задание размеров
		pgXY.setBackground(Color.lightGray);// цвет
		pgXY.setLocation(180, 530);
		panel.add(pgXY);
		// ----------
		setResizable(false);
		setVisible(true);
		setContentPane(panel);
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\path\frames\ObserverCoordFrame.java

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ua.edu.donntu.cs.path.frames;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.UIManager;

import ua.edu.donntu.cs.path.calculations_kutt.IKuttCalc;
import ua.edu.donntu.cs.path.paint.PaintGraph;
import ua.edu.donntu.cs.path.paint.PaintGraphCoordCircle;
import ua.edu.donntu.cs.path.paint.PaintGraphLine;

/**
 * Класс для построения графиков движения (в системе наблюдателя)
 * 
 * @author Denis Vodolazskiy
 */
public class ObserverCoordFrame extends JFrame implements ActionListener,
		MouseListener, IKuttCalc {

	private JButton jbt1, jbt2;
	// private JTextField text1 = new JTextField(1);//, text2, text3, text4,
	// text5, text6, text7, text8;
	private PaintGraph pgVx, pgVy, pgw, pgXY, pgXYmov;// класс вывода графика
														// функции
	MouseListener me;

	@Override
	/**
	 * Выполняет действия при нажатии кнопок
	 */
	public void actionPerformed(ActionEvent e) {
		if (e.getSource().equals(jbt2)) {
			pgVx.repaint();// перерисовка графика функции
			pgVy.repaint();// перерисовка графика функции
			pgw.repaint();// перерисовка графика функции
			pgXY.repaint();// перерисовка графика функции
		}
		if (e.getSource().equals(jbt1)) {
			// ModelCalc2 MC = new ModelCalc2();
			pgXYmov = new PaintGraphCoordCircle("Xmov", "Ymov", MC.getXobs(),
					MC.getYobs(), 1, 1, 6000, 6000, 1);
			new BigGraphicUniFrame(pgXYmov);
		}

	}

	/**
	 * Конструктор, задаёт расположение окна и его свойства
	 */
	public ObserverCoordFrame() {
		super("Построение графика функции");
		// System Look-And-Feel:
		try {
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (Exception e) {
			// Exception handle
		}
		JPanel panel = new JPanel();
		panel.setLayout(null);
		setSize(1000, 730); // задание размеров
		// setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // задание параметров
		setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

		Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();
		int width = getSize().width;
		int height = getSize().height;
		int x = (dim.width - width) / 2;
		int y = (dim.height - height) / 2;
		setLocation(x, y);
		// ----------------------
		jbt2 = new JButton("Paint");
		jbt1 = new JButton("Path");
		// -------------
		jbt2.setSize(100, 25);
		jbt2.setLocation(10, 20);
		panel.add(jbt2);
		// --
		jbt1.setSize(100, 25);
		jbt1.setLocation(10, 60);
		panel.add(jbt1);
		// --
		jbt2.addActionListener(this);
		jbt1.addActionListener(this);

		// ModelCalc2 MC = new ModelCalc2();

		pgVx = new PaintGraphLine("t", "Xobs", MC.getXobs());
		pgVx.setSize(800, 160); // задание размеров
		pgVx.setBackground(Color.lightGray);// цвет
		pgVx.setLocation(180, 20);
		panel.add(pgVx);
		// --second graph
		pgVy = new PaintGraphLine("t", "Yobs", MC.getYobs()); // инициализация
																// класса
																// построения
																// графика
																// функции
		pgVy.setSize(800, 160); // задание размеров
		pgVy.setBackground(Color.lightGray);// цвет
		pgVy.setLocation(180, 190);
		panel.add(pgVy);
		// -------
		pgw = new PaintGraphLine("t", "w observer", MC.getW(), 100); // инициализация
																		// класса
																		// построения
																		// графика
																		// функции
		pgw.setSize(800, 160); // задание размеров
		pgw.setBackground(Color.lightGray);// цвет
		pgw.setLocation(180, 360);
		panel.add(pgw);
		// ----------
		pgXY = new PaintGraphCoordCircle("Xobs", "Yobs", MC.getXobs(),
				MC.getYobs(), 1, 1, 10000, 6000, 1);
		pgXY.setSize(800, 160); // задание размеров
		pgXY.setBackground(Color.lightGray);// цвет
		pgXY.setLocation(180, 530);
		panel.add(pgXY);
		// ----------
		pgXY.addMouseListener(this);
		setResizable(false);
		setVisible(true);
		setContentPane(panel);
	}

	@Override
	public void mouseClicked(MouseEvent me) {
		// throw new UnsupportedOperationException("Not supported yet."); //To
		// change body of generated methods, choose Tools | Templates.
		if (me.getSource().equals(pgXY)) {
			pgXYmov = new PaintGraphCoordCircle("Xmov", "Ymov", MC.getXobs(),
					MC.getYobs(), 1, 1, 6000, 6000, 1);
			new BigGraphicUniFrame(pgXYmov);
		}
	}

	@Override
	public void mousePressed(MouseEvent me) {
		// throw new UnsupportedOperationException("Not supported yet."); //To
		// change body of generated methods, choose Tools | Templates.
	}

	@Override
	public void mouseReleased(MouseEvent me) {
		// throw new UnsupportedOperationException("Not supported yet."); //To
		// change body of generated methods, choose Tools | Templates.
	}

	@Override
	public void mouseEntered(MouseEvent me) {
		// throw new UnsupportedOperationException("Not supported yet."); //To
		// change body of generated methods, choose Tools | Templates.
	}

	@Override
	public void mouseExited(MouseEvent me) {
		// throw new UnsupportedOperationException("Not supported yet."); //To
		// change body of generated methods, choose Tools | Templates.
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\path\frames\VelocityFrame.java

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ua.edu.donntu.cs.path.frames;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.UIManager;

import ua.edu.donntu.cs.path.calculations_kutt.IKuttCalc;
import ua.edu.donntu.cs.path.paint.PaintGraph;
import ua.edu.donntu.cs.path.paint.PaintGraphCircle;
import ua.edu.donntu.cs.path.paint.PaintGraphLine;

/**
 * Класс для построения графиков движения (в системе объекта)
 * 
 * @author Denis Vodolazskiy
 */
public class VelocityFrame extends JFrame implements ActionListener,
		MouseListener, IKuttCalc {

	private JButton jbt1, jbt2;
	private PaintGraph pgVx, pgVy, pgw, pgXY, pgXYmov;// класс вывода графика
														// функции

	@Override
	/**
	 * Выполняет действия при нажатии кнопок
	 */
	public void actionPerformed(ActionEvent e) {
		if (e.getSource().equals(jbt2)) {
			pgVx.repaint();// перерисовка графика функции
			pgVy.repaint();// перерисовка графика функции
			pgw.repaint();// перерисовка графика функции
			pgXY.repaint();// перерисовка графика функции
		}
		if (e.getSource().equals(jbt1)) {
			// ModelCalc2 MC = new ModelCalc2();
			pgXYmov = new PaintGraphCircle("Vx", "Vy", MC.getVX(), MC.getVY(),
					1, 1, 20, 20, 1);
			new BigGraphicUniFrame(pgXYmov);
		}
	}

	/**
	 * Конструктор, задаёт расположение окна и его свойства
	 */
	public VelocityFrame() {
		super("Построение графика функции");
		// System Look-And-Feel:
		try {
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (Exception e) {
			// Exception handle
		}
		JPanel panel = new JPanel();
		panel.setLayout(null);
		setSize(1000, 730); // задание размеров
		// setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // задание параметров
		setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

		Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();
		int width = getSize().width;
		int height = getSize().height;
		int x = (dim.width - width) / 2;
		int y = (dim.height - height) / 2;
		setLocation(x, y);
		// ----------------------
		jbt2 = new JButton("Paint");
		jbt1 = new JButton("Big VxVy");
		// -------------
		jbt2.setSize(100, 25);
		jbt2.setLocation(10, 20);
		panel.add(jbt2);
		// --
		jbt1.setSize(100, 25);
		jbt1.setLocation(10, 60);
		panel.add(jbt1);
		// --
		jbt2.addActionListener(this);
		jbt1.addActionListener(this);

		// ModelCalc2 MC = new ModelCalc2();

		pgVx = new PaintGraphLine("t", "Vx", MC.getVX());
		pgVx.setSize(800, 160); // задание размеров
		pgVx.setBackground(Color.lightGray);// цвет
		pgVx.setLocation(180, 20);
		panel.add(pgVx);
		// --second graph
		pgVy = new PaintGraphLine("t", "Vy", MC.getVY()); // инициализация
															// класса построения
															// графика функции
		pgVy.setSize(800, 160); // задание размеров
		pgVy.setBackground(Color.lightGray);// цвет
		pgVy.setLocation(180, 190);
		panel.add(pgVy);
		// -------
		pgw = new PaintGraphLine("t", "w", MC.getw(), 100); // инициализация
															// класса построения
															// графика функции
		pgw.setSize(800, 160); // задание размеров
		pgw.setBackground(Color.lightGray);// цвет
		pgw.setLocation(180, 360);
		panel.add(pgw);
		// ----------
		pgXY = new PaintGraphCircle("Vx", "Vy", MC.getVX(), MC.getVY(), 1, 1,
				60, 10, 1);
		pgXY.setSize(800, 160); // задание размеров
		pgXY.setBackground(Color.lightGray);// цвет
		pgXY.setLocation(180, 530);
		panel.add(pgXY);
		// ----------
		pgXY.addMouseListener(this);
		setResizable(false);
		setVisible(true);
		setContentPane(panel);
	}

	@Override
	public void mouseClicked(MouseEvent me) {
		// throw new UnsupportedOperationException("Not supported yet."); //To
		// change body of generated methods, choose Tools | Templates.
		pgXYmov = new PaintGraphCircle("Vx", "Vy", MC.getVX(), MC.getVY(), 1,
				1, 20, 20, 1);
		new BigGraphicUniFrame(pgXYmov);
	}

	@Override
	public void mousePressed(MouseEvent me) {
		// throw new UnsupportedOperationException("Not supported yet."); //To
		// change body of generated methods, choose Tools | Templates.
	}

	@Override
	public void mouseReleased(MouseEvent me) {
		// throw new UnsupportedOperationException("Not supported yet."); //To
		// change body of generated methods, choose Tools | Templates.
	}

	@Override
	public void mouseEntered(MouseEvent me) {
		// throw new UnsupportedOperationException("Not supported yet."); //To
		// change body of generated methods, choose Tools | Templates.
	}

	@Override
	public void mouseExited(MouseEvent me) {
		// throw new UnsupportedOperationException("Not supported yet."); //To
		// change body of generated methods, choose Tools | Templates.
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\path\old_kutt\ModelCalc2.java

/*Not used */
package ua.edu.donntu.cs.path.old_kutt;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

/**
 * Этот класс не используется
 * 
 * @author Denis Vodolazskiy
 */
public class ModelCalc2 {

	//
	private double m = 2_0_000_000_000.0f; // масса судна
	private double lr = 40.0f; // расстояние от ДРК до ЦТ судна
	private double Vx = 0.0f, Vy = 0.0f;// скорости по осям
	private double v = 0.0f, w = 0.0f;// линейная и угловая скорости
	private int size = 10_000;
	private double VX[] = new double[size];
	private double VY[] = new double[size];
	private double ww[] = new double[size];
	// для второго интеграла
	private double X[] = new double[size];
	private double Y[] = new double[size];
	private double W[] = new double[size];
	// неподвижная система координат
	private double Xobs[] = new double[size];
	private double Yobs[] = new double[size];
	private double Wmov[] = new double[size];

	public ModelCalc2() {
		double k11, k22, k66, k26;
		double T = 4.0f, L = 80.0f, B = 15.0f;// осадка, длина, ширина c 323,
												// 321
		double delta = 0.7f;// коэффициент общей полноты
		double c1, c2, c3, m1, m2;// коэффициеты Р.Я.Першица
		double w_ = 0.0f;// угол дрейфа approx
		double betta_d = 0.0f;// угол дрейфа в центре тяжести (rad)
		double Cxr, Cyr, Cmr;// коэффициенты Cxr, боковой силы, момента
		// double L1=B,T1=L/2;//хорда, полудлина вертикального крыла
		// ????????????????????
		double p = 1000.0f;// плотность воды
		double Xr, Yr, Mr;// гидродинамические усилия
		double ZpTei;// полезная тяга винтов при равномерном прямолинейном
						// движении =R+Xa
		double Jz;// момент инерции массы судна относительно оси Gz
		double ZpYri;// боковая сила ДРК
		double a66 = 0.31f;// числовой коэффициент
		double Ramp = 0.0f;// для одиночных рулей
		double lyamdaR = 1.4f;// удлинение c 335 //0.5--1.4 //1
		double deltaR = 0.349f;// угол перекладки руля - 20% //0.349f
		// double Va;//скорость натекания воды на руль
		double Yri, Ysi;// боковая и стабилизирубщая силы
		double Ar = 6.0f;// площадь перьев//5 можно увеличить
		double D = 1.5f;// диаметр диска винта//2 можно уменьшить
		double Cta = 10.0f, Ctt = 50.0f;// c 334 //Cta<=20, 0.5--30, Ctt<=20,
										// 1--50
		// Ctt =30
		double Kvx, Kvy, Kw;// коэффиценты для производных
		double No = 30.0f;// обороты двигателя //Першин//3 оборота
		double Re = 5000000.0f;// Число Рейнольда >5E8
		double K_betta;
		double fit;
		double xk = 1.0f;
		double bettar = 0.9f;
		double fik = 0.95f;
		double ld_;// относительная длина насадки c228
		double betta_D;// коэффициент расширения
		double fiD;// c 338
		double CyD1;
		double CyD;
		double A0;// площадь диска винта
		double xD;// c 339
		double viv = 0.0f;// угол для неподвижной системы координат с 27 ch3_2
		double[][] Rmatr = new double[][] {
				{ Math.cos(viv), -Math.sin(viv), 0.0f },
				{ Math.sin(viv), Math.cos(viv), 0.0f }, { 0.0f, 0.0f, 1.0f } };
		// Math.cos(viv),-Math.sin(viv),0.0f,Math.sin(viv),Math.cos(viv),0.0f,0.0f,0.0f,1.0f};
		// ------------------------------------------------------------
		// c 330
		k11 = (5.91f * (double) Math.pow(B / L, 2.0f) + 7.76f * (B / L) - 0.259f)
				/ (48.4f - 6.89f * (B / T) + 1.47f
						* (double) Math.pow(B / T, 2.0f) - 0.0475f * (double) Math
						.pow(B / T, 3.0f));
		k22 = ((0.722f + 0.224f * delta) * (1.022f - (double) Math.pow(B / L,
				2.0f))) / (0.264f + 0.368f * (B / T));
		k66 = (2.0f * T / B) * (2.59f + 0.781f * delta)
				* (0.357f - 1.77f * (double) Math.pow(B / L, 2.0f));
		k26 = k22;
		// k26=0;
		// System.out.printf("k11=%f\tk22=%f\tk66=%f\tk26=%f\n", k11, k22, k66,
		// k26);
		// c 323
		c1 = 3.14f * (T / L)
				* (double) Math.pow((0.63f / delta), (5.0f / 2.0f))
				* (double) Math.pow(L / (6.0f * B), (1.0f / 3.0f)) - 0.032f;
		c2 = -2.0f * k11 * delta * (B / L);
		c3 = 1.35f * (double) Math.pow(T / B, (1.0f / 2.0f))
				* (double) Math.pow((0.63f / delta), (3.0f / 2.0f)) - 0.029f;
		m1 = 1.67f * (T / L) - 0.56f * delta + 0.43f;
		m2 = -0.44f * (T / L) - 0.0375f;
		// System.out.printf("c1=%f\tc2=%f\tc3=%f\tm1=%f\tm2=%f\n", c1, c2, c3,
		// m1, m2);
		Jz = (m * (double) Math.pow(L, 2.0f) / 12.4f)
				* (0.463f + 0.574f * (double) Math.pow(delta, a66) + (double) Math
						.pow(B / L, 2.0f));// c 330
		/*
		 * коэффиценты для производных: 1/m(1+k11) 1/m(1+k22) 1/Jz(1+k26)
		 */
		Kvx = 1 / (m * (1 + k11));
		Kvy = 1 / (m * (1 + k22));
		Kw = 1 / (Jz * (1 + k26));// ????? m
		// System.out.printf("Kvx=%g\tKvy=%g\tKw=%g\n", Kvx, Kvy, Kw);
		// ----------------------------------------------------------------

		double k1, k2, k3, k4;
		double q1, q2, q3, q4;
		double z1, z2, z3, z4;
		double j1, j2, j3, j4;
		// t = 0.0f; // шаг времени
		int t = 0;
		double h = 1f;
		// System.out.printf("\tVx\t\tVy\t\tw\tt\n");
		Vx = 5.0f;
		Vy = 0.0f;
		w = 0.0f;
		// -------------------------------------
		try {
			BufferedWriter outfile = new BufferedWriter(new FileWriter(
					"data/outfiles/VxVy.txt"));
			BufferedWriter outfile2 = new BufferedWriter(new FileWriter(
					"data/outfiles/viv.txt"));
			BufferedWriter outfile3 = new BufferedWriter(new FileWriter(
					"data/outfiles/XY.txt"));
			BufferedWriter outfile4 = new BufferedWriter(new FileWriter(
					"data/outfiles/XYmov.txt"));
			//
			outfile.write("\t Vx\t\t\t\t Vy\t\t\t\t w\t\t\t t\n");
			//
			outfile3.write("X\t\t Y\t\t W" + "\n");
			//
			outfile4.write("Xmov\t\t Ymov\t\t Wmov" + "\n");
			// ------------------------
			for (int i = 0; i < size; i++) { // 16550
				v = (double) Math.sqrt((double) Math.pow(Vx, 2.0f)
						+ (double) Math.pow(Vy, 2.0f));
				if (Vx != 0) {
					// c 353 ?????????????????????????
					w_ = w * L / v;// ??????????????????????
					betta_d = -(double) Math.atan(Vy / Vx);// c 350
				} else {
					w_ = 0;
					betta_d = 0;
				}
				// System.out.println(w_);
				Cxr = 0.01f * (1.0f + 170.0f * (T / L));// для плота c 119
				Cyr = c1 * betta_d + c2 * w_ + c3 * betta_d * Math.abs(betta_d);// c
																				// 323
				Cmr = m1 * betta_d + m2 * w_;

				Xr = Cxr * L * T * (double) Math.pow(v, 2.0f) * p / 2.0f;// c
																			// 320
				Yr = Cyr * L * T * (double) Math.pow(v, 2.0f) * p / 2.0f;
				Mr = Cmr * L * T * (double) Math.pow(v, 2.0f) * p / 2.0f;

				K_betta = 0.43f * (double) Math.pow(Ctt, -0.6f);
				fit = (double) Math.pow(1.0f + Ctt, 0.508f);
				// Yri = 3.14f * (lyamdaR - K_betta * xk * (betta_d + lr * w_))
				// * p * Ar * (double) Math.pow(v * fik * fit, 2.0f) / (1.0f +
				// 2.2f / (double) Math.pow(lyamdaR, 2.0f / 3.0f));
				// Yri=(3.14f*2.0f)/(1.0f+2.2f/Math.pow(lyamdaR,2.0f/3.0f))*(deltaR-xk*bettar)*Ramp*Math.pow(v*fik,2.0f)*Ar*p/2.0f;//Va=V*fir
				// Yri = 3.14f * (lyamdaR - K_betta * xk * (betta_d + lr *
				// w_))*(deltaR-xk*bettar) * p * Ar * (double) Math.pow(v * fik
				// * fit, 2.0f) / (1.0f + 2.2f / (double) Math.pow(lyamdaR, 2.0f
				// / 3.0f));

				// IMOPRTANT!!! deltaR
				Yri = 3.14f
						* (deltaR - K_betta * xk * (betta_d + lr * w_))
						* p
						* Ar
						* (double) Math.pow(v * fik * fit, 2.0f)
						/ (1.0f + 2.2f / (double) Math
								.pow(lyamdaR, 2.0f / 3.0f));

				ld_ = 0.77f - 0.125f * (double) Math.sqrt(Ctt)
						/ (1.65f * (double) Math.sqrt(Ctt) - 1.0f);
				betta_D = 1.22f - 0.0563f * (double) Math.sqrt(Ctt)
						/ (1.65f * (double) Math.sqrt(Ctt) - 1.0f);
				fiD = 0.5f * ((double) Math.sqrt(1.0f + 2.0f * Ctt / betta_D) + 1.0f);

				CyD1 = 12.0f * ld_ / (1.0f + 1.56f * ld_);
				CyD = CyD1 + 2.0f * betta_D * (double) Math.pow(fiD, 2.0f);
				xD = xk
						* (CyD1 + 2.0f * betta_D * fiD)
						/ (CyD1 + 2.0f * betta_D * (double) Math.pow(fiD, 2.0f));
				A0 = 3.14f * (double) Math.pow(D, 2.0f) / 4.0f;
				Ysi = CyD * (xD - 0.02f * xk) * (betta_d + lr * w_)
						* (p / 2.0f) * A0 * (double) Math.pow(v, 2.0f)
						* (double) Math.pow(fik, 2.0f);

				// ZpTei = Xr;//при прямолинейном движении Xr=R
				ZpTei = 9.740f * (double) Math.pow(No, 2.0f) - 2.23f * v; // Пелевин//9.740f

				ZpYri = 2.0f * (Yri - Ysi);// 2 винта
				// printf("ZpTei=%f\tZpYri=%f\t\n",ZpTei,ZpYri);

				k1 = h * vxd(Vy, w, ZpTei, Xr, Kvx);
				q1 = h * vyd(Vx, w, ZpYri, Yr, Kvy);
				z1 = h * wd(Mr, ZpTei, Yr, Kw);

				k2 = h * vxd(Vy + q1 / 2.0f, w + z1 / 2.0f, ZpTei, Xr, Kvx);
				q2 = h * vyd(Vx + k1 / 2.0f, w + z1 / 2.0f, ZpYri, Yr, Kvy);
				z2 = h * wd(Mr, ZpYri, Yr, Kw);

				k3 = h * vxd(Vy + q2 / 2.0f, w + z2 / 2.0f, ZpTei, Xr, Kvx);
				q3 = h * vyd(Vx + k2 / 2.0f, w + z2 / 2.0f, ZpYri, Yr, Kvy);
				z3 = h * wd(Mr, ZpYri, Yr, Kw);

				k4 = h * vxd(Vy + q3, w + z3, ZpTei, Xr, Kvx);
				q4 = h * vyd(Vx + k3, w + z3, ZpYri, Yr, Kvy);
				z4 = h * wd(Mr, ZpYri, Yr, Kw);

				Vx = Vx + (1.0f / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
				VX[t] = Vx;
				Vy = Vy + (1.0f / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
				VY[t] = Vy;
				w = w + (1.0f / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);
				ww[t] = w;

				// ---второй интеграл-----------------------------------------
				k1 = h * vxd(Vy, w, ZpTei, Xr, Kvx);
				q1 = h * vyd(Vx, w, ZpYri, Yr, Kvy);
				z1 = h * wd(Mr, ZpTei, Yr, Kw);

				k2 = h * vxd(Vy + q1 / 2.0f, w + z1 / 2.0f, ZpTei, Xr, Kvx);
				q2 = h * vyd(Vx + k1 / 2.0f, w + z1 / 2.0f, ZpYri, Yr, Kvy);
				z2 = h * wd(Mr, ZpYri, Yr, Kw);

				k3 = h * vxd(Vy + q2 / 2.0f, w + z2 / 2.0f, ZpTei, Xr, Kvx);
				q3 = h * vyd(Vx + k2 / 2.0f, w + z2 / 2.0f, ZpYri, Yr, Kvy);
				z3 = h * wd(Mr, ZpYri, Yr, Kw);

				k4 = h * vxd(Vy + q3, w + z3, ZpTei, Xr, Kvx);
				q4 = h * vyd(Vx + k3, w + z3, ZpYri, Yr, Kvy);
				z4 = h * wd(Mr, ZpYri, Yr, Kw);

				X[t] = Vx + (1.0f / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
				Y[t] = Vy + (1.0f / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
				W[t] = w + (1.0f / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);
				outfile3.write(X[t] + "\t" + Y[t] + "\t" + W[t] + "\n");
				// угол для неподвижной системы координат
				/*
				 * j1 = h * wd(Mr, ZpTei, Yr, Kw); j2 = h * wd(Mr, ZpYri, Yr,
				 * Kw); j3 = h * wd(Mr, ZpYri, Yr, Kw); j4 = h * wd(Mr, ZpYri,
				 * Yr, Kw); viv = w + (1.0f / 6.0f) * (j1 + 2.0f * j2 + 2.0f *
				 * j3 + j4);
				 */
				viv = W[t];
				outfile2.write("viv=" + viv + "\n");
				// System.out.println("viv="+viv);
				// -------
				Rmatr[0][0] = Math.cos(viv);
				Rmatr[0][1] = -Math.sin(viv);
				Rmatr[1][0] = Math.sin(viv);
				Rmatr[1][1] = Math.cos(viv);
				Xobs[t] = Rmatr[0][0] * X[t] + Rmatr[0][1] * Y[t];
				Yobs[t] = Rmatr[1][0] * X[t] + Rmatr[1][1] * Y[t];
				outfile4.write(Xobs[t] + "\t" + Yobs[t] + "\n");
				// ----------
				t += 1f;

				outfile.write(Vx + "\t\t" + Vy + "\t\t" + w + "\t\t" + t + "\n");
			}
			outfile.close();
			outfile2.close();
			outfile3.close();
			outfile4.close();
		} catch (IOException e) {
		}
		// --------------------------------------------------------------------
	}

	public double vxd(double Vy, double w, double ZpTei, double Xr, double Kvx) {
		return ((m * Vy * w - Xr + ZpTei) * Kvx);
	}

	public double vyd(double Vx, double w, double ZpYri, double Yr, double Kvy) {
		return ((Yr - ZpYri - m * Vx * w) * Kvy);
	}

	public double wd(double Mr, double ZpYri, double Yr, double Kw) {
		return ((Mr + lr * ZpYri) * Kw);
	}

	public double[] getVX() {
		return VX;
	}

	public double[] getVY() {
		return VY;
	}

	public double[] getw() {
		return ww;
	}

	public double[] getX() {
		return X;
	}

	public double[] getY() {
		return Y;
	}

	public double[] getW() {
		return W;
	}

	public double[] getXobs() {
		return Xobs;
	}

	public double[] getYobs() {
		return Yobs;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\path\old_kutt\ModelCalcNoEngine.java

/*Not used*/
package ua.edu.donntu.cs.path.old_kutt;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

/**
 * Этот класс не используется
 * 
 * @author Denis Vodolazskiy
 */
public class ModelCalcNoEngine {

	// with k11 - 580.91
	private float T = 4.0f, L = 80.0f, B = 15.0f;// осадка, длина, ширина c 323,
													// 321
	private float m = 2_0_000_000_000.0f; // масса судна
	private float lr = 40.0f; // расстояние от ДРК до ЦТ судна
	private float Vx = 0.0f, Vy = 0.0f;// скорости по осям
	private float v = 0.0f, w = 0.0f;// линейная и угловая скорости
	private float Rc;// радиус циркуляции
	private int size = 80_000;
	private float VX[] = new float[size];
	private float VY[] = new float[size];
	private float ww[] = new float[size];
	// для второго интеграла
	private float X[] = new float[size];
	private float Y[] = new float[size];
	private float W[] = new float[size];
	// неподвижная система координат
	private float Xobs[] = new float[size];
	private float Yobs[] = new float[size];
	private float Wmov[] = new float[size];

	public ModelCalcNoEngine() {
		float k11, k22, k66, k26;
		float delta = 0.7f;// коэффициент общей полноты
		float c1, c2, c3, m1, m2;// коэффициеты Р.Я.Першица
		float w_ = 0.0f;// угол дрейфа approx
		float betta_d = 0.0f;// угол дрейфа в центре тяжести (rad)
		float Cxr, Cyr, Cmr;// коэффициенты Cxr, боковой силы, момента
		// float L1=B,T1=L/2;//хорда, полудлина вертикального крыла
		// ????????????????????
		float p = 1000.0f;// плотность воды
		float Xr, Yr, Mr;// гидродинамические усилия
		float ZpTei = 0;// полезная тяга винтов при равномерном прямолинейном
						// движении =R+Xa
		float Jz;// момент инерции массы судна относительно оси Gz
		float ZpYri;// боковая сила ДРК
		float a66 = 0.31f;// числовой коэффициент
		float Ramp = 0.0f;// для одиночных рулей
		float lyamdaR = 1.4f;// удлинение c 335 //0.5--1.4 //1
		float deltaR = 0.349f;// угол перекладки руля - 20% //0.349f
		// float Va;//скорость натекания воды на руль
		float Yri, Ysi;// боковая и стабилизирубщая силы
		float Ar = 6.0f;// площадь перьев//5 можно увеличить
		float D = 1.5f;// диаметр диска винта//2 можно уменьшить
		float Cta = 10.0f, Ctt = 50.0f;// c 334 //Cta<=20, 0.5--30, Ctt<=20,
										// 1--50 UP!!!
		// Ctt =30
		float Kvx, Kvy, Kw;// коэффиценты для производных
		float No = 3.0f;// обороты двигателя //Першин//3 оборота
		float Re = 5000000.0f;// Число Рейнольда >5E8
		float K_betta;
		float fit;
		float xk = 1.0f;
		float bettar = 0.9f;
		float fik = 0.95f;
		float ld_;// относительная длина насадки c228
		float betta_D;// коэффициент расширения
		float fiD;// c 338
		float CyD1;
		float CyD;
		float A0;// площадь диска винта
		float xD;// c 339
		float viv = 0.0f;// угол для неподвижной системы координат с 27 ch3_2
		float[][] Rmatr = new float[][] {
				{ (float) Math.cos(viv), -(float) Math.sin(viv), 0.0f },
				{ (float) Math.sin(viv), (float) Math.cos(viv), 0.0f },
				{ 0.0f, 0.0f, 1.0f } };
		// Math.cos(viv),-Math.sin(viv),0.0f,Math.sin(viv),Math.cos(viv),0.0f,0.0f,0.0f,1.0f};
		// ------------------------------------------------------------
		// c 330 5.91-в книге, 580.91 - выравнять Х
		k11 = (580.91f * (float) Math.pow(B / L, 2.0f) + 7.76f * (B / L) - 0.259f)
				/ (48.4f - 6.89f * (B / T) + 1.47f
						* (float) Math.pow(B / T, 2.0f) - 0.0475f * (float) Math
						.pow(B / T, 3.0f));

		k22 = ((0.722f + 0.224f * delta) * (1.022f - (float) Math.pow(B / L,
				2.0f))) / (0.264f + 0.368f * (B / T));
		k66 = (2.0f * T / B) * (2.59f + 0.781f * delta)
				* (0.357f - 1.77f * (float) Math.pow(B / L, 2.0f));
		k26 = k22;
		// k26=0;
		// System.out.printf("k11=%f\tk22=%f\tk66=%f\tk26=%f\n", k11, k22, k66,
		// k26);
		// c 323
		c1 = 3.14f * (T / L) * (float) Math.pow((0.63f / delta), (5.0f / 2.0f))
				* (float) Math.pow(L / (6.0f * B), (1.0f / 3.0f)) - 0.032f;
		c2 = -2.0f * k11 * delta * (B / L);
		c3 = 1.35f * (float) Math.pow(T / B, (1.0f / 2.0f))
				* (float) Math.pow((0.63f / delta), (3.0f / 2.0f)) - 0.029f;
		m1 = 1.67f * (T / L) - 0.56f * delta + 0.43f;
		m2 = -0.44f * (T / L) - 0.0375f;
		// System.out.printf("c1=%f\tc2=%f\tc3=%f\tm1=%f\tm2=%f\n", c1, c2, c3,
		// m1, m2);
		Jz = (m * (float) Math.pow(L, 2.0f) / 12.4f)
				* (0.463f + 0.574f * (float) Math.pow(delta, a66) + (float) Math
						.pow(B / L, 2.0f));// c 330
		/*
		 * коэффиценты для производных: 1/m(1+k11) 1/m(1+k22) 1/Jz(1+k26)
		 */
		Kvx = 1 / (m * (1 + k11));
		Kvy = 1 / (m * (1 + k22));
		Kw = 1 / (Jz * (1 + k66));// ????? m
		// System.out.printf("Kvx=%g\tKvy=%g\tKw=%g\n", Kvx, Kvy, Kw);
		// ----------------------------------------------------------------

		float k1, k2, k3, k4;
		float q1, q2, q3, q4;
		float z1, z2, z3, z4;
		float j1, j2, j3, j4;
		// t = 0.0f; // шаг времени
		int t = 0;
		float h = 1f;
		// System.out.printf("\tVx\t\tVy\t\tw\tt\n");
		Vx = 5.0f;
		Vy = 0.0f;
		w = 0.0f;
		// -------------------------------------
		try {
			BufferedWriter outfile = new BufferedWriter(new FileWriter(
					"data/outfiles/VxVy.txt"));
			BufferedWriter outfile2 = new BufferedWriter(new FileWriter(
					"data/outfiles/viv.txt"));
			BufferedWriter outfile3 = new BufferedWriter(new FileWriter(
					"data/outfiles/XY.txt"));
			BufferedWriter outfile4 = new BufferedWriter(new FileWriter(
					"data/outfiles/XYmov.txt"));
			//
			outfile.write("\t Vx\t\t\t\t Vy\t\t\t\t w\t\t\t t\n");
			//
			outfile3.write("X\t\t Y\t\t W" + "\n");
			//
			outfile4.write("Xmov\t\t Ymov\t\t Wmov" + "\n");
			// ------------------------
			for (int i = 0; i < size; i++) { // 16550
				v = (float) Math.sqrt((float) Math.pow(Vx, 2.0f)
						+ (float) Math.pow(Vy, 2.0f));
				// assert(Vx==0);
				if (Vx != 0) {
					// c 353 ?????????????????????????
					w_ = w * L / v;// ??????????????????????
					betta_d = -(float) Math.atan(Vy / Vx);// c 350
				} else {
					w_ = w * L / v;
					// betta_d = 0;
					betta_d = -(float) Math.atan(Vy / Vx);// c 350
				}
				// System.out.println(w_);
				Cxr = 0.01f * (1.0f + 170.0f * (T / L));// для плота c 119
				Cyr = c1 * betta_d + c2 * w_ + c3 * betta_d * Math.abs(betta_d);// c
																				// 323
				Cmr = m1 * betta_d + m2 * w_;

				Xr = Cxr * L * T * (float) Math.pow(v, 2.0f) * p / 2.0f;// c 320
				Yr = Cyr * L * T * (float) Math.pow(v, 2.0f) * p / 2.0f;
				Mr = Cmr * L * T * (float) Math.pow(v, 2.0f) * p / 2.0f;

				K_betta = 0.43f * (float) Math.pow(Ctt, -0.6f);
				fit = (float) Math.pow(1.0f + Ctt, 0.508f);
				// Yri = 3.14f * (lyamdaR - K_betta * xk * (betta_d + lr * w_))
				// * p * Ar * (float) Math.pow(v * fik * fit, 2.0f) / (1.0f +
				// 2.2f / (float) Math.pow(lyamdaR, 2.0f / 3.0f));
				// Yri=(3.14f*2.0f)/(1.0f+2.2f/Math.pow(lyamdaR,2.0f/3.0f))*(deltaR-xk*bettar)*Ramp*Math.pow(v*fik,2.0f)*Ar*p/2.0f;//Va=V*fir
				// Yri = 3.14f * (lyamdaR - K_betta * xk * (betta_d + lr *
				// w_))*(deltaR-xk*bettar) * p * Ar * (float) Math.pow(v * fik *
				// fit, 2.0f) / (1.0f + 2.2f / (float) Math.pow(lyamdaR, 2.0f /
				// 3.0f));

				// IMOPRTANT!!! deltaR
				Yri = 3.14f
						* (deltaR - K_betta * xk * (betta_d + lr * w_))
						* p
						* Ar
						* (float) Math.pow(v * fik * fit, 2.0f)
						/ (1.0f + 2.2f / (float) Math.pow(lyamdaR, 2.0f / 3.0f));

				ld_ = 0.77f - 0.125f * (float) Math.sqrt(Ctt)
						/ (1.65f * (float) Math.sqrt(Ctt) - 1.0f);
				betta_D = 1.22f - 0.0563f * (float) Math.sqrt(Ctt)
						/ (1.65f * (float) Math.sqrt(Ctt) - 1.0f);
				fiD = 0.5f * ((float) Math.sqrt(1.0f + 2.0f * Ctt / betta_D) + 1.0f);

				CyD1 = 12.0f * ld_ / (1.0f + 1.56f * ld_);
				CyD = CyD1 + 2.0f * betta_D * (float) Math.pow(fiD, 2.0f);
				xD = xk * (CyD1 + 2.0f * betta_D * fiD)
						/ (CyD1 + 2.0f * betta_D * (float) Math.pow(fiD, 2.0f));
				A0 = 3.14f * (float) Math.pow(D, 2.0f) / 4.0f;
				Ysi = CyD * (xD - 0.02f * xk) * (betta_d + lr * w_)
						* (p / 2.0f) * A0 * (float) Math.pow(v, 2.0f)
						* (float) Math.pow(fik, 2.0f);

				// ZpTei = Xr;//при прямолинейном движении Xr=R
				// ZpTei = 1000_000f * (9.740f * (float) Math.pow(No, 2.0f) -
				// 2.23f * v); //Пелевин//9.740f
				/*
				 * float dP = 10_000_000f; float Wt, Fr, xp = 2f; Fr = v /
				 * (Math.sqrt(9.8f * L)); Wt = 0.11f + (0.16f / xp) *
				 * Math.pow(delta, xp) * Math.sqrt(Math.pow(v, 1.0f / 3.0f) / D)
				 * - 0.3f * delta * (Fr - 0.2f);
				 * 
				 * ZpTei = 2.0f * dP * A0*(1.0f-0.8f*Wt*(1.0f+0.25f*Wt));
				 */

				ZpYri = 2.0f * (Yri - Ysi);// 2 винта
				// printf("ZpTei=%f\tZpYri=%f\t\n",ZpTei,ZpYri);

				k1 = h * vxd(Vy, w, ZpTei, Xr, Kvx);
				q1 = h * vyd(Vx, w, ZpYri, Yr, Kvy);
				z1 = h * wd(Mr, ZpTei, Yr, Kw);

				k2 = h * vxd(Vy + q1 / 2.0f, w + z1 / 2.0f, ZpTei, Xr, Kvx);
				q2 = h * vyd(Vx + k1 / 2.0f, w + z1 / 2.0f, ZpYri, Yr, Kvy);
				z2 = h * wd(Mr, ZpYri, Yr, Kw);

				k3 = h * vxd(Vy + q2 / 2.0f, w + z2 / 2.0f, ZpTei, Xr, Kvx);
				q3 = h * vyd(Vx + k2 / 2.0f, w + z2 / 2.0f, ZpYri, Yr, Kvy);
				z3 = h * wd(Mr, ZpYri, Yr, Kw);

				k4 = h * vxd(Vy + q3, w + z3, ZpTei, Xr, Kvx);
				q4 = h * vyd(Vx + k3, w + z3, ZpYri, Yr, Kvy);
				z4 = h * wd(Mr, ZpYri, Yr, Kw);

				Vx = Vx + (1.0f / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
				// VX[t] = Vx / 1.24f;
				VX[t] = Vx;
				Vy = Vy + (1.0f / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
				VY[t] = Vy;
				w = w + (1.0f / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);
				ww[t] = w;

				// ---второй интеграл-----------------------------------------
				k1 = h * vxd(Vy, w, ZpTei, Xr, Kvx);
				q1 = h * vyd(Vx, w, ZpYri, Yr, Kvy);
				z1 = h * wd(Mr, ZpTei, Yr, Kw);

				k2 = h * vxd(Vy + q1 / 2.0f, w + z1 / 2.0f, ZpTei, Xr, Kvx);
				q2 = h * vyd(Vx + k1 / 2.0f, w + z1 / 2.0f, ZpYri, Yr, Kvy);
				z2 = h * wd(Mr, ZpYri, Yr, Kw);

				k3 = h * vxd(Vy + q2 / 2.0f, w + z2 / 2.0f, ZpTei, Xr, Kvx);
				q3 = h * vyd(Vx + k2 / 2.0f, w + z2 / 2.0f, ZpYri, Yr, Kvy);
				z3 = h * wd(Mr, ZpYri, Yr, Kw);

				k4 = h * vxd(Vy + q3, w + z3, ZpTei, Xr, Kvx);
				q4 = h * vyd(Vx + k3, w + z3, ZpYri, Yr, Kvy);
				z4 = h * wd(Mr, ZpYri, Yr, Kw);

				X[t] = Vx + (1.0f / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
				Y[t] = Vy + (1.0f / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
				W[t] = w + (1.0f / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);
				outfile3.write(X[t] + "\t" + Y[t] + "\t" + W[t] + "\n");
				// угол для неподвижной системы координат
				/*
				 * j1 = h * wd(Mr, ZpTei, Yr, Kw); j2 = h * wd(Mr, ZpYri, Yr,
				 * Kw); j3 = h * wd(Mr, ZpYri, Yr, Kw); j4 = h * wd(Mr, ZpYri,
				 * Yr, Kw); viv = w + (1.0f / 6.0f) * (j1 + 2.0f * j2 + 2.0f *
				 * j3 + j4);
				 */
				viv = W[t];
				outfile2.write("viv=" + viv + "\n");
				// System.out.println("viv="+viv);
				// -------
				Rmatr[0][0] = (float) Math.cos(viv);
				Rmatr[0][1] = -(float) Math.sin(viv);
				Rmatr[1][0] = (float) Math.sin(viv);
				Rmatr[1][1] = (float) Math.cos(viv);
				Xobs[t] = Rmatr[0][0] * X[t] + Rmatr[0][1] * Y[t];
				Yobs[t] = Rmatr[1][0] * X[t] + Rmatr[1][1] * Y[t];
				outfile4.write(Xobs[t] + "\t" + Yobs[t] + "\n");
				// ----------
				t += 1f;

				outfile.write(Vx + "\t\t" + Vy + "\t\t" + w + "\t\t" + t + "\n");
			}
			outfile.close();
			outfile2.close();
			outfile3.close();
			outfile4.close();
		} catch (IOException e) {
		}
		// Rc=v/w;
		// --------------------------------------------------------------------
	}

	public float vxd(float Vy, float w, float ZpTei, float Xr, float Kvx) {
		if (Vy > 0) {
			return ((m * Vy * w - Xr + ZpTei) * Kvx);
		} else {
			return ((m * Vy * w - Xr + ZpTei) * Kvx);// Vx*1.061
														// ;N0=3;k11=580.91f
														// Ubuntu
		}// *1.1045; k11=580.91f windows
	}

	public float vyd(float Vx, float w, float ZpYri, float Yr, float Kvy) {
		if (Vx > 0) {
			return ((Yr - ZpYri - m * Vx * w) * Kvy);// Vx*1.0179
		} else {// *1.0165; k11=580.91f windows
			return ((Yr - ZpYri - m * Vx * w) * Kvy);
		}
	}

	public float wd(float Mr, float ZpYri, float Yr, float Kw) {
		return ((Mr + lr * ZpYri) * Kw);
	}

	public float[] getVX() {
		return VX;
	}

	public float[] getVY() {
		return VY;
	}

	public float[] getw() {
		return ww;
	}

	public float[] getX() {
		return X;
	}

	public float[] getY() {
		return Y;
	}

	public float[] getW() {
		return W;
	}

	public float[] getXobs() {
		return Xobs;
	}

	public float[] getYobs() {
		return Yobs;
	}

	public float getRc() {
		return Rc = v / w;
	}

	public float getL() {
		return L;
	}

}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\path\old_kutt\ModelCalcOld.java

/*Not Used*/
package ua.edu.donntu.cs.path.old_kutt;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

/**
 * Этот класс не используется
 * 
 * @author Denis Vodolazskiy
 */
public class ModelCalcOld {

	//
	private double m = 2_0_000_000_000.0f; // масса судна
	private double l_ = 40.0f; // расстояние от ДРК до ЦТ судна
	private double Vx = 0.0f, Vy = 0.0f;// скорости по осям
	private double v = 0.0f, w = 0.0f;// линейная и угловая скорости
	private int t;
	private double VX[] = new double[750];
	private double VY[] = new double[750];
	private double ww[] = new double[750];
	// для второго интеграла
	private double X[] = new double[750];
	private double Y[] = new double[750];
	private double W[] = new double[750];
	// неподвижная система координат
	private double Xmov[] = new double[750];
	private double Ymov[] = new double[750];
	private double Wmov[] = new double[750];

	public ModelCalcOld() {
		double k11, k22, k66, k26;
		double T = 4.0f, L = 80.0f, B = 15.0f;// осадка, длина, ширина c 323,
												// 321
		double delta = 0.7f;// коэффициент общей полноты
		double c1, c2, c3, m1, m2;// коэффициеты Р.Я.Першица
		double w_ = 0.0f;// угол дрейфа approx
		double betta_d = 0.0f;// угол дрейфа в центре тяжести (rad)

		double Cxr, Cyr, Cmr;// коэффициенты Cxr, боковой силы, момента
		/*
		 * ??
		 */// double L1=B,T1=L/2;//хорда, полудлина вертикального крыла
			// ????????????????????
		double p = 1000.0f;// плотность воды
		double Xr, Yr, Mr;// гидродинамические усилия
		double ZpTei;// полезная тяга винтов при равномерном прямолинейном
						// движении =R+Xa
		double Jz;// момент инерции массы судна относительно оси Gz
		double ZpYri;// боковая сила ДРК

		double a66 = 0.31f;// числовой коэффициент
		double Ramp = 0.0f;// для одиночных рулей
		double lyamdaR = 1.0f;// удлинение c 335
		double deltaR = 0.349f;// угол перекладки руля - 20%
		// double Va;//скорость натекания воды на руль
		double Yri, Ysi;// боковая и стабилизирубщая силы
		double Ar = 5.0f;// площадь перьев
		double D = 2.0f;// диаметр диска винта
		double Cta = 10.0f, Ctt = 30.0f;// c 334
		double Kvx, Kvy, Kw;// коэффиценты для производных
		double No = 3.0f;// обороты двигателя //Першин
		double Re = 5000000.0f;// Число Рейнольда >5E8
		double K_betta;

		double fit;
		double xk = 1.0f;
		double bettar = 0.9f;
		double fik = 0.95f;
		double ld_;// относительная длина насадки c228
		double betta_D;// коэффициент расширения
		double fiD;// c 338
		double CyD1;
		double CyD;
		double A0;// площадь диска винта
		double xD;// c 339
		double viv = 0.0f;// угол для неподвижной системы координат с 27 ch3_2
		double[][] Rmatr = new double[][] {
				{ Math.cos(viv), -Math.sin(viv), 0.0f },
				{ Math.sin(viv), Math.cos(viv), 0.0f }, { 0.0f, 0.0f, 1.0f } };

		// Math.cos(viv),-Math.sin(viv),0.0f,Math.sin(viv),Math.cos(viv),0.0f,0.0f,0.0f,1.0f};
		// ------------------------------------------------------------
		// c 330
		k11 = (5.91f * (double) Math.pow(B / L, 2.0f) + 7.76f * (B / L) - 0.259f)
				/ (48.4f - 6.89f * (B / T) + 1.47f
						* (double) Math.pow(B / T, 2.0f) - 0.0475f * (double) Math
						.pow(B / T, 3.0f));
		k22 = ((0.722f + 0.224f * delta) * (1.022f - (double) Math.pow(B / L,
				2.0f))) / (0.264f + 0.368f * (B / T));
		k66 = (2.0f * T / B) * (2.59f + 0.781f * delta)
				* (0.357f - 1.77f * (double) Math.pow(B / L, 2.0f));
		k26 = k22;
		// k26=0;
		System.out.printf("k11=%f\tk22=%f\tk66=%f\tk26=%f\n", k11, k22, k66,
				k26);
		// c 323
		c1 = 3.14f * (T / L)
				* (double) Math.pow((0.63f / delta), (5.0f / 2.0f))
				* (double) Math.pow(L / (6.0f * B), (1.0f / 3.0f)) - 0.032f;
		c2 = -2.0f * k11 * delta * (B / L);
		c3 = 1.35f * (double) Math.pow(T / B, (1.0f / 2.0f))
				* (double) Math.pow((0.63f / delta), (3.0f / 2.0f)) - 0.029f;
		m1 = 1.67f * (T / L) - 0.56f * delta + 0.43f;
		m2 = -0.44f * (T / L) - 0.0375f;
		System.out.printf("c1=%f\tc2=%f\tc3=%f\tm1=%f\tm2=%f\n", c1, c2, c3,
				m1, m2);
		Jz = (m * (double) Math.pow(L, 2.0f) / 12.4f)
				* (0.463f + 0.574f * (double) Math.pow(delta, a66) + (double) Math
						.pow(B / L, 2.0f));// c 330
		/*
		 * коэффиценты для производных: 1/m(1+k11) 1/m(1+k22) 1/Jz(1+k26)
		 */
		Kvx = 1 / (m * (1 + k11));
		Kvy = 1 / (m * (1 + k22));
		Kw = 1 / (Jz * (1 + k26));
		System.out.printf("Kvx=%g\tKvy=%g\tKw=%g\n", Kvx, Kvy, Kw);
		// ----------------------------------------------------------------

		double k1, k2, k3, k4;
		double q1, q2, q3, q4;
		double z1, z2, z3, z4;
		double j1, j2, j3, j4;
		// t = 0.0f; // шаг времени
		t = 0;
		System.out.printf("\tVx\t\tVy\t\tw\tt\n");
		Vx = 5.0f;
		Vy = 0.0f;
		w = 0.0f;
		// -------------------------------------
		try {
			BufferedWriter outfile = new BufferedWriter(new FileWriter(
					"data/outfiles/VxVy.txt"));
			BufferedWriter outfile2 = new BufferedWriter(new FileWriter(
					"data/outfiles/viv.txt"));
			BufferedWriter outfile3 = new BufferedWriter(new FileWriter(
					"data/outfiles/XY.txt"));
			BufferedWriter outfile4 = new BufferedWriter(new FileWriter(
					"data/outfiles/XYmov.txt"));
			//
			outfile.write("\t Vx\t\t\t\t Vy\t\t\t\t w\t\t\t t\n");
			//
			outfile3.write("X\t\t Y\t\t W" + "\n");
			//
			outfile4.write("Xmov\t\t Ymov\t\t Wmov" + "\n");
			// ------------------------
			for (int i = 0; i < 750; i++) { // 16550
				v = (double) Math.sqrt((double) Math.pow(Vx, 2.0f)
						+ (double) Math.pow(Vy, 2.0f));
				if (Vx != 0) {
					// c 353 ?????????????????????????
					w_ = w * L / v;// ??????????????????????
					betta_d = -(double) Math.atan(Vy / Vx);// c 350
				} else {
					w_ = 0;
					betta_d = 0;
				}
				Cxr = 0.01f * (1.0f + 170.0f * (T / L));// для плота c 119
				Cyr = c1 * betta_d + c2 * w_ + c3 * betta_d * Math.abs(betta_d);// c
																				// 323
				Cmr = m1 * betta_d + m2 * w_;

				Xr = Cxr * L * T * (double) Math.pow(v, 2.0f) * p / 2.0f;// c
																			// 320
				Yr = Cyr * L * T * (double) Math.pow(v, 2.0f) * p / 2.0f;
				Mr = Cmr * L * T * (double) Math.pow(v, 2.0f) * p / 2.0f;

				K_betta = 0.43f * (double) Math.pow(Ctt, -0.6f);
				fit = (double) Math.pow(1.0f + Ctt, 0.508f);
				Yri = 3.14f
						* (lyamdaR - K_betta * xk * (betta_d + l_ * w_))
						* p
						* Ar
						* (double) Math.pow(v * fik * fit, 2.0f)
						/ (1.0f + 2.2f / (double) Math
								.pow(lyamdaR, 2.0f / 3.0f));

				ld_ = 0.77f - 0.125f * (double) Math.sqrt(Ctt)
						/ (1.65f * (double) Math.sqrt(Ctt) - 1.0f);
				betta_D = 1.22f - 0.0563f * (double) Math.sqrt(Ctt)
						/ (1.65f * (double) Math.sqrt(Ctt) - 1.0f);
				fiD = 0.5f * ((double) Math.sqrt(1.0f + 2.0f * Ctt / betta_D) + 1.0f);

				CyD1 = 12.0f * ld_ / (1.0f + 1.56f * ld_);
				CyD = CyD1 + 2.0f * betta_D * (double) Math.pow(fiD, 2.0f);
				xD = xk
						* (CyD1 + 2.0f * betta_D * fiD)
						/ (CyD1 + 2.0f * betta_D * (double) Math.pow(fiD, 2.0f));
				A0 = 3.14f * (double) Math.pow(D, 2.0f) / 4.0f;
				Ysi = CyD * (xD - 0.02f * xk) * (betta_d + l_ * w_)
						* (p / 2.0f) * A0 * (double) Math.pow(v, 2.0f)
						* (double) Math.pow(fik, 2.0f);

				// ZpTei = Xr;//при прямолинейном движении Xr=R
				ZpTei = 9.740f * (double) Math.pow(No, 2.0f) - 2.23f * v; // Пелевин

				ZpYri = 2.0f * (Yri - Ysi);// 2 винта
				// printf("ZpTei=%f\tZpYri=%f\t\n",ZpTei,ZpYri);

				k1 = vxd(Vy, w, ZpTei, Xr, Kvx);
				q1 = vyd(Vx, w, ZpYri, Yr, Kvy);
				z1 = wd(Mr, ZpTei, Yr, Kw);

				k2 = vxd(Vy + (t * q1) / 2.0f, w + (t * z1) / 2.0f, ZpTei, Xr,
						Kvx);
				q2 = vyd(Vx + (t * k1) / 2.0f, w + (t * z1) / 2.0f, ZpYri, Yr,
						Kvy);
				z2 = wd(Mr, ZpYri, Yr, Kw);

				k3 = vxd(Vy + (t * q2) / 2.0f, w + (t * z2) / 2.0f, ZpTei, Xr,
						Kvx);
				q3 = vyd(Vx + (t * k2) / 2.0f, w + (t * z2) / 2.0f, ZpYri, Yr,
						Kvy);
				z3 = wd(Mr, ZpYri, Yr, Kw);

				k4 = vxd(Vy + (t * q3), w + (t * z3), ZpTei, Xr, Kvx);
				q4 = vyd(Vx + (t * k3), w + (t * z3), ZpYri, Yr, Kvy);
				z4 = wd(Mr, ZpYri, Yr, Kw);

				Vx = Vx + (t / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
				VX[t] = Vx;
				Vy = Vy + (t / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
				VY[t] = Vy;
				w = w + (t / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);
				ww[t] = w;

				// ---второй интеграл
				k1 = vxd(Vy, w, ZpTei, Xr, Kvx);
				q1 = vyd(Vx, w, ZpYri, Yr, Kvy);
				z1 = wd(Mr, ZpTei, Yr, Kw);

				k2 = vxd(Vy + (t * q1) / 2.0f, w + (t * z1) / 2.0f, ZpTei, Xr,
						Kvx);
				q2 = vyd(Vx + (t * k1) / 2.0f, w + (t * z1) / 2.0f, ZpYri, Yr,
						Kvy);
				z2 = wd(Mr, ZpYri, Yr, Kw);

				k3 = vxd(Vy + (t * q2) / 2.0f, w + (t * z2) / 2.0f, ZpTei, Xr,
						Kvx);
				q3 = vyd(Vx + (t * k2) / 2.0f, w + (t * z2) / 2.0f, ZpYri, Yr,
						Kvy);
				z3 = wd(Mr, ZpYri, Yr, Kw);

				k4 = vxd(Vy + (t * q3), w + (t * z3), ZpTei, Xr, Kvx);
				q4 = vyd(Vx + (t * k3), w + (t * z3), ZpYri, Yr, Kvy);
				z4 = wd(Mr, ZpYri, Yr, Kw);

				X[t] = Vx + (t / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
				Y[t] = Vy + (t / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
				W[t] = w + (t / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);
				outfile3.write(X[t] + "\t" + Y[t] + "\t" + W[t] + "\n");
				// угол для неподвижной системы координат
				j1 = t * wd(Mr, ZpTei, Yr, Kw);
				j2 = t * wd(Mr, ZpYri, Yr, Kw);
				j3 = t * wd(Mr, ZpYri, Yr, Kw);
				j4 = t * wd(Mr, ZpYri, Yr, Kw);
				viv = w + (1 / 6.0f) * (j1 + 2.0f * j2 + 2.0f * j3 + j4);
				outfile2.write("viv=" + viv + "\n");
				// System.out.println("viv="+viv);
				// -------
				Rmatr[0][0] = Math.cos(viv);
				Rmatr[0][1] = -Math.sin(viv);
				Rmatr[1][0] = Math.sin(viv);
				Rmatr[1][1] = Math.cos(viv);
				Xmov[t] = Rmatr[0][0] * X[t] + Rmatr[0][1] * Y[t];
				Ymov[t] = Rmatr[1][0] * X[t] + Rmatr[1][1] * Y[t];
				outfile4.write(Xmov[t] + "\t" + Ymov[t] + "\n");
				// ----------
				t += 1f;

				outfile.write(Vx + "\t\t" + Vy + "\t\t" + w + "\t\t" + t + "\n");
			}
			outfile.close();
			outfile2.close();
			outfile3.close();
			outfile4.close();
		} catch (IOException e) {
		}
		// --------------------------------------------------------------------
	}

	public double vxd(double Vy, double w, double ZpTei, double Xr, double Kvx) {
		// double Kvx=4.95715e-008f;
		// double m = 2_000_000_000_000.0f;
		return ((ZpTei + m * Vy * w - Xr) * Kvx);
	}

	public double vyd(double Vx, double w, double ZpYri, double Yr, double Kvy) {
		// double Kvy=2.3871e-008f;
		// double m = 2_000_000_000_000.0f;
		return ((Yr - ZpYri - m * Vx * w) * Kvy);
	}

	public double wd(double Mr, double ZpYri, double Yr, double Kw) {
		// double Kw=4.70718e-011f;
		// double lr = 40.0f;//расстояние от ДРК до ЦТ судна
		return ((Mr + l_ * ZpYri) * Kw);
	}

	public double[] getVX() {
		return VX;
	}

	public double[] getVY() {
		return VY;
	}

	public double[] getw() {
		return ww;
	}

	public double[] getX() {
		return X;
	}

	public double[] getY() {
		return Y;
	}

	public double[] getXmov() {
		return Xmov;
	}

	public double[] getYmov() {
		return Ymov;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\path\old_kutt\ModelCalcXrEngine.java

/*Not used */
package ua.edu.donntu.cs.path.old_kutt;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

/**
 * Этот класс не используется
 * 
 * @author Denis Vodolazskiy
 */
public class ModelCalcXrEngine {
	// with k11 - 580.91
	private double T = 4.0f, L = 80.0f, B = 15.0f;// осадка, длина, ширина c
													// 323, 321
	private double m = 2_0_000_000_000.0f; // масса судна
	private double lr = 40.0f; // расстояние от ДРК до ЦТ судна
	private double Vx = 0.0f, Vy = 0.0f;// скорости по осям
	private double v = 0.0f, w = 0.0f;// линейная и угловая скорости
	private double Rc;// радиус циркуляции
	private int size = 80_000;
	private double VX[] = new double[size];
	private double VY[] = new double[size];
	private double ww[] = new double[size];
	// для второго интеграла
	private double X[] = new double[size];
	private double Y[] = new double[size];
	private double W[] = new double[size];
	// неподвижная система координат
	private double Xobs[] = new double[size];
	private double Yobs[] = new double[size];
	private double Wmov[] = new double[size];

	public ModelCalcXrEngine() {
		double k11, k22, k66, k26;
		double delta = 0.7f;// коэффициент общей полноты
		double c1, c2, c3, m1, m2;// коэффициеты Р.Я.Першица
		double w_ = 0.0f;// угол дрейфа approx
		double betta_d = 0.0f;// угол дрейфа в центре тяжести (rad)
		double Cxr, Cyr, Cmr;// коэффициенты Cxr, боковой силы, момента
		// double L1=B,T1=L/2;//хорда, полудлина вертикального крыла
		// ????????????????????
		double p = 1000.0f;// плотность воды
		double Xr, Yr, Mr;// гидродинамические усилия
		double ZpTei = 0;// полезная тяга винтов при равномерном прямолинейном
							// движении =R+Xa
		double Jz;// момент инерции массы судна относительно оси Gz
		double ZpYri;// боковая сила ДРК
		double a66 = 0.31f;// числовой коэффициент
		double Ramp = 0.0f;// для одиночных рулей
		double lyamdaR = 1.4f;// удлинение c 335 //0.5--1.4 //1
		double deltaR = -0.349f;// угол перекладки руля - 20% //0.349f
		// double Va;//скорость натекания воды на руль
		double Yri, Ysi;// боковая и стабилизирубщая силы
		double Ar = 6.0f;// площадь перьев//5 можно увеличить
		double D = 1.5f;// диаметр диска винта//2 можно уменьшить
		double Cta = 10.0f, Ctt = 50.0f;// c 334 //Cta<=20, 0.5--30, Ctt<=20,
										// 1--50 UP!!!
		// Ctt =30
		double Kvx, Kvy, Kw;// коэффиценты для производных
		double No = 3.0f;// обороты двигателя //Першин//3 оборота
		double Re = 5000000.0f;// Число Рейнольда >5E8
		double K_betta;
		double fit;
		double xk = 1.0f;
		double bettar = 0.9f;
		double fik = 0.95f;
		double ld_;// относительная длина насадки c228
		double betta_D;// коэффициент расширения
		double fiD;// c 338
		double CyD1;
		double CyD;
		double A0;// площадь диска винта
		double xD;// c 339
		double viv = 0.0f;// угол для неподвижной системы координат с 27 ch3_2
		double[][] Rmatr = new double[][] {
				{ Math.cos(viv), -Math.sin(viv), 0.0f },
				{ Math.sin(viv), Math.cos(viv), 0.0f }, { 0.0f, 0.0f, 1.0f } };
		// Math.cos(viv),-Math.sin(viv),0.0f,Math.sin(viv),Math.cos(viv),0.0f,0.0f,0.0f,1.0f};
		// ------------------------------------------------------------
		// c 330 5.91-в книге, 580.91 - выравнять Х
		k11 = (580.91f * (double) Math.pow(B / L, 2.0f) + 7.76f * (B / L) - 0.259f)
				/ (48.4f - 6.89f * (B / T) + 1.47f
						* (double) Math.pow(B / T, 2.0f) - 0.0475f * (double) Math
						.pow(B / T, 3.0f));

		k22 = ((0.722f + 0.224f * delta) * (1.022f - (double) Math.pow(B / L,
				2.0f))) / (0.264f + 0.368f * (B / T));
		k66 = (2.0f * T / B) * (2.59f + 0.781f * delta)
				* (0.357f - 1.77f * (double) Math.pow(B / L, 2.0f));
		k26 = k22;
		// k26=0;
		// System.out.printf("k11=%f\tk22=%f\tk66=%f\tk26=%f\n", k11, k22, k66,
		// k26);
		// c 323
		c1 = 3.14f * (T / L)
				* (double) Math.pow((0.63f / delta), (5.0f / 2.0f))
				* (double) Math.pow(L / (6.0f * B), (1.0f / 3.0f)) - 0.032f;
		c2 = -2.0f * k11 * delta * (B / L);
		c3 = 1.35f * (double) Math.pow(T / B, (1.0f / 2.0f))
				* (double) Math.pow((0.63f / delta), (3.0f / 2.0f)) - 0.029f;
		m1 = 1.67f * (T / L) - 0.56f * delta + 0.43f;
		m2 = -0.44f * (T / L) - 0.0375f;
		// System.out.printf("c1=%f\tc2=%f\tc3=%f\tm1=%f\tm2=%f\n", c1, c2, c3,
		// m1, m2);
		Jz = (m * (double) Math.pow(L, 2.0f) / 12.4f)
				* (0.463f + 0.574f * (double) Math.pow(delta, a66) + (double) Math
						.pow(B / L, 2.0f));// c 330
		/*
		 * коэффиценты для производных: 1/m(1+k11) 1/m(1+k22) 1/Jz(1+k26)
		 */
		Kvx = 1 / (m * (1 + k11));
		Kvy = 1 / (m * (1 + k22));
		Kw = 1 / (Jz * (1 + k66));// ????? m
		// System.out.printf("Kvx=%g\tKvy=%g\tKw=%g\n", Kvx, Kvy, Kw);
		// ----------------------------------------------------------------

		double k1, k2, k3, k4;
		double q1, q2, q3, q4;
		double z1, z2, z3, z4;
		double j1, j2, j3, j4;
		// t = 0.0f; // шаг времени
		int t = 0;
		double h = 1f;
		// System.out.printf("\tVx\t\tVy\t\tw\tt\n");
		Vx = 5.0f;
		Vy = 0.0f;
		w = 0.0f;
		// -------------------------------------
		try {
			BufferedWriter outfile = new BufferedWriter(new FileWriter(
					"data/outfiles/VxVy.txt"));
			BufferedWriter outfile2 = new BufferedWriter(new FileWriter(
					"data/outfiles/viv.txt"));
			BufferedWriter outfile3 = new BufferedWriter(new FileWriter(
					"data/outfiles/XY.txt"));
			BufferedWriter outfile4 = new BufferedWriter(new FileWriter(
					"data/outfiles/XYmov.txt"));
			//
			outfile.write("\t Vx\t\t\t\t Vy\t\t\t\t w\t\t\t t\n");
			//
			outfile3.write("X\t\t Y\t\t W" + "\n");
			//
			outfile4.write("Xmov\t\t Ymov\t\t Wmov" + "\n");
			// ------------------------
			for (int i = 0; i < size; i++) { // 16550
				v = (double) Math.sqrt((double) Math.pow(Vx, 2.0f)
						+ (double) Math.pow(Vy, 2.0f));
				// assert(Vx==0);
				if (Vx != 0) {
					// c 353 ?????????????????????????
					w_ = w * L / v;// ??????????????????????
					betta_d = -(double) Math.atan(Vy / Vx);// c 350
				} else {
					w_ = w * L / v;
					// betta_d = 0;
					betta_d = -(double) Math.atan(Vy / Vx);// c 350
				}
				// System.out.println(w_);
				Cxr = 0.01f * (1.0f + 170.0f * (T / L));// для плота c 119
				Cyr = c1 * betta_d + c2 * w_ + c3 * betta_d * Math.abs(betta_d);// c
																				// 323
				Cmr = m1 * betta_d + m2 * w_;

				Xr = Cxr * L * T * (double) Math.pow(v, 2.0f) * p / 2.0f;// c
																			// 320
				Yr = Cyr * L * T * (double) Math.pow(v, 2.0f) * p / 2.0f;
				Mr = Cmr * L * T * (double) Math.pow(v, 2.0f) * p / 2.0f;

				K_betta = 0.43f * (double) Math.pow(Ctt, -0.6f);
				fit = (double) Math.pow(1.0f + Ctt, 0.508f);
				// Yri = 3.14f * (lyamdaR - K_betta * xk * (betta_d + lr * w_))
				// * p * Ar * (double) Math.pow(v * fik * fit, 2.0f) / (1.0f +
				// 2.2f / (double) Math.pow(lyamdaR, 2.0f / 3.0f));
				// Yri=(3.14f*2.0f)/(1.0f+2.2f/Math.pow(lyamdaR,2.0f/3.0f))*(deltaR-xk*bettar)*Ramp*Math.pow(v*fik,2.0f)*Ar*p/2.0f;//Va=V*fir
				// Yri = 3.14f * (lyamdaR - K_betta * xk * (betta_d + lr *
				// w_))*(deltaR-xk*bettar) * p * Ar * (double) Math.pow(v * fik
				// * fit, 2.0f) / (1.0f + 2.2f / (double) Math.pow(lyamdaR, 2.0f
				// / 3.0f));

				// IMOPRTANT!!! deltaR
				Yri = 3.14f
						* (deltaR - K_betta * xk * (betta_d + lr * w_))
						* p
						* Ar
						* (double) Math.pow(v * fik * fit, 2.0f)
						/ (1.0f + 2.2f / (double) Math
								.pow(lyamdaR, 2.0f / 3.0f));

				ld_ = 0.77f - 0.125f * (double) Math.sqrt(Ctt)
						/ (1.65f * (double) Math.sqrt(Ctt) - 1.0f);
				betta_D = 1.22f - 0.0563f * (double) Math.sqrt(Ctt)
						/ (1.65f * (double) Math.sqrt(Ctt) - 1.0f);
				fiD = 0.5f * ((double) Math.sqrt(1.0f + 2.0f * Ctt / betta_D) + 1.0f);

				CyD1 = 12.0f * ld_ / (1.0f + 1.56f * ld_);
				CyD = CyD1 + 2.0f * betta_D * (double) Math.pow(fiD, 2.0f);
				xD = xk
						* (CyD1 + 2.0f * betta_D * fiD)
						/ (CyD1 + 2.0f * betta_D * (double) Math.pow(fiD, 2.0f));
				A0 = 3.14f * (double) Math.pow(D, 2.0f) / 4.0f;
				Ysi = CyD * (xD - 0.02f * xk) * (betta_d + lr * w_)
						* (p / 2.0f) * A0 * (double) Math.pow(v, 2.0f)
						* (double) Math.pow(fik, 2.0f);

				ZpTei = Xr;// при прямолинейном движении Xr=R
				// ZpTei = 1000_000f * (9.740f * (double) Math.pow(No, 2.0f) -
				// 2.23f * v); //Пелевин//9.740f
				/*
				 * double dP = 10_000_000f; double Wt, Fr, xp = 2f; Fr = v /
				 * (Math.sqrt(9.8f * L)); Wt = 0.11f + (0.16f / xp) *
				 * Math.pow(delta, xp) * Math.sqrt(Math.pow(v, 1.0f / 3.0f) / D)
				 * - 0.3f * delta * (Fr - 0.2f);
				 * 
				 * ZpTei = 2.0f * dP * A0*(1.0f-0.8f*Wt*(1.0f+0.25f*Wt));
				 */

				ZpYri = 2.0f * (Yri - Ysi);// 2 винта
				// printf("ZpTei=%f\tZpYri=%f\t\n",ZpTei,ZpYri);

				k1 = h * vxd(Vy, w, ZpTei, Xr, Kvx);
				q1 = h * vyd(Vx, w, ZpYri, Yr, Kvy);
				z1 = h * wd(Mr, ZpTei, Yr, Kw);

				k2 = h * vxd(Vy + q1 / 2.0f, w + z1 / 2.0f, ZpTei, Xr, Kvx);
				q2 = h * vyd(Vx + k1 / 2.0f, w + z1 / 2.0f, ZpYri, Yr, Kvy);
				z2 = h * wd(Mr, ZpYri, Yr, Kw);

				k3 = h * vxd(Vy + q2 / 2.0f, w + z2 / 2.0f, ZpTei, Xr, Kvx);
				q3 = h * vyd(Vx + k2 / 2.0f, w + z2 / 2.0f, ZpYri, Yr, Kvy);
				z3 = h * wd(Mr, ZpYri, Yr, Kw);

				k4 = h * vxd(Vy + q3, w + z3, ZpTei, Xr, Kvx);
				q4 = h * vyd(Vx + k3, w + z3, ZpYri, Yr, Kvy);
				z4 = h * wd(Mr, ZpYri, Yr, Kw);

				Vx = Vx + (1.0f / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
				VX[t] = Vx / 1.24;
				VX[t] = Vx;
				Vy = Vy + (1.0f / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
				VY[t] = Vy;
				w = w + (1.0f / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);
				ww[t] = w;

				// ---второй интеграл-----------------------------------------
				k1 = h * vxd(Vy, w, ZpTei, Xr, Kvx);
				q1 = h * vyd(Vx, w, ZpYri, Yr, Kvy);
				z1 = h * wd(Mr, ZpTei, Yr, Kw);

				k2 = h * vxd(Vy + q1 / 2.0f, w + z1 / 2.0f, ZpTei, Xr, Kvx);
				q2 = h * vyd(Vx + k1 / 2.0f, w + z1 / 2.0f, ZpYri, Yr, Kvy);
				z2 = h * wd(Mr, ZpYri, Yr, Kw);

				k3 = h * vxd(Vy + q2 / 2.0f, w + z2 / 2.0f, ZpTei, Xr, Kvx);
				q3 = h * vyd(Vx + k2 / 2.0f, w + z2 / 2.0f, ZpYri, Yr, Kvy);
				z3 = h * wd(Mr, ZpYri, Yr, Kw);

				k4 = h * vxd(Vy + q3, w + z3, ZpTei, Xr, Kvx);
				q4 = h * vyd(Vx + k3, w + z3, ZpYri, Yr, Kvy);
				z4 = h * wd(Mr, ZpYri, Yr, Kw);

				X[t] = Vx + (1.0f / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
				Y[t] = Vy + (1.0f / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
				W[t] = w + (1.0f / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);
				outfile3.write(X[t] + "\t" + Y[t] + "\t" + W[t] + "\n");
				// угол для неподвижной системы координат
				/*
				 * j1 = h * wd(Mr, ZpTei, Yr, Kw); j2 = h * wd(Mr, ZpYri, Yr,
				 * Kw); j3 = h * wd(Mr, ZpYri, Yr, Kw); j4 = h * wd(Mr, ZpYri,
				 * Yr, Kw); viv = w + (1.0f / 6.0f) * (j1 + 2.0f * j2 + 2.0f *
				 * j3 + j4);
				 */
				viv = W[t];
				outfile2.write("viv=" + viv + "\n");
				// System.out.println("viv="+viv);
				// -------
				Rmatr[0][0] = Math.cos(viv);
				Rmatr[0][1] = -Math.sin(viv);
				Rmatr[1][0] = Math.sin(viv);
				Rmatr[1][1] = Math.cos(viv);
				Xobs[t] = Rmatr[0][0] * X[t] + Rmatr[0][1] * Y[t];
				Yobs[t] = Rmatr[1][0] * X[t] + Rmatr[1][1] * Y[t];
				outfile4.write(Xobs[t] + "\t" + Yobs[t] + "\n");
				// ----------
				t += 1f;

				outfile.write(Vx + "\t\t" + Vy + "\t\t" + w + "\t\t" + t + "\n");
			}
			outfile.close();
			outfile2.close();
			outfile3.close();
			outfile4.close();
		} catch (IOException e) {
		}
		// Rc=v/w;
		// --------------------------------------------------------------------
	}

	public double vxd(double Vy, double w, double ZpTei, double Xr, double Kvx) {
		if (Vy > 0) {
			return ((m * Vy * w - Xr + ZpTei) * Kvx);
		} else {
			return ((m * Vy * w - Xr + ZpTei) * Kvx);// Vx*1.061
														// ;N0=3;k11=580.91f
														// Ubuntu
		}// *1.1045; k11=580.91f windows
	}

	public double vyd(double Vx, double w, double ZpYri, double Yr, double Kvy) {
		if (Vx > 0) {
			return ((Yr - ZpYri - m * Vx * w) * Kvy);// Vx*1.0179
		} else {// *1.0165; k11=580.91f windows
			return ((Yr - ZpYri - m * Vx * w) * Kvy);
		}
	}

	public double wd(double Mr, double ZpYri, double Yr, double Kw) {
		return ((Mr + lr * ZpYri) * Kw);
	}

	public double[] getVX() {
		return VX;
	}

	public double[] getVY() {
		return VY;
	}

	public double[] getw() {
		return ww;
	}

	public double[] getX() {
		return X;
	}

	public double[] getY() {
		return Y;
	}

	public double[] getW() {
		return W;
	}

	public double[] getXobs() {
		return Xobs;
	}

	public double[] getYobs() {
		return Yobs;
	}

	public double getRc() {
		return Rc = v / w;
	}

	public double getL() {
		return L;
	}

}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\path\paint\PaintGraph.java

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ua.edu.donntu.cs.path.paint;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;

import javax.swing.JPanel;

/**
 * Абстрактная панель для построения графиков
 * 
 * @author Denis Vodolazskiy
 */
public abstract class PaintGraph extends JPanel {

	protected int xMagnitude = 5_000;
	protected int yMagnitude = 20;
	protected float velX[];// velocity
	protected float velY[];// velocity
	protected String xAxisName = "";
	protected String yAxisName = "";
	protected int divideForRealModelingTime = 1;

	/**
	 * Пустой конструктор
	 */
	public PaintGraph() {
	}

	@Override
	/**
	 * Выполняет перерисовку панели
	 */
	public void paint(Graphics g) {
		Graphics2D g2 = (Graphics2D) g;
		drawAxis(g2);
		BasicStroke pen1 = new BasicStroke(2);
		g2.setStroke(pen1);
		g2.setColor(Color.CYAN);
		drawLegend(g2);
	}

	/**
	 * Выполняет отрисовку осей
	 */
	protected abstract void drawAxis(Graphics2D g2);

	/**
	 * Выполняет отрисовку легенд
	 */
	protected abstract void drawLegend(Graphics g2);

	{
	}

	/**
	 * Сокращает количество шагов
	 * 
	 * @param divideForRealModelingTime
	 *            сократить во столько раз
	 */
	public void setDivideForRealModelingTime(int divideForRealModelingTime) {
		this.divideForRealModelingTime = divideForRealModelingTime;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\path\paint\PaintGraphCircle.java

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ua.edu.donntu.cs.path.paint;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;

/**
 * Панель для построения графиков (круг)
 * 
 * @author Denis Vodolazskiy
 */
public class PaintGraphCircle extends PaintGraph {

	private int divScaleByX = 1;
	private int multScaleByY = 1;

	/**
	 * Первый конструктор
	 * 
	 * @param xAxisName
	 *            название оси X
	 * @param yAxisName
	 *            название оси Y
	 * @param velX
	 *            значение по оси X
	 * @param velY
	 *            значение по оси Y
	 */
	public PaintGraphCircle(String xAxisName, String yAxisName, float velX[],
			float velY[]) {
		this.xAxisName = xAxisName;
		this.yAxisName = yAxisName;
		this.velX = velX;
		this.velY = velY;
	}

	/**
	 * Второй конструктор
	 * 
	 * @param xAxisName
	 *            название оси X
	 * @param yAxisName
	 *            название оси Y
	 * @param velX
	 *            значение по оси X
	 * @param velY
	 *            значение по оси Y
	 * @param divScaleByX
	 *            делитель по оси X
	 * @param multScaleByY
	 *            множитель по оси Y
	 */
	public PaintGraphCircle(String xAxisName, String yAxisName, float velX[],
			float velY[], int divScaleByX, int multScaleByY) {

		this.xAxisName = xAxisName;
		this.yAxisName = yAxisName;
		this.velX = velX;
		this.velY = velY;
		this.divScaleByX = divScaleByX;
		this.multScaleByY = multScaleByY;
	}

	/**
	 * Третий конструктор
	 * 
	 * @param xAxisName
	 *            название оси X
	 * @param yAxisName
	 *            название оси Y
	 * @param velX
	 *            значение по оси X
	 * @param velY
	 *            значение по оси Y
	 * @param divScaleByX
	 *            делитель по оси X
	 * @param multScaleByY
	 *            множитель по оси Y
	 * @param xMagnitude
	 *            деления по оси X
	 * @param yMagnitude
	 *            деления по оси Y
	 * @param divideForRealModelingTime
	 *            сокращает количество шагов
	 */
	public PaintGraphCircle(String xAxisName, String yAxisName, float velX[],
			float velY[], int divScaleByX, int multScaleByY, int xMagnitude,
			int yMagnitude, int divideForRealModelingTime) {
		this.xAxisName = xAxisName;
		this.yAxisName = yAxisName;
		this.velX = velX;
		this.velY = velY;
		this.divScaleByX = divScaleByX;
		this.multScaleByY = multScaleByY;
		this.xMagnitude = xMagnitude;// X
		this.yMagnitude = yMagnitude;// Y
		this.divideForRealModelingTime = divideForRealModelingTime;
	}

	@Override
	/**
	 * Выполняет отрисовку осей
	 */
	protected void drawAxis(Graphics2D g2) {
		Color c = new Color(187, 187, 187);
		g2.setColor(c);
		g2.fillRect(0, 0, this.getWidth(), this.getHeight());
		//
		g2.setColor(Color.black);
		g2.drawString(xAxisName, this.getWidth() - 20,
				this.getHeight() / 2 + 15);
		g2.drawString(yAxisName, this.getWidth() / 2 + 10, 10);
		if (divScaleByX != 1) {
			g2.drawString("/" + divScaleByX, this.getWidth() - 20,
					this.getHeight() / 2 + 35);
		}
		if (multScaleByY != 1) {
			g2.drawString("*" + multScaleByY, this.getWidth() / 2 + 10, 30);
		}
		//
		g2.setColor(Color.blue);
		g2.drawLine(0, this.getHeight() / 2, this.getWidth(),
				this.getHeight() / 2);
		g2.drawLine(this.getWidth() / 2, this.getHeight(), this.getWidth() / 2,
				0);
		float k = this.getWidth();
		k /= xMagnitude;
		for (int i = 0, x = this.getWidth() / 2; i < xMagnitude / 2 + 1; i++, x = this
				.getWidth() / 2 + (int) (i * k)) {
			g2.drawLine(x, this.getHeight() / 2 + 3, x,
					this.getHeight() / 2 - 3);
			if (i % 10 == 0) {
				g2.drawLine(x, this.getHeight() / 2 + 10, x,
						this.getHeight() / 2 - 10);
			} else if (i % 5 == 0) {
				g2.drawLine(x, this.getHeight() / 2 + 5, x,
						this.getHeight() / 2 - 5);
			}
			if (i % 5 == 0) {
				g2.drawString("" + i, x - 4, this.getHeight() / 2 + 23);
			}
		}
		for (int i = 0, x = this.getWidth() / 2; i < xMagnitude / 2; i++, x = this
				.getWidth() / 2 - (int) (i * k)) {
			g2.drawLine(x, this.getHeight() / 2 + 3, x,
					this.getHeight() / 2 - 3);
			if (i % 10 == 0) {
				g2.drawLine(x, this.getHeight() / 2 + 10, x,
						this.getHeight() / 2 - 10);
			} else if (i % 5 == 0) {
				g2.drawLine(x, this.getHeight() / 2 + 5, x,
						this.getHeight() / 2 - 5);
			}
			if (i % 5 == 0 && i != 0) {// second 0
				g2.drawString("-" + i, x - 4, this.getHeight() / 2 + 23);
			}
		}
		//
		float m = this.getHeight();
		m /= yMagnitude;
		for (int i = 0, x = 0; i < yMagnitude / 2 + 1; i++, x = (int) (i * m)) {
			g2.drawLine(this.getWidth() / 2 + 3, x + this.getHeight() / 2,
					this.getWidth() / 2 - 3, x + this.getHeight() / 2);
			if (i % 10 == 0) {
				g2.drawLine(this.getWidth() / 2 + 10, x + this.getHeight() / 2,
						this.getWidth() / 2 - 10, x + this.getHeight() / 2);
			} else if (i % 5 == 0) {
				g2.drawLine(this.getWidth() / 2 + 5, x + this.getHeight() / 2,
						this.getWidth() / 2 - 5, x + this.getHeight() / 2);
			}
			if (i % 5 == 0 && i != 0) {// second 0
				g2.drawString("-" + i, this.getWidth() / 2 + 27,
						x + this.getHeight() / 2);
			}
		}
		for (int i = 0, x = 0; i < yMagnitude / 2 + 1; i++, x = (int) (i * m)) {
			g2.drawLine(this.getWidth() / 2 + 3, -x + this.getHeight() / 2,
					this.getWidth() / 2 - 3, -x + this.getHeight() / 2);
			if (i % 10 == 0) {
				g2.drawLine(this.getWidth() / 2 + 10,
						-x + this.getHeight() / 2, this.getWidth() / 2 - 10, -x
								+ this.getHeight() / 2);
			} else if (i % 5 == 0) {
				g2.drawLine(this.getWidth() / 2 + 5, -x + this.getHeight() / 2,
						this.getWidth() / 2 - 5, -x + this.getHeight() / 2);
			}
			if (i % 5 == 0) {
				g2.drawString("" + i, this.getWidth() / 2 + 27,
						-x + this.getHeight() / 2);
			}
		}
	}

	@Override
	/**
	 * Выполняет отрисовку легенд
	 */
	protected void drawLegend(Graphics g2) {
		// g2.setColor(Color.CYAN);
		float k = this.getWidth();
		k = (k / xMagnitude);// MODELING_TIME);
		float m = this.getHeight();
		m = (m / yMagnitude);
		assert (velY.length >= xMagnitude);

		for (int i = 1; i < velX.length / divideForRealModelingTime; i++) {
			g2.drawLine((int) (velX[i - 1] * k) / divScaleByX + this.getWidth()
					/ 2, (int) (this.getHeight() / 2 - velY[i - 1] * m
					* multScaleByY),
					(int) (velX[i] * k) / divScaleByX + this.getWidth() / 2,
					(int) (this.getHeight() / 2 - velY[i] * m * multScaleByY));
		}
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\path\paint\PaintGraphCoordCircle.java

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ua.edu.donntu.cs.path.paint;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;

/**
 * Панель для построения графиков (спираль координат)
 * 
 * @author Denis Vodolazskiy
 */
public class PaintGraphCoordCircle extends PaintGraph {

	private int divScaleByX = 1;
	private int multScaleByY = 1;

	/**
	 * Первый конструктор
	 * 
	 * @param xAxisName
	 *            название оси X
	 * @param yAxisName
	 *            название оси Y
	 * @param velX
	 *            значение по оси X
	 * @param velY
	 *            значение по оси Y
	 */
	public PaintGraphCoordCircle(String xAxisName, String yAxisName,
			float velX[], float velY[]) {
		this.xAxisName = xAxisName;
		this.yAxisName = yAxisName;
		this.velX = velX;
		this.velY = velY;
	}

	/**
	 * Второй конструктор
	 * 
	 * @param xAxisName
	 *            название оси X
	 * @param yAxisName
	 *            название оси Y
	 * @param velX
	 *            значение по оси X
	 * @param velY
	 *            значение по оси Y
	 * @param divScaleByX
	 *            делитель по оси X
	 * @param multScaleByY
	 *            множитель по оси Y
	 */
	public PaintGraphCoordCircle(String xAxisName, String yAxisName,
			float velX[], float velY[], int divScaleByX, int multScaleByY) {

		this.xAxisName = xAxisName;
		this.yAxisName = yAxisName;
		this.velX = velX;
		this.velY = velY;
		this.divScaleByX = divScaleByX;
		this.multScaleByY = multScaleByY;
	}

	/**
	 * Третий конструктор
	 * 
	 * @param xAxisName
	 *            название оси X
	 * @param yAxisName
	 *            название оси Y
	 * @param velX
	 *            значение по оси X
	 * @param velY
	 *            значение по оси Y
	 * @param divScaleByX
	 *            делитель по оси X
	 * @param multScaleByY
	 *            множитель по оси Y
	 * @param xMagnitude
	 *            деления по оси X
	 * @param yMagnitude
	 *            деления по оси Y
	 * @param divideForRealModelingTime
	 *            сокращает количество шагов
	 */
	public PaintGraphCoordCircle(String xAxisName, String yAxisName,
			float velX[], float velY[], int divScaleByX, int multScaleByY,
			int xMagnitude, int yMagnitude, int divideForRealModelingTime) {
		this.xAxisName = xAxisName;
		this.yAxisName = yAxisName;
		this.velX = velX;
		this.velY = velY;
		this.divScaleByX = divScaleByX;
		this.multScaleByY = multScaleByY;
		this.xMagnitude = xMagnitude;// X
		this.yMagnitude = yMagnitude;// Y
		this.divideForRealModelingTime = divideForRealModelingTime;
	}

	@Override
	/**
	 * Выполняет отрисовку осей
	 */
	protected void drawAxis(Graphics2D g2) {
		Color c = new Color(187, 187, 187);
		g2.setColor(c);
		g2.fillRect(0, 0, this.getWidth(), this.getHeight());
		//
		g2.setColor(Color.black);
		g2.drawString(xAxisName, this.getWidth() - 20,
				this.getHeight() / 2 + 15);
		g2.drawString(yAxisName, this.getWidth() / 2 + 10, 10);
		if (divScaleByX != 1) {
			g2.drawString("/" + divScaleByX, this.getWidth() - 20,
					this.getHeight() / 2 + 35);
		}
		if (multScaleByY != 1) {
			g2.drawString("*" + multScaleByY, this.getWidth() / 2 + 10, 30);
		}
		//
		g2.setColor(Color.blue);
		g2.drawLine(0, this.getHeight() / 2, this.getWidth(),
				this.getHeight() / 2);
		g2.drawLine(this.getWidth() / 2, this.getHeight(), this.getWidth() / 2,
				0);
		float k = this.getWidth();
		k /= xMagnitude;
		for (int i = 0, x = this.getWidth() / 2; i < xMagnitude / 2 + 1; i++, x = this
				.getWidth() / 2 + (int) (i * k)) {
			if (i % 100 == 0) {
				g2.drawLine(x, this.getHeight() / 2 + 3, x,
						this.getHeight() / 2 - 3);
			}
			if (i % 1000 == 0) {
				g2.drawLine(x, this.getHeight() / 2 + 10, x,
						this.getHeight() / 2 - 10);
			} else if (i % 500 == 0) {
				g2.drawLine(x, this.getHeight() / 2 + 5, x,
						this.getHeight() / 2 - 5);
			}
			if (i % 500 == 0) {
				g2.drawString("" + i, x - 4, this.getHeight() / 2 + 23);
			}
		}
		for (int i = 0, x = this.getWidth() / 2; i < xMagnitude / 2; i++, x = this
				.getWidth() / 2 - (int) (i * k)) {
			if (i % 100 == 0) {
				g2.drawLine(x, this.getHeight() / 2 + 3, x,
						this.getHeight() / 2 - 3);
			}
			if (i % 1000 == 0) {
				g2.drawLine(x, this.getHeight() / 2 + 10, x,
						this.getHeight() / 2 - 10);
			} else if (i % 500 == 0) {
				g2.drawLine(x, this.getHeight() / 2 + 5, x,
						this.getHeight() / 2 - 5);
			}
			if (i % 500 == 0 && i != 0) {// second 0
				g2.drawString("-" + i, x - 4, this.getHeight() / 2 + 23);
			}
		}
		//
		float m = this.getHeight();
		m /= yMagnitude;
		for (int i = 0, x = 0; i < yMagnitude / 2 + 1; i++, x = (int) (i * m)) {
			if (i % 100 == 0) {
				g2.drawLine(this.getWidth() / 2 + 3, x + this.getHeight() / 2,
						this.getWidth() / 2 - 3, x + this.getHeight() / 2);
			}
			if (i % 1000 == 0) {
				g2.drawLine(this.getWidth() / 2 + 10, x + this.getHeight() / 2,
						this.getWidth() / 2 - 10, x + this.getHeight() / 2);
			} else if (i % 500 == 0) {
				g2.drawLine(this.getWidth() / 2 + 5, x + this.getHeight() / 2,
						this.getWidth() / 2 - 5, x + this.getHeight() / 2);
			}
			if (i % 500 == 0 && i != 0) {// second 0
				g2.drawString("-" + i, this.getWidth() / 2 + 27,
						x + this.getHeight() / 2);
			}
		}
		for (int i = 0, x = 0; i < yMagnitude / 2 + 1; i++, x = (int) (i * m)) {
			if (i % 100 == 0) {
				g2.drawLine(this.getWidth() / 2 + 3, -x + this.getHeight() / 2,
						this.getWidth() / 2 - 3, -x + this.getHeight() / 2);
			}
			if (i % 1000 == 0) {
				g2.drawLine(this.getWidth() / 2 + 10,
						-x + this.getHeight() / 2, this.getWidth() / 2 - 10, -x
								+ this.getHeight() / 2);
			} else if (i % 500 == 0) {
				g2.drawLine(this.getWidth() / 2 + 5, -x + this.getHeight() / 2,
						this.getWidth() / 2 - 5, -x + this.getHeight() / 2);
			}
			if (i % 500 == 0) {
				g2.drawString("" + i, this.getWidth() / 2 + 27,
						-x + this.getHeight() / 2);
			}
		}
	}

	@Override
	/**
	 * Выполняет отрисовку легенд
	 */
	protected void drawLegend(Graphics g2) {
		// g2.setColor(Color.CYAN);
		float k = this.getWidth();
		k = (k / xMagnitude);// MODELING_TIME);
		float m = this.getHeight();
		m = (m / yMagnitude);
		assert (velY.length >= xMagnitude);

		float previousX = velX[0];
		float previousY = velY[0];
		float nextX = velX[1];
		float nextY = velY[1];
		for (int i = 1; i < velX.length / divideForRealModelingTime; i++) {
			nextX = previousX + velX[i];
			nextY = previousY + velY[i];
			g2.drawLine((int) (previousX * k) / divScaleByX + this.getWidth()
					/ 2, (int) (this.getHeight() / 2 - previousY * m
					* multScaleByY),
					(int) (nextX * k) / divScaleByX + this.getWidth() / 2,
					(int) (this.getHeight() / 2 - nextY * m * multScaleByY));
			previousX = nextX;
			previousY = nextY;
		}
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\path\paint\PaintGraphLine.java

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ua.edu.donntu.cs.path.paint;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;

/**
 * Панель для построения графиков (линия)
 * 
 * @author Denis Vodolazskiy
 */
public class PaintGraphLine extends PaintGraph {

	private int multScaleByY = 1;

	/**
	 * Первый конструктор
	 * 
	 * @param xAxisName
	 *            название оси X
	 * @param yAxisName
	 *            название оси Y
	 * @param velY
	 *            значение по оси Y
	 */
	public PaintGraphLine(String xAxisName, String yAxisName, float velY[]) {
		this.xAxisName = xAxisName;
		this.yAxisName = yAxisName;
		this.velY = velY;
	}

	/**
	 * Второй конструктор
	 * 
	 * @param xAxisName
	 *            название оси X
	 * @param yAxisName
	 *            название оси Y
	 * @param velY
	 *            значение по оси Y
	 * @param multScaleByY
	 *            множитель по оси Y
	 */
	public PaintGraphLine(String xAxisName, String yAxisName, float velY[],
			int multScaleByY) {
		this.xAxisName = xAxisName;
		this.yAxisName = yAxisName;
		this.velY = velY;
		this.multScaleByY = multScaleByY;
	}

	@Override
	/**
	 * Выполняет отрисовку осей
	 */
	protected void drawAxis(Graphics2D g2) {
		Color c = new Color(187, 187, 187);
		g2.setColor(c);
		g2.fillRect(0, 0, this.getWidth(), this.getHeight());
		//
		g2.setColor(Color.black);
		g2.drawString(xAxisName, this.getWidth() - 10,
				this.getHeight() / 2 + 15);
		g2.drawString(yAxisName, 10, 10);
		if (multScaleByY != 1) {
			g2.drawString("* " + multScaleByY, 10, 25);
		}
		//
		g2.setColor(Color.blue);
		g2.drawLine(0, this.getHeight() / 2, this.getWidth(),
				this.getHeight() / 2);
		g2.drawLine(0, this.getHeight(), 0, 0);
		float k = this.getWidth();
		k /= xMagnitude;
		for (int i = 0, x = 0; i < xMagnitude + 1; i++, x = (int) (i * k)) {
			if (i % 100 == 0) {
				g2.drawLine(x, this.getHeight() / 2 + 3, x,
						this.getHeight() / 2 - 3);
			}
			if (i % 1000 == 0) {
				g2.drawLine(x, this.getHeight() / 2 + 10, x,
						this.getHeight() / 2 - 10);
			} else if (i % 500 == 0) {
				g2.drawLine(x, this.getHeight() / 2 + 5, x,
						this.getHeight() / 2 - 5);
			}
			if (i % 500 == 0) {
				g2.drawString("" + i, x - 4, this.getHeight() / 2 + 23);
			}
		}
		//
		float m = this.getHeight();
		m /= yMagnitude;
		for (int i = 0, x = 0; i < yMagnitude / 2 + 1; i++, x = (int) (i * m)) {
			g2.drawLine(3, x + this.getHeight() / 2, -3, x + this.getHeight()
					/ 2);
			if (i % 10 == 0) {
				g2.drawLine(10, x + this.getHeight() / 2, -10,
						x + this.getHeight() / 2);
			} else if (i % 5 == 0) {
				g2.drawLine(5, x + this.getHeight() / 2, -5,
						x + this.getHeight() / 2);
			}
			if (i % 5 == 0 && i != 0) {// second 0
				g2.drawString("-" + i, 27, x + this.getHeight() / 2);
			}
		}
		for (int i = 0, x = 0; i < yMagnitude / 2 + 1; i++, x = (int) (i * m)) {
			g2.drawLine(3, -x + this.getHeight() / 2, -3, -x + this.getHeight()
					/ 2);
			if (i % 10 == 0) {
				g2.drawLine(10, -x + this.getHeight() / 2, -10,
						-x + this.getHeight() / 2);
			} else if (i % 5 == 0) {
				g2.drawLine(+5, -x + this.getHeight() / 2, -5,
						-x + this.getHeight() / 2);
			}
			if (i % 5 == 0) {
				g2.drawString("" + i, 27, -x + this.getHeight() / 2);
			}
		}
	}

	@Override
	/**
	 * Выполняет отрисовку легенд
	 */
	protected void drawLegend(Graphics g2) {
		// g2.setColor(Color.CYAN);
		float k = this.getWidth();
		k = (k / xMagnitude);
		float m = this.getHeight();
		m = (m / yMagnitude);
		//
		assert (velY.length >= xMagnitude);

		for (int i = 1; i < xMagnitude; i++) {
			g2.drawLine((int) (k * (i - 1)),
					(int) (this.getHeight() / 2 - velY[i - 1] * m
							* multScaleByY), (int) (k * i),
					(int) (this.getHeight() / 2 - velY[i] * m * multScaleByY));
		}
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\priority_method\draw\ManyShipsMove.java

/*This class allows to move group of ships*/
package ua.edu.donntu.cs.priority_method.draw;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.ArrayList;

import javax.swing.Timer;

import ua.edu.donntu.cs.draw.information.InfoPrint;
import ua.edu.donntu.cs.draw.main.DrawShip;
import ua.edu.donntu.cs.draw.matrix_transform.MatrixTransform;
import ua.edu.donntu.cs.inout.IPrepareData;
import ua.edu.donntu.cs.key_manager.Craft;
import ua.edu.donntu.cs.priority_method.service.Left;
import ua.edu.donntu.cs.priority_method.service.Right;
import ua.edu.donntu.cs.priority_method.service.Ship;

/**
 * Панель для построения 9-ти объектов с помощью CPU. Используется метод
 * приоритетов
 *
 * @author Denis Vodolazskiy
 */
public class ManyShipsMove extends DrawShip implements IPrepareData,
        ActionListener {

    private static final long serialVersionUID = 1L;
    private ArrayList<Ship> ships;
    private ArrayList<Ship> sortedShips;
    private Timer timer;
    private Craft craft;

    /**
     * Конструктор, активирует слушателя и менеджера клавиатуры. Запускает
     * таймер.
     */
    public ManyShipsMove() {
        addKeyListener(new TAdapter());
        setFocusable(true);
        setBackground(Color.BLACK);
        // Color cFill = new Color(20, 80, 255);
        // setBackground(cFill);
        setDoubleBuffered(true);
        initShips();
        // sortShips();
        // init key_manager
        craft = new Craft(psi, teta, gamma, distanceX, distanceY, distanceZ);
        // init delay between key events
        timer = new Timer(5, this);
        timer.start();
    }

    // add displacement by axes X, Z
    /**
     * Задаёт смещение кораблей относительно центрального корабля
     *
     * @param a смещение по X
     * @param b смещение по Y
     * @return новый массив точек
     */
    protected int[][] initPoints(int a, int b) {
        int myPoints[][] = new int[Q_POINTS][3];
        for (int i = 0; i < Q_POINTS; i++) {
            myPoints[i][0] = points[i][0] + a;
            myPoints[i][1] = points[i][1];
            myPoints[i][2] = points[i][2] + b;
        }
        return myPoints;
    }

    // set position and color of every ship
    /**
     * Инициализация кораблей. Задаётся расположение и цвет
     */
    protected void initShips() {
        ships = new ArrayList<Ship>();

        ships.add(new Ship(initPoints(0, 0), polygons, normals, new Color(255,
                255, 255)));// initPoints(0,0)
        ships.add(new Ship(initPoints(0, 150000), polygons, normals, new Color(
                255, 255, 0)));
        ships.add(new Ship(initPoints(0, -150000), polygons, normals, new Color(
                255, 0, 255)));
        ships.add(new Ship(initPoints(150000, 0), polygons, normals, new Color(
                0, 255, 255)));
        ships.add(new Ship(initPoints(-150000, 0), polygons, normals, new Color(
                0, 0, 255)));
        ships.add(new Ship(initPoints(150000, 150000), polygons, normals,
                new Color(255, 0, 0)));
        ships.add(new Ship(initPoints(-150000, 150000), polygons, normals,
                new Color(255, 127, 127)));
        ships.add(new Ship(initPoints(-150000, -150000), polygons, normals,
                new Color(127, 255, 127)));
        ships.add(new Ship(initPoints(150000, -150000), polygons, normals,
                new Color(127, 127, 255)));
    }

    // sort ships according to tree
    /**
     * Сортировка кораблей в соответствии с методом приоритетов
     */
    protected void sortShips() {
        //
        double matrixA[][] = new double[3][3];
        MatrixTransform mt = new MatrixTransform();
        matrixA = mt.matr(psi, teta, gamma, 2);
        double matrixB[][] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};

        // matrix D
        double matrixD[][] = new double[3][3];
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                matrixD[i][j] = matrixA[i][0] * matrixB[j][0] + matrixA[i][1]
                        * matrixB[j][1] + matrixA[i][2] * matrixB[j][2];
            }
        }
        //
        int node = 0;
        int pow = 3;
        int Vx, Vy, Vz;

        // lists of ships to draw (order)
        int list[][] = {{7, 4, 6, 2, 0, 1, 8, 3, 5},
            {6, 7, 4, 1, 2, 0, 5, 8, 3}, {6, 4, 7, 1, 0, 2, 5, 3, 8},
            {8, 7, 2, 3, 4, 0, 5, 6, 1}, {5, 1, 6, 8, 7, 2, 3, 4, 0},
            // { 5, 8, 3, 1, 2, 0, 6, 7, 4 },
            {5, 6, 1, 3, 4, 0, 8, 7, 2}, {8, 3, 5, 2, 0, 1, 7, 4, 6},
            {5, 8, 3, 1, 2, 0, 6, 7, 4}, {5, 3, 8, 1, 0, 2, 6, 4, 7}};
        Left left;
        Right right;

        // coordinates of control points
        int p[][] = {{0, 0, -10000}, {0, 0, 10000}, {10000, 0, 0},
            {-10000, 0, 0}};

        // normals for each point
        int N[][] = {{0, 0, -1}, {0, 0, 1}, {1, 0, 0}, {-1, 0, 0}};

        int observer[] = new int[3];// = { distanceX, distanceY, distanceZ };
        observer[0] = (int) (distanceX * matrixD[0][0] + distanceY
                * matrixD[0][1] + distanceZ * matrixD[0][2]);
        observer[1] = (int) (distanceX * matrixD[1][0] + distanceY
                * matrixD[1][1] + distanceZ * matrixD[1][2]);
        observer[2] = (int) (distanceX * matrixD[2][0] + distanceY
                * matrixD[2][1] + distanceZ * matrixD[2][2]);

        // number of nodes for each node
        int relationsOfNodes[] = {2, 1, 3, 1, 1, 0, 0, 0};

        // numbers and powers of left nodes
        int lNum[] = {1, 0, 3, 3, 6, 1, 7, 4};
        int lPow[] = {2, 0, 2, 0, 0, 0, 0, 0};
        left = new Left(lNum, lPow);

        // numbers and powers of right nodes
        int rNum[] = {2, 5, 4, 7, 6, 2, 8, 5};
        int rPow[] = {3, 1, 2, 1, 1, 0, 0, 0};
        right = new Right(rNum, rPow);
        // System.out.println("observer[0]= "+observer[0]);
        // System.out.println("observer[2]= "+observer[2]);

        // algorithm for searching list
        while (pow != 0) {
            Vx = p[relationsOfNodes[node]][0] - observer[0];
            Vy = p[relationsOfNodes[node]][1] - observer[1];
            Vz = p[relationsOfNodes[node]][2] - observer[2];
            int S = Vx * N[relationsOfNodes[node]][0] + Vy
                    * N[relationsOfNodes[node]][1] + Vz
                    * N[relationsOfNodes[node]][2];
            if (S < 0) {
                pow = left.getPowI(node);
                node = left.getNumI(node);
            } else {
                pow = right.getPowI(node);
                node = right.getNumI(node);
            }
            // System.out.println("node= "+node);
            // System.out.println("pow= "+pow);
        }
        int listShips[] = list[node];
        sortedShips = new ArrayList<Ship>();

        for (int i = 0; i < listShips.length; i++) {
            sortedShips.add(ships.get(listShips[i]));
            // System.out.println("listShips[i]= "+listShips[i]);
        }
    }

    /**
     * Выполняет перерисовку экрана. Корабли берутся последовательно из
     * отсортированного списка
     */
    public void paint(Graphics g) {
        super.paint(g);

        Graphics2D g2 = (Graphics2D) g;
        // setAntialiasing(g2);
        psi = craft.getPsi();
        teta = craft.getTeta();
        gamma = craft.getGamma();
        distanceX = craft.getDistX();
        distanceY = craft.getDistY();
        distanceZ = craft.getDistZ();
        //
        // calc(points, polygons, normals);
        // makeAllPolygons(g2);
        sortShips();
        int pr = 1;
        for (int i = 0; i < sortedShips.size(); i++) {
            // for (int i = 0; i < 3; i++) {
            calc(sortedShips.get(i).getPoints(), sortedShips.get(i)
                    .getPolygons(), sortedShips.get(i).getNormals(), pr);
            makeAllPolygons(g2, sortedShips.get(i).getColor());
        }

        // draw information
        new InfoPrint(g2, craft);
        Toolkit.getDefaultToolkit().sync();
        g.dispose();
    }

    @Override
    public void actionPerformed(ActionEvent arg0) {
        // TODO Auto-generated method stub
        craft.move();
        repaint();

    }

    /**
     * Обрабатывает нажатие клавиш
     *
     * @author Denis Vodolazskiy
     *
     */
    private class TAdapter extends KeyAdapter {

        public void keyReleased(KeyEvent e) {
            craft.keyReleased(e);
        }

        public void keyPressed(KeyEvent e) {
            craft.keyPressed(e);
        }
    }
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\priority_method\service\Left.java

package ua.edu.donntu.cs.priority_method.service;

/**
 * Левая ветка метода приоритетов
 * 
 * @author Denis Vodolazskiy
 * 
 */
public class Left {
	private int pow[];
	private int num[];

	public Left(int num[], int pow[]) {
		this.pow = pow;
		this.num = num;
	}

	public int getPowI(int i) {
		return pow[i];
	}

	public int getNumI(int i) {
		return num[i];
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\priority_method\service\Right.java

package ua.edu.donntu.cs.priority_method.service;

/**
 * Правая ветка метода приоритетов
 * 
 * @author Denis Vodolazskiy
 * 
 */
public class Right {
	private int pow[];
	private int num[];

	public Right(int num[], int pow[]) {
		this.pow = pow;
		this.num = num;
	}

	public int getPowI(int i) {
		return pow[i];
	}

	public int getNumI(int i) {
		return num[i];
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\priority_method\service\Ship.java

package ua.edu.donntu.cs.priority_method.service;

import java.awt.Color;

import ua.edu.donntu.cs.inout.IPrepareData;

/**
 * Корабль, его форма, положение, цвет
 * 
 * @author Denis Vodolazskiy
 */
public class Ship implements IPrepareData {
	private int pointsShip[][] = new int[Q_POINTS][3];
	private int polygonsShip[][] = new int[Q_POLYGONS][3];
	private int normalsShip[][] = new int[Q_POLYGONS][3];
	private Color colorShip;

	/**
	 * Конструктор создания объекта "Корабль"
	 * 
	 * @param points
	 *            точки
	 * @param polygons
	 *            треугольники
	 * @param normals
	 *            нормали к треугольникам
	 * @param color
	 *            цвет корабля
	 */
	public Ship(int[][] points, int[][] polygons, int[][] normals, Color color) {
		this.pointsShip = points;
		this.polygonsShip = polygons;
		this.normalsShip = normals;
		this.colorShip = color;
	}

	/**
	 * Взять точки
	 * 
	 * @return точки
	 */
	public int[][] getPoints() {
		return pointsShip;
	}

	/**
	 * Установить точки
	 * 
	 * @param points
	 *            точки
	 */

	public void setPoints(int[][] points) {
		this.pointsShip = points;
	}

	/**
	 * Взять треугольники
	 * 
	 * @return треугольники
	 */
	public int[][] getPolygons() {
		return polygonsShip;
	}

	/**
	 * Установить треугольники
	 * 
	 * @param polygons
	 *            треугольники
	 */
	public void setPolygons(int[][] polygons) {
		this.polygonsShip = polygons;
	}

	/**
	 * Взять нормали
	 * 
	 * @return нормали
	 */
	public int[][] getNormals() {
		return normalsShip;
	}

	/**
	 * Установить нормали
	 * 
	 * @param normals
	 *            нормали
	 */
	public void setNormals(int[][] normals) {
		this.normalsShip = normals;
	}

	/**
	 * Взять цвет корабля
	 * 
	 * @return цвет корабля
	 */
	public Color getColor() {
		return colorShip;
	}

	/**
	 * Установить цвет корабля
	 * 
	 * @param color
	 *            цвет корабля
	 */
	public void setColor(Color color) {
		this.colorShip = color;
	}

}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\ray\base_draw\BaseDrawRay.java

package ua.edu.donntu.cs.ray.base_draw;

import javax.swing.JPanel;

import ua.edu.donntu.cs.service.transform_pixels_meters.MetMmTransform;
/**
 * Этот класс задаёт основные данные для метода трассировки лучей.
 * Задаются параметры окна
 * 
 * @author Denis Vodolazskiy
 */
public class BaseDrawRay extends JPanel implements IRayFigure {
	protected float psi = 0;// -30;
	protected float teta = 0;// 30;
	protected float gamma = 0;
	protected int pr = 1;
	protected int distanceX = new MetMmTransform().meter2mm(-10);// meters
	protected int distanceY = 0;
	protected int distanceZ = 0;
	// 2 Initializing the following values:- a0,b0,d0,Nx,Ny,hx,hy
	/**
	 * Количество пикселов по Х
	 */			
	protected final int Nx = 700;// pixcels in window (X)
	/**
	 * Количество пикселов по Y
	 */	
	protected final int Ny = 700;// pixcels in window (Y)
	/**
	 * Размер окна по Х
	 */	
	protected final float a0 = 1;// размер окна по икс
	/**
	 * Размер окна по Y
	 */	
	protected final float b0 = 1;// размер окна по игрик
	/**
	 * Расстояние до окна
	 */	
	protected final float d0 = 0.6f;// расстояние до окна
	/**
	 * Размер пиксела по Х
	 */	
	protected final float hx = a0 / Nx;
	/**
	 * Размер пиксела по Y
	 */
	protected final float hy = b0 / Ny;
	// Initialization of arrays
	/**
	 * Общее количество пикселов
	 */
	protected final int N = Nx * Ny;
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\ray\base_draw\IRayFigure.java

package ua.edu.donntu.cs.ray.base_draw;

import ua.edu.donntu.cs.cuda.service.TransformArray;
import ua.edu.donntu.cs.inout.LoadData;

/**
 * Этот класс задаёт основные данные для метода трассировки лучей.
 * Точки и полигоны берутся из файлов для куба.
 * 
 * @author Denis Vodolazskiy
 */
public interface IRayFigure {
	
	public final LoadData data = new LoadData();// для остальных классов путь
	/**
	 * Точки куба
	 */										// задан в их коде
	public final int points[][] = data
			.loadPoints("data/inputfiles/pointsKub.txt");
			//.loadPoints("data/inputfiles/points2.txt");
	/**
	 * Полигоны куба
	 */	
	public final int polygons[][] = data
			.loadPolygons("data/inputfiles/pointsAndPolygonsKub.txt");
			//.loadPolygons("data/inputfiles/pointsAndPolygons2.txt");
	/**
	 * Нормали куба
	 */	
	public final int normals[][] = data.loadNormals(points, polygons);

	// set Q_POINTS and Q_POLYGONS
	/**
	 * Количество точек
	 */	
	public final int Q_POINTS = data.getCountPoints();
	/**
	 * Количество полигонов
	 */	
	public final int Q_POLYGONS = data.getCountPolygons();

	/**
	 * Точки куба (CUDA)
	 */	
	public final int pointsBaseCuda[] = new TransformArray().in1D(points,
			Q_POINTS);
	/**
	 * Полигоны куба (CUDA)
	 */	
	public final int polygonsCuda[] = new TransformArray().in1D(polygons,
			Q_POLYGONS);
	/**
	 * Нормали куба (CUDA)
	 */	
	public final int normalsCuda[] = new TransformArray().in1D(normals,
			Q_POLYGONS);
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\ray\compare_graphic\CPUandGPUCompareRayFrame.java

package ua.edu.donntu.cs.ray.compare_graphic;

import java.awt.Dimension;
import java.awt.Toolkit;

import javax.swing.JFrame;
import javax.swing.UIManager;

import ua.edu.donntu.cs.cuda.exception.InitCuda;
import ua.edu.donntu.cs.inout.LoadTimeValues;
import ua.edu.donntu.cs.inout.QuantityOfStringsInFile;
import ua.edu.donntu.cs.inout.WriteToFile;
import ua.edu.donntu.cs.ray.base_draw.IRayFigure;
import ua.edu.donntu.cs.ray.ray_calc.ParallelRay;
import ua.edu.donntu.cs.ray.ray_calc_time.SerialRayTime;

/**
 * Этот класс создаёт окно для графиков зависимости времени выполнения от
 * количества пикселов в окне. Метод трассировки лучей
 * 
 * @author Denis Vodolazskiy
 */
public class CPUandGPUCompareRayFrame extends JFrame implements IRayFigure {
	/**
	 * Панель для размещения компонентов
	 */
	private PaintCompareRay panel;

	/**
	 * Конструктор, задаёт расположение окна и его свойства. Принимает данные,
	 * проверяет, являются ли данные новыми. Если да, то заново рассчитывает
	 * время выполнения и записывает результат в текстовый файл. Если нет, то
	 * читает данные из текстового файла. Затем строит график. Перед выполнением
	 * рассчётов проверяет наличие видеокарты
	 */
	public CPUandGPUCompareRayFrame() {
		super("Метод трассировки лучей на CPU и GPU:");
		// System Look-And-Feel:
		try {
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (Exception e) {
			// Exception handle
		}
		int Nx = 700;
		int increment = 1;

		float timesGPU[] = new float[Nx + 1];
		float timesCPU[] = new float[Nx + 1];
		final String nameGPU = "timesRayGPU.txt";
		final String nameCPU = "timesRayCPU.txt";

		int stringQuantatyGPU = 0;
		stringQuantatyGPU = new QuantityOfStringsInFile()
				.quantityOfStringsTime(nameGPU);
		int stringQuantatyCPU = 0;
		stringQuantatyCPU = new QuantityOfStringsInFile()
				.quantityOfStringsTime(nameCPU);

		if ((stringQuantatyGPU == Nx + 1) && (stringQuantatyCPU == Nx + 1)) {
			timesGPU = new LoadTimeValues().loadTimes(nameGPU);
			timesCPU = new LoadTimeValues().loadTimes(nameCPU);
		} else {
			if (new InitCuda().isPresent()) {// check GPU
				for (int i = 1; i < Nx + 1; i += increment) {
					timesGPU[i] = new ParallelRay(pointsBaseCuda, polygonsCuda,
							normalsCuda, i, i).getEl_time();
					timesCPU[i] = new SerialRayTime(points, polygons, normals,
							i, i).getTimeout();
				}
				new WriteToFile(timesGPU, nameGPU);
				new WriteToFile(timesCPU, nameCPU);
			}
		}

		panel = new PaintCompareRay("pixels", "time, ms", timesGPU, timesCPU,
				1, 1, increment);
		panel.setLayout(null);
		setSize(700, 500); // задание размеров
		setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); // задание параметров
															// // главного окна
															// при закрытии

		Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();
		int width = getSize().width;
		int height = getSize().height;
		int x = (dim.width - width) / 2;
		int y = (dim.height - height) / 2;
		setLocation(x, y);

		//
		setResizable(false);
		setVisible(true);
		setContentPane(panel);
	}

}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\ray\compare_graphic\PaintCompareRay.java

package ua.edu.donntu.cs.ray.compare_graphic;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;

import javax.swing.JPanel;

/**
 * Этот класс выполнет построение графиков зависимости времени выполнения от
 * количества пикселов в окне. Метод трассировки лучей
 * 
 * @author Denis Vodolazskiy
 */
public class PaintCompareRay extends JPanel {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private int divScaleByX = 1;
	private int divScaleByY = 1;
	private int xMagnitude = 1;
	private int yMagnitude = 1000;// 200000
	// private float valX[];
	private float valY[];
	private float valY2[];
	private String xAxisName = "";
	private String yAxisName = "";
	// private int divideForRealModelingTime = 1;
	private Color c1 = new Color(0).CYAN;
	private Color c2 = new Color(0).RED;
	private int increment = 1;

	/**
	 * Конструктор, принимает параметры
	 * 
	 * @param xAxisName
	 *            подпись по оси X
	 * @param yAxisName
	 *            подпись по оси Y
	 * @param valY
	 *            массив значений первой легенды (GPU)
	 * @param valY2
	 *            массив значений первой легенды (CPU)
	 * @param divScaleByX
	 *            делитель значений по оси X
	 * @param divScaleByY
	 *            делитель значений по оси Y
	 * @param increment
	 *            шаг по Y
	 */
	public PaintCompareRay(String xAxisName, String yAxisName, float valY[],
			float valY2[], int divScaleByX, int divScaleByY, int increment) {
		this.xAxisName = xAxisName;
		this.yAxisName = yAxisName;
		this.valY = valY;
		this.valY2 = valY2;
		this.divScaleByX = divScaleByX;
		this.divScaleByY = divScaleByY;
		xMagnitude = valY.length;
		this.increment = increment;
	}

	/**
	 * Выполняет перерисовку окна
	 */
	public void paint(Graphics g) {
		Graphics2D g2 = (Graphics2D) g;
		drawAxis(g2);
		BasicStroke pen1 = new BasicStroke(2);
		g2.setStroke(pen1);
		// g2.setColor(Color.CYAN);
		drawLegend(g2);
	}

	/**
	 * Выполняет отрисовку осей
	 */
	private void drawAxis(Graphics2D g2) {
		Color c = new Color(187, 187, 187);
		g2.setColor(c);
		g2.fillRect(0, 0, this.getWidth(), this.getHeight());
		//
		g2.setColor(c1);
		g2.drawString("GPU", this.getWidth() - 80, this.getHeight() / 2 + 60);
		g2.setColor(c2);
		g2.drawString("CPU", this.getWidth() - 40, this.getHeight() / 2 + 60);
		//
		g2.setColor(Color.black);
		g2.drawString(xAxisName, this.getWidth() - 40,
				this.getHeight() / 2 + 40);
		g2.drawString(yAxisName, 60, 10);
		if (divScaleByY != 1) {
			g2.drawString("* " + divScaleByY, 60, 25);
		}
		if (divScaleByX != 1) {
			g2.drawString("/" + divScaleByX, this.getWidth() - 20,
					this.getHeight() / 2 - 35);
		}
		//
		g2.setColor(Color.blue);
		g2.drawLine(0, this.getHeight() / 2, this.getWidth(),
				this.getHeight() / 2);
		g2.drawLine(0, this.getHeight(), 0, 0);
		float k = this.getWidth();
		k /= xMagnitude;
		for (int i = 0, x = 0; i < xMagnitude + 1; i++, x = (int) (i * k)) {
			if (i % 10 == 0) {// 1
				g2.drawLine(x, this.getHeight() / 2 + 3, x,
						this.getHeight() / 2 - 3);
			}
			if (i % 100 == 0) {// 10
				g2.drawLine(x, this.getHeight() / 2 + 10, x,
						this.getHeight() / 2 - 10);
			} else if (i % 50 == 0) {
				g2.drawLine(x, this.getHeight() / 2 + 5, x,
						this.getHeight() / 2 - 5);
			}
			if (i % 50 == 0) {// 5
				g2.drawString("" + i, x - 4, this.getHeight() / 2 + 23);
			}
		}
		//
		float m = this.getHeight();
		m /= yMagnitude;
		for (int i = 0, x = 0; i < yMagnitude / 2 + 1; i++, x = (int) (i * m)) {
			// g2.drawLine(3, x + this.getHeight() / 2, - 3, x +
			// this.getHeight() / 2);
			if (i % 100 == 0) {
				g2.drawLine(10, x + this.getHeight() / 2, -10,
						x + this.getHeight() / 2);
			} else if (i % 20 == 0) {
				g2.drawLine(5, x + this.getHeight() / 2, -5,
						x + this.getHeight() / 2);
			}
			if (i % 100 == 0 && i != 0) {// second 0
				g2.drawString("-" + i, 27, x + this.getHeight() / 2);
			}
		}
		for (int i = 0, x = 0; i < yMagnitude / 2 + 1; i++, x = (int) (i * m)) {
			// g2.drawLine(3, -x + this.getHeight() / 2, - 3, -x +
			// this.getHeight() / 2);
			if (i % 100 == 0) {// 5000
				g2.drawLine(10, -x + this.getHeight() / 2, -10,
						-x + this.getHeight() / 2);
			} else if (i % 20 == 0) {// 1000
				g2.drawLine(+5, -x + this.getHeight() / 2, -5,
						-x + this.getHeight() / 2);
			}
			if (i % 100 == 0) {// 50000
				g2.drawString("" + i, 27, -x + this.getHeight() / 2);
			}
		}
	}

	/**
	 * Выполняет отрисовку легенд
	 */
	private void drawLegend(Graphics g2) {

		float k = this.getWidth();
		k = (k / xMagnitude);
		float displ = 0;
		float m = this.getHeight();
		m = (m / yMagnitude);
		//
		// assert (valY.length >= xMagnitude);

		for (int i = 1 + increment; i < xMagnitude; i += increment) {
			g2.setColor(c1);
			g2.drawLine((int) (displ + k * (i - increment) / divScaleByX),
					(int) (this.getHeight() / 2 - valY[i - increment] * m
							/ divScaleByY),
					(int) (displ + k * i / divScaleByX),
					(int) (this.getHeight() / 2 - valY[i] * m / divScaleByY));
			g2.setColor(c2);
			g2.drawLine((int) (displ + k * (i - increment) / divScaleByX),
					(int) (this.getHeight() / 2 - valY2[i - increment] * m
							/ divScaleByY),
					(int) (displ + k * i / divScaleByX),
					(int) (this.getHeight() / 2 - valY2[i] * m / divScaleByY));
		}
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\ray\draw_ray\DrawRay.java

package ua.edu.donntu.cs.ray.draw_ray;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;

import javax.swing.Timer;

import ua.edu.donntu.cs.draw.information.InfoPrint;
import ua.edu.donntu.cs.ray.ray_calc.Ray;
import ua.edu.donntu.cs.ray.ray_key_manager.CraftFast;
import ua.edu.donntu.cs.service.transform_pixels_meters.MetMmTransform;


/**
 * Этот класс выполняет отрисовку объекта с помощью метода трассировки лучей на
 * CPU
 * 
 * @author Denis Vodolazskiy
 */
public class DrawRay extends Ray implements ActionListener {

	private static final long serialVersionUID = 1L;
	//
	private Timer timer;
	private CraftFast craft;

	/**
	 * Конструктор для отрисовки объекта с помощью метода трассировки лучей на
	 * CPU
	 * 
	 */
	public DrawRay() {
		// decrease default distance
		final int distX = new MetMmTransform().meter2mm(-10);
		// System.out.print(distX);
		addKeyListener(new DrawRay.TAdapter());
		setFocusable(true);
		setBackground(Color.BLACK);
		setDoubleBuffered(true);
		// init key_manager
		// psi=180;
		craft = new CraftFast(psi, teta, gamma, distX, distanceY, distanceZ);
		// init delay between key events
		timer = new Timer(5, this);
		timer.start();
	}

	@Override
	public void actionPerformed(ActionEvent e) {
		craft.move();
		repaint();
	}

	/**
	 * Выполняет перерисовку экрана
	 */
	@Override
	public void paint(Graphics g) {
		super.paint(g);

		Graphics2D g2 = (Graphics2D) g;
		// setAntialiasing(g2);
		psi = craft.getPsi();
		teta = craft.getTeta();
		gamma = craft.getGamma();
		distanceX = craft.getDistX();
		distanceY = craft.getDistY();
		distanceZ = craft.getDistZ();
		// make calculations
		// calc(g2,points, polygons, normals);
		calc(g2, points, polygons, normals);
		// draw information
		new InfoPrint(g2, craft);
		Toolkit.getDefaultToolkit().sync();
		g.dispose();
	}

	// key adapter
	/**
	 * Обрабатывает нажатие клавиш
	 * 
	 * @author Denis Vodolazskiy
	 * 
	 */
	private class TAdapter extends KeyAdapter {

		@Override
		public void keyReleased(KeyEvent e) {
			craft.keyReleased(e);
		}

		@Override
		public void keyPressed(KeyEvent e) {
			craft.keyPressed(e);
		}
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\ray\draw_ray\DrawRayCuda.java

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ua.edu.donntu.cs.ray.draw_ray;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;

import javax.swing.Timer;

import ua.edu.donntu.cs.draw.information.InfoPrint;
import ua.edu.donntu.cs.ray.ray_calc.ParallelRay;
import ua.edu.donntu.cs.ray.ray_key_manager.CraftFast;
import ua.edu.donntu.cs.service.transform_pixels_meters.MetMmTransform;

/**
 * Этот класс выполняет отрисовку объекта с помощью метода трассировки лучей на
 * GPU
 * 
 * @author Denis Vodolazskiy
 */
public class DrawRayCuda extends ParallelRay implements ActionListener {

	private static final long serialVersionUID = 1L;
	//
	private Timer timer;
	private CraftFast craft;

	/**
	 * Конструктор для отрисовки объекта с помощью метода трассировки лучей на
	 * GPU
	 * 
	 */
	public DrawRayCuda() {
		// decrease default distance
		final int distX = new MetMmTransform().meter2mm(-10);
		// System.out.print(distX);
		addKeyListener(new DrawRayCuda.TAdapter());
		setFocusable(true);
		setBackground(Color.BLACK);
		setDoubleBuffered(true);
		// init key_manager
		// psi=180;
		craft = new CraftFast(psi, teta, gamma, distX, distanceY, distanceZ);
		// init delay between key events
		timer = new Timer(5, this);
		timer.start();
	}

	@Override
	public void actionPerformed(ActionEvent e) {
		craft.move();
		repaint();
	}

	/**
	 * Выполняет перерисовку экрана
	 */
	@Override
	public void paint(Graphics g) {
		super.paint(g);

		Graphics2D g2 = (Graphics2D) g;
		// setAntialiasing(g2);
		psi = craft.getPsi();
		teta = craft.getTeta();
		gamma = craft.getGamma();
		distanceX = craft.getDistX();
		distanceY = craft.getDistY();
		distanceZ = craft.getDistZ();
		// make calculations
		// calc(g2,points, polygons, normals);
		calc(g2, pointsBaseCuda, polygonsCuda, normalsCuda);
		// draw information
		new InfoPrint(g2, craft);
		Toolkit.getDefaultToolkit().sync();
		g.dispose();
	}

	// key adapter
	/**
	 * Обрабатывает нажатие клавиш
	 * 
	 * @author Denis Vodolazskiy
	 * 
	 */
	private class TAdapter extends KeyAdapter {

		@Override
		public void keyReleased(KeyEvent e) {
			craft.keyReleased(e);
		}

		@Override
		public void keyPressed(KeyEvent e) {
			craft.keyPressed(e);
		}
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\ray\ray_calc\ParallelRay.java

package ua.edu.donntu.cs.ray.ray_calc;

import static jcuda.runtime.JCuda.cudaFree;
import static jcuda.runtime.JCuda.cudaMalloc;
import static jcuda.runtime.JCuda.cudaMemcpy;
import static jcuda.runtime.cudaMemcpyKind.cudaMemcpyDeviceToHost;
import static jcuda.runtime.cudaMemcpyKind.cudaMemcpyHostToDevice;

import java.awt.Color;
import java.awt.Graphics2D;

import jcuda.Pointer;
import jcuda.Sizeof;
import jcuda.runtime.cudaStream_t;
import jcuda.utils.KernelLauncher;
import ua.edu.donntu.cs.cuda.service.CUDATiming;
import ua.edu.donntu.cs.ray.base_draw.BaseDrawRay;

/**
 * Этот класс выполняет рассчёты для метода трассировки лучей на GPU.
 * 
 * @author Denis Vodolazskiy
 */
public class ParallelRay extends BaseDrawRay {
	/**
	 * Время выполнения
	 */
	private float el_time;
	/**
	 * Массив цветов пикселов
	 */
	private int pixelColor[] = new int[N];;

	/**
	 * Пустой конструктор
	 */
	public ParallelRay() {

	}

	/**
	 * Конструктор для отрисовки объекта с помощью видеокарты
	 * 
	 * @param points
	 *            точки объекта
	 * @param polygons
	 *            полигоны объекта
	 * @param normals
	 *            нормали объекта
	 */
	public ParallelRay(int[] points, int[] polygons, int[] normals) {
		obtainTime(points, polygons, normals);
	}

	/**
	 * Конструктор для замера времени на видеокарте при различных расширениях
	 * экрана
	 * 
	 * @param points
	 *            точки объекта
	 * @param polygons
	 *            полигоны объекта
	 * @param normals
	 *            нормали объекта
	 * @param Nx
	 *            кол-во по оси X
	 * @param Ny
	 *            кол-во по оси Y
	 */
	public ParallelRay(int[] points, int[] polygons, int[] normals, int Nx,
			int Ny) {

		obtainTime(points, polygons, normals, Nx, Ny);
	}

	/**
	 * Функция для замера времени на видеокарте при различных расширениях экрана
	 * 
	 * @param points
	 *            точки объекта
	 * @param polygons
	 *            полигоны объекта
	 * @param normals
	 *            нормали объекта
	 * @param Nx
	 *            кол-во по оси X
	 * @param Ny
	 *            кол-во по оси Y
	 */
	public void obtainTime(int[] points, int[] polygons, int[] normals, int Nx,
			int Ny) {
		int N = Nx * Ny;
		pixelColor = new int[N];
		cudaStream_t stream = new cudaStream_t();
		CUDATiming ct = new CUDATiming(stream);
		ct.startTiming();

		// create device pointers and allocate memory on the device
		Pointer dev_pointsBaseCuda = new Pointer();
		cudaMalloc(dev_pointsBaseCuda, 3 * Q_POINTS * Sizeof.INT);
		Pointer dev_polygonsCuda = new Pointer();
		cudaMalloc(dev_polygonsCuda, 3 * Q_POLYGONS * Sizeof.INT);
		Pointer dev_normalsCuda = new Pointer();
		cudaMalloc(dev_normalsCuda, 3 * Q_POLYGONS * Sizeof.INT);

		Pointer dev_pixelColor = new Pointer();
		cudaMalloc(dev_pixelColor, N * Sizeof.INT);

		cudaMemcpy(dev_pointsBaseCuda, Pointer.to(points), 3 * Q_POINTS
				* Sizeof.INT, cudaMemcpyHostToDevice);
		cudaMemcpy(dev_polygonsCuda, Pointer.to(polygons), 3 * Q_POLYGONS
				* Sizeof.INT, cudaMemcpyHostToDevice);
		cudaMemcpy(dev_normalsCuda, Pointer.to(normals), 3 * Q_POLYGONS
				* Sizeof.INT, cudaMemcpyHostToDevice);

		// set cu-file
		KernelLauncher kernelLauncher = KernelLauncher.create(
				"data/cuSource/ParallelRay.cu", "ParallelRay", false);
		// parameters of CUDA-function
		int threadsPerBlock = 128;
		int blockPerGrid = (Nx + threadsPerBlock - 1) / threadsPerBlock;// Nx
		kernelLauncher.setGridSize(blockPerGrid, 1);
		kernelLauncher.setBlockSize(threadsPerBlock, 1, 1);

		// launch kernel to obtain visible polygons
		kernelLauncher.call(dev_pixelColor, dev_pointsBaseCuda,
				dev_polygonsCuda, dev_normalsCuda, N, Nx, Ny, a0, b0, d0, hx,
				hy, distanceX, distanceY, distanceZ, psi, teta, gamma);

		// copy data from device to host
		cudaMemcpy(Pointer.to(pixelColor), dev_pixelColor, N * Sizeof.INT,
				cudaMemcpyDeviceToHost);

		cudaFree(dev_pointsBaseCuda);
		cudaFree(dev_polygonsCuda);
		cudaFree(dev_normalsCuda);
		cudaFree(dev_pixelColor);
		//
		el_time = ct.stopTiming();
	}

	/**
	 * Функция для отрисовки объекта с помощью видеокарты экрана
	 * 
	 * @param points
	 *            точки объекта
	 * @param polygons
	 *            полигоны объекта
	 * @param normals
	 *            нормали объекта
	 */
	public void obtainTime(int[] points, int[] polygons, int[] normals) {
		// pixelColor= new int[N];
		cudaStream_t stream = new cudaStream_t();
		CUDATiming ct = new CUDATiming(stream);
		ct.startTiming();

		// create device pointers and allocate memory on the device
		Pointer dev_pointsBaseCuda = new Pointer();
		cudaMalloc(dev_pointsBaseCuda, 3 * Q_POINTS * Sizeof.INT);
		Pointer dev_polygonsCuda = new Pointer();
		cudaMalloc(dev_polygonsCuda, 3 * Q_POLYGONS * Sizeof.INT);
		Pointer dev_normalsCuda = new Pointer();
		cudaMalloc(dev_normalsCuda, 3 * Q_POLYGONS * Sizeof.INT);

		Pointer dev_pixelColor = new Pointer();
		cudaMalloc(dev_pixelColor, N * Sizeof.INT);

		cudaMemcpy(dev_pointsBaseCuda, Pointer.to(points), 3 * Q_POINTS
				* Sizeof.INT, cudaMemcpyHostToDevice);
		cudaMemcpy(dev_polygonsCuda, Pointer.to(polygons), 3 * Q_POLYGONS
				* Sizeof.INT, cudaMemcpyHostToDevice);
		cudaMemcpy(dev_normalsCuda, Pointer.to(normals), 3 * Q_POLYGONS
				* Sizeof.INT, cudaMemcpyHostToDevice);

		// set cu-file
		KernelLauncher kernelLauncher = KernelLauncher.create(
				"data/cuSource/ParallelRay.cu", "ParallelRay", false);
		// parameters of CUDA-function
		int threadsPerBlock = 128;
		int blockPerGrid = (Nx + threadsPerBlock - 1) / threadsPerBlock;// Nx
		kernelLauncher.setGridSize(blockPerGrid, 1);
		kernelLauncher.setBlockSize(threadsPerBlock, 1, 1);

		// launch kernel to obtain visible polygons
		kernelLauncher.call(dev_pixelColor, dev_pointsBaseCuda,
				dev_polygonsCuda, dev_normalsCuda, N, Nx, Ny, a0, b0, d0, hx,
				hy, distanceX, distanceY, distanceZ, psi, teta, gamma);

		// copy data from device to host
		cudaMemcpy(Pointer.to(pixelColor), dev_pixelColor, N * Sizeof.INT,
				cudaMemcpyDeviceToHost);

		cudaFree(dev_pointsBaseCuda);
		cudaFree(dev_polygonsCuda);
		cudaFree(dev_normalsCuda);
		cudaFree(dev_pixelColor);
		//
		el_time = ct.stopTiming();
	}

	/**
	 * Функция для отрисовки пикселов рассчитанным цветом
	 * 
	 * @param g2
	 *            полотно
	 * @param points
	 *            точки объекта
	 * @param polygons
	 *            полигоны объекта
	 * @param normals
	 *            нормали объекта
	 */
	public void calc(Graphics2D g2, int[] points, int[] polygons, int[] normals) {
		obtainTime(points, polygons, normals);

		//
		for (int i = 0; i < N; i++) {
			if (pixelColor[i] == 0) {
				fillPixcel(g2, i / Nx, i % Nx, Color.BLACK);
			} else {
				fillPixcel(g2, i / Nx, i % Nx, Color.WHITE);
			}
		}
	}

	/**
	 * Функция, выполняющая закраску пиксела
	 * 
	 * @param g2
	 *            полотно
	 * @param x
	 *            x-координата пиксела
	 * @param y
	 *            y-координата пиксела
	 * @param c
	 *            цвет пиксела
	 * 
	 */
	protected void fillPixcel(Graphics2D g2, int x, int y, Color c) {
		g2.setPaint(c);
		g2.drawLine(x, y, x, y);
	}

	/**
	 * Передаёт время выполнения
	 */
	public float getEl_time() {
		return el_time;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\ray\ray_calc\ParallelRay100.java

package ua.edu.donntu.cs.ray.ray_calc;

import static jcuda.runtime.JCuda.cudaFree;
import static jcuda.runtime.JCuda.cudaMalloc;
import static jcuda.runtime.JCuda.cudaMemcpy;
import static jcuda.runtime.cudaMemcpyKind.cudaMemcpyDeviceToHost;
import static jcuda.runtime.cudaMemcpyKind.cudaMemcpyHostToDevice;

import java.awt.Color;
import java.awt.Graphics2D;

import jcuda.Pointer;
import jcuda.Sizeof;
import jcuda.runtime.cudaStream_t;
import jcuda.utils.KernelLauncher;
import ua.edu.donntu.cs.cuda.service.CUDATiming;
import ua.edu.donntu.cs.ray.base_draw.BaseDrawRay;

/**
 * Этот класс выполняет рассчёты для метода трассировки лучей на GPU.
 * Делится на 100 потоков. Результат - медленне.
 * 
 * @author Denis Vodolazskiy
 */
public class ParallelRay100 extends BaseDrawRay {
	/**
	 * Время выполнения
	 */
	private float el_time;
	/**
	 * Массив цветов пикселов
	 */
	private int pixelColor[] = new int[N];
	/**
	 * Пустой конструктор
	 */
	private final int NumThreads = 100;// Nx должен бытькратен 100!

	/**
	 * Пустой конструктор
	 */
	public ParallelRay100() {

	}
	/**
	 * Конструктор для отрисовки объекта с помощью видеокарты
	 * 
	 * @param points
	 *            точки объекта
	 * @param polygons
	 *            полигоны объекта
	 * @param normals
	 *            нормали объекта
	 */
	public ParallelRay100(int[] points, int[] polygons, int[] normals) {
		obtainTime(points, polygons, normals);
	}
	/**
	 * Функция для отрисовки объекта с помощью видеокарты экрана
	 * 
	 * @param points
	 *            точки объекта
	 * @param polygons
	 *            полигоны объекта
	 * @param normals
	 *            нормали объекта
	 */
	public void obtainTime(int[] points, int[] polygons, int[] normals) {
		cudaStream_t stream = new cudaStream_t();
		CUDATiming ct = new CUDATiming(stream);
		ct.startTiming();

		// create device pointers and allocate memory on the device
		Pointer dev_pointsBaseCuda = new Pointer();
		cudaMalloc(dev_pointsBaseCuda, 3 * Q_POINTS * Sizeof.INT);
		Pointer dev_polygonsCuda = new Pointer();
		cudaMalloc(dev_polygonsCuda, 3 * Q_POLYGONS * Sizeof.INT);
		Pointer dev_normalsCuda = new Pointer();
		cudaMalloc(dev_normalsCuda, 3 * Q_POLYGONS * Sizeof.INT);

		Pointer dev_pixelColor = new Pointer();
		cudaMalloc(dev_pixelColor, N * Sizeof.INT);

		cudaMemcpy(dev_pointsBaseCuda, Pointer.to(points), 3 * Q_POINTS
				* Sizeof.INT, cudaMemcpyHostToDevice);
		cudaMemcpy(dev_polygonsCuda, Pointer.to(polygons), 3 * Q_POLYGONS
				* Sizeof.INT, cudaMemcpyHostToDevice);
		cudaMemcpy(dev_normalsCuda, Pointer.to(normals), 3 * Q_POLYGONS
				* Sizeof.INT, cudaMemcpyHostToDevice);

		// set cu-file
		KernelLauncher kernelLauncher = KernelLauncher.create(
				"data/cuSource/ParallelRay100.cu", "ParallelRay100", false);

		// parameters of CUDA-function
		int threadsPerBlock = 128;
		int blockPerGrid = (NumThreads + threadsPerBlock - 1) / threadsPerBlock;// Nx
		kernelLauncher.setGridSize(blockPerGrid, 1);
		kernelLauncher.setBlockSize(threadsPerBlock, 1, 1);

		// launch kernel to obtain visible polygons
		kernelLauncher.call(dev_pixelColor, dev_pointsBaseCuda,
				dev_polygonsCuda, dev_normalsCuda, N, Nx, Ny, a0, b0, d0, hx,
				hy, distanceX, distanceY, distanceZ, psi, teta, gamma,
				NumThreads);

		// copy data from device to host
		cudaMemcpy(Pointer.to(pixelColor), dev_pixelColor, N * Sizeof.INT,
				cudaMemcpyDeviceToHost);

		cudaFree(dev_pointsBaseCuda);
		cudaFree(dev_polygonsCuda);
		cudaFree(dev_normalsCuda);
		cudaFree(dev_pixelColor);
		//
		el_time = ct.stopTiming();
	}
	/**
	 * Функция для отрисовки пикселов рассчитанным цветом
	 * 
	 * @param g2
	 *            полотно
	 * @param points
	 *            точки объекта
	 * @param polygons
	 *            полигоны объекта
	 * @param normals
	 *            нормали объекта
	 */
	public void calc(Graphics2D g2, int[] points, int[] polygons, int[] normals) {
		obtainTime(points, polygons, normals);

		//
		for (int i = 0; i < N; i++) {
			if (pixelColor[i] == 0) {
				fillPixcel(g2, i / Nx, i % Nx, Color.BLACK);
			} else {
				fillPixcel(g2, i / Nx, i % Nx, Color.WHITE);
			}
		}
	}
	/**
	 * Функция, выполняющая закраску пиксела
	 * 
	 * @param g2
	 *            полотно
	 * @param x
	 *            x-координата пиксела
	 * @param y
	 *            y-координата пиксела
	 * @param c
	 *            цвет пиксела
	 * 
	 */
	protected void fillPixcel(Graphics2D g2, int x, int y, Color c) {
		g2.setPaint(c);
		g2.drawLine(x, y, x, y);
	}

	/**
	 * Передаёт время выполнения
	 */
	public float getEl_time() {
		return el_time;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\ray\ray_calc\Po.java

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ua.edu.donntu.cs.ray.ray_calc;

/**
 * Служебный класс для создания точки наблюдателя в методе трассировки лучей.
 * 
 * @author Denis Vodolazskiy
 */
public class Po {
    private int x;
    private int y;
    private int z;
    private float psi;
    private float teta;
    private float gamma;

    public Po(int x, int y, int z, float psi, float teta, float gamma) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.psi = psi;
        this.teta = teta;
        this.gamma = gamma;
    }

    public float getPsi() {
        return psi;
    }

    public float getTeta() {
        return teta;
    }

    public float getGamma() {
        return gamma;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public int getZ() {
        return z;
    }
    
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\ray\ray_calc\Ray.java

package ua.edu.donntu.cs.ray.ray_calc;

import static ua.edu.donntu.cs.inout.IPrepareData.Q_POLYGONS;

import java.awt.Color;
import java.awt.Graphics2D;

import ua.edu.donntu.cs.draw.matrix_transform.MatrixTransform;
import ua.edu.donntu.cs.ray.base_draw.BaseDrawRay;

/**
 * Этот класс выполняет рассчёты для метода трассировки лучей на CPU.
 * 
 * @author Denis Vodolazskiy
 */
public class Ray extends BaseDrawRay {

	private float t;
	/**
	 * Цвета граней куба
	 */
	Color c[] = new Color[] { new Color(255, 255, 0), new Color(255, 0, 0),
			new Color(255, 0, 255), new Color(0, 255, 0),
			new Color(0, 255, 255), new Color(0, 0, 255),
			new Color(0, 127, 255), new Color(0, 127, 0),
			new Color(0, 127, 127), new Color(127, 0, 127),
			new Color(127, 0, 0), new Color(127, 127, 0) };
	private static final long serialVersionUID = 1L;

	public Ray() {

	}

	/**
	 * Функция, выполняющая рассчёт видимых пикселов
	 * 
	 * @param g2
	 *            полотно
	 * @param points
	 *            точки объекта
	 * @param polygons
	 *            полигоны объекта
	 * @param normals
	 *            нормали объекта
	 * 
	 */
	public void calc(Graphics2D g2, int points[][], int polygons[][],
			int normals[][]) {
		// 5. Calculate matrix E(local –global) to make rotation of coordinate
		// system
		// float E[][] = new MatrixTransform().matr(psi, teta, gamma, 1);
		double E[][] = new MatrixTransform().matr(0, 0, 0, 1);

		// Initialization of arrays
		float X;// расстояние до пиксела X
		float Y;// расстояние до пиксела Y
		float Z;// расстояние до пиксела Z
		float Xv;
		float Yv;
		float Zv;
		float Vx;
		float Vy;
		float Vz;

		// p(Q_POLYGONS);
		for (int i = 0; i < Nx; i++) {
			for (int j = 0; j < Ny; j++) {
				// for (int i = Nx / 2; i < Nx / 2 + 1; i++) {
				// for (int j = Ny / 2; j < Ny / 2+2 ; j++) {
				// 8. Element (i,j) of the window has 3D coordinate in observer
				// system (center - in right eye):
				X = d0;
				Y = b0 / 2.0f - j * hy;
				Z = -a0 / 2.0f + i * hx;
				// 9. Convert Ray’s parameters to global system:
				Xv = X * (float) E[0][0] + Y * (float) E[0][1] + Z
						* (float) E[0][2] - distanceX;
				Yv = X * (float) E[1][0] + Y * (float) E[1][1] + Z
						* (float) E[1][2] - distanceY;
				Zv = X * (float) E[2][0] + Y * (float) E[2][1] + Z
						* (float) E[2][2] - distanceZ;
				/*
				 * System.out.println("Observer:" + X[i * Nx + j] + " " + Y[i *
				 * Nx + j] + " " + Z[i * Nx + j]);
				 * System.out.println("Global system:" + Xv[i * Nx + j] + " " +
				 * Yv[i * Nx + j] + " " + Zv[i * Nx + j]);
				 */
				// 10. Convert Ray’s parameters to global system:
				Vx = Xv + distanceX;
				Vy = Yv + distanceY;
				Vz = Zv + distanceZ;
				// System.out.println("Global vector:" + Vx[i * Nx + j] + " "
				// + Vy[i * Nx + j] + " " + Vz[i * Nx + j]);
				// 11. Initializing:
				int hit = 0;
				float tmin = 1_000_000;// init min distance
				float tin = 1_000_000;// -Fmax
				float tout = -1_000_000;// Fmax
				float t_ = -1;// t*
				int gin = -1;
				int gmin;// index of polyfon
				// 12. Loop for objects analyses.
				// init arrays
				float Xvo[] = new float[Q_POLYGONS];
				float Yvo[] = new float[Q_POLYGONS];
				float Zvo[] = new float[Q_POLYGONS];
				float Vxo[] = new float[Q_POLYGONS];
				float Vyo[] = new float[Q_POLYGONS];
				float Vzo[] = new float[Q_POLYGONS];

				for (int io = 0; io < 1; io++) {
					// 16. Location of iob - object loading:-
					Po po = new Po(0, 0, 0, psi, teta, gamma);
					// Po po = new Po(0, 0, 0, 0, 0, 0);
					// 17. Calculation of matrix D (global to local) to make
					// rotation of coordinate system – transformed matrix.
					double D[][] = new MatrixTransform().matr(psi, teta, gamma,
							2);
					/*
					 * for (int k=0;k<3;k++){ System.out.println(); for (int
					 * mn=0;mn<3;mn++){ System.out.print(E[k][mn]+" "); } }
					 */
					// 18. Convert Ray parameters to object iob system - ????
					// float Po[] = {0, 0, 0};

					Xvo[io] = Xv * (float) D[0][0] + Yv * (float) D[0][1] + Zv
							* (float) D[0][2] + po.getX();
					Yvo[io] = Xv * (float) D[1][0] + Yv * (float) D[1][1] + Zv
							* (float) D[1][2] + po.getY();
					Zvo[io] = Xv * (float) D[2][0] + Yv * (float) D[2][1] + Zv
							* (float) D[2][2] + po.getZ();

					Vxo[io] = Vx * (float) D[0][0] + Vy * (float) D[0][1] + Vz
							* (float) D[0][2];
					Vyo[io] = Vx * (float) D[1][0] + Vy * (float) D[1][1] + Vz
							* (float) D[1][2];
					Vzo[io] = Vx * (float) D[2][0] + Vy * (float) D[2][1] + Vz
							* (float) D[2][2];
					// 19. Intersection stage – defined below.
					boolean cross = false;

					float div;
					float d;
					float dev;

					for (int iob = 0; iob < Q_POLYGONS; iob++) {
						// System.out.println("normal:" + normals[iob][0] +
						// " "+normals[iob][1]+" "+normals[iob][2]);
						// System.out.println("vector:" + Vxo[io] +
						// " "+Vyo[io]+" "+Vzo[io]);
						div = normals[iob][0] * Vxo[io] + normals[iob][1]
								* Vyo[io] + normals[iob][2] * Vzo[io];
						d = normals[iob][0] * points[polygons[iob][0]][0]
								+ normals[iob][1] * points[polygons[iob][0]][1]
								+ normals[iob][2] * points[polygons[iob][0]][2];
						dev = normals[iob][0] * Xvo[io] + normals[iob][1]
								* Yvo[io] + normals[iob][2] * Zvo[io] + d;
						// System.out.println("iob:" + iob +
						// " div="+div+" dev="+dev);
						if (div != 0) {
							t = -dev / div;
							// p(i+"   "+j+"   "+t+"   "+iob);
							if (div < 0) {
								if (t < tin) {
									tin = t;
									gin = iob;
								}
							} else {
								if (t > tout) {
									tout = t;
								}
							}
							// p("i="+i+"   j="+j+"  t="+t+"   tin="+tin+"   tout="+tout+"   iob="+iob);
						} else {
							tin = -1_000_000;
							tout = 0;
						}
						// System.out.println("t="
						// +t+" tin="+tin+" tout="+tout);
					}// end of for iob< Q_POLYGONS

					//
					if (tin >= tout) {// ???????????
						cross = true;
					} else {
						cross = false;
					}
					t_ = tin;

					// 20
					// System.out.println("gin="+gin+" cross="+cross);
					if (cross) {
						hit++;// 23
						if (hit == 1) {// 21
							tmin = t_;
							gmin = gin;
						} else {
							if (t_ < tmin) {// 22 //<
								tmin = t_;
								gmin = gin;
								// continue;
							}
						}
					}
				}// end of for io<K objects
					// System.out.println("Pixcel="+(i * Nx + j)+" hit="+hit);
					// 13
				if (hit == 0) {
					// 14
					Color cFill = new Color(0, 0, 0);

					fillPixcel(g2, i, j, cFill);
				} else {// 15
					// Color cFill = new Color(255, 255, 255);
					Color cFill = c[gin];
					fillPixcel(g2, i, j, cFill);
				}
			}// Ny
		}// Nx
	}

	/**
	 * Функция, выполняющая закраску пиксела
	 * 
	 * @param g2
	 *            полотно
	 * @param x
	 *            x-координата пиксела
	 * @param y
	 *            y-координата пиксела
	 * 
	 */
	protected void fillPixcel(Graphics2D g2, int x, int y) {
		Color cFill = new Color(255, 255, 255);
		g2.setPaint(cFill);
		g2.drawLine(x, y, x, y);
	}

	/**
	 * Функция, выполняющая закраску пиксела
	 * 
	 * @param g2
	 *            полотно
	 * @param x
	 *            x-координата пиксела
	 * @param y
	 *            y-координата пиксела
	 * @param c
	 *            цвет пиксела
	 * 
	 */
	protected void fillPixcel(Graphics2D g2, int x, int y, Color c) {
		g2.setPaint(c);
		g2.drawLine(x, y, x, y);
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\ray\ray_calc_time\RayTimeCalc.java

package ua.edu.donntu.cs.ray.ray_calc_time;

import ua.edu.donntu.cs.ray.base_draw.BaseDrawRay;
import ua.edu.donntu.cs.ray.ray_calc.ParallelRay;

/**
 * Этот класс замеряет времявыполнения для метода трассировки лучей на CPU и
 * GPU. Ресультат выводит в консоль. Не используется в основной программе.
 * 
 * @author Denis Vodolazskiy
 */
public class RayTimeCalc extends BaseDrawRay {
	private long CPUtime;
	private float GPUtime;

	public RayTimeCalc() {
		CPUtime = new SerialRayTime(points, polygons, normals, Nx, Ny)
				.getTimeout();
		GPUtime = new ParallelRay(pointsBaseCuda, polygonsCuda, normalsCuda)
				.getEl_time();

		System.out.println("SerialRayTime elapsed on CPU=" + CPUtime + " ms");

		System.out.println("ParallelRayTime elapsed on GPU=" + GPUtime + " ms");

		System.out.println("CPU/GPU=" + CPUtime / GPUtime + " times");

	}

}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\ray\ray_calc_time\SerialRayTime.java

package ua.edu.donntu.cs.ray.ray_calc_time;

import java.awt.Color;

import ua.edu.donntu.cs.draw.matrix_transform.MatrixTransform;
import ua.edu.donntu.cs.ray.base_draw.BaseDrawRay;
import ua.edu.donntu.cs.ray.ray_calc.Po;

/**
 * Этот класс выполняет рассчёты для метода трассировки лучей на CPU. Необходим для
 * замера времени выполнения.
 * 
 * @author Denis Vodolazskiy
 */
public class SerialRayTime extends BaseDrawRay {
	/**
	 * Время выполнения
	 */
	private long timeout;
	private float t;

	/**
	 * Конструктор, выполняющий вычисления для метода трассировки лучей. 
	 * 
	 * @param points
	 *            точки объекта
	 * @param polygons
	 *            полигоны объекта
	 * @param normals
	 *            нормали объекта
	 * @param Nx
	 *            пикселы по X
	 * @param Ny
	 *            пикселы по Y
	 * 
	 */
	public SerialRayTime(int points[][], int polygons[][], int normals[][],
			int Nx, int Ny) {
		timeout = System.currentTimeMillis();
		//
		// 5. Calculate matrix E(local –global) to make rotation of coordinate
		// system
		double E[][] = new MatrixTransform().matr(0, 0, 0, 1);

		// Initialization of arrays
		float X;// расстояние до пиксела X
		float Y;// расстояние до пиксела Y
		float Z;// расстояние до пиксела Z
		float Xv;
		float Yv;
		float Zv;
		float Vx;
		float Vy;
		float Vz;

		// p(Q_POLYGONS);
		for (int i = 0; i < Nx; i++) {
			for (int j = 0; j < Ny; j++) {
				// 8. Element (i,j) of the window has 3D coordinate in observer
				// system (center - in right eye):
				X = d0;
				Y = b0 / 2.0f - j * hy;
				Z = -a0 / 2.0f + i * hx;
				// 9. Convert Ray’s parameters to global system:
				Xv = X * (float) E[0][0] + Y * (float) E[0][1] + Z
						* (float) E[0][2] - distanceX;
				Yv = X * (float) E[1][0] + Y * (float) E[1][1] + Z
						* (float) E[1][2] - distanceY;
				Zv = X * (float) E[2][0] + Y * (float) E[2][1] + Z
						* (float) E[2][2] - distanceZ;
				// 10. Convert Ray’s parameters to global system:
				Vx = Xv + distanceX;
				Vy = Yv + distanceY;
				Vz = Zv + distanceZ;

				// 11. Initializing:
				int hit = 0;
				float tmin = 1_000_000;// init min distance
				float tin = 1_000_000;// -Fmax
				float tout = -1_000_000;// Fmax
				float t_ = -1;// t*
				int gin = -1;
				int gmin;// index of polyfon
				// 12. Loop for objects analyses.
				// init arrays
				float Xvo[] = new float[Q_POLYGONS];
				float Yvo[] = new float[Q_POLYGONS];
				float Zvo[] = new float[Q_POLYGONS];
				float Vxo[] = new float[Q_POLYGONS];
				float Vyo[] = new float[Q_POLYGONS];
				float Vzo[] = new float[Q_POLYGONS];
				float NormalObs[][] = new float[Q_POLYGONS][3];

				for (int io = 0; io < 1; io++) {
					// 16. Location of iob - object loading:-
					Po po = new Po(0, 0, 0, psi, teta, gamma);
					// 17. Calculation of matrix D (global to local) to make
					// rotation of coordinate system – transformed matrix.
					double D[][] = new MatrixTransform().matr(psi, teta, gamma,
							2);

					// 18. Convert Ray parameters to object iob system - ????

					Xvo[io] = Xv * (float) D[0][0] + Yv * (float) D[0][1] + Zv
							* (float) D[0][2] + po.getX();
					Yvo[io] = Xv * (float) D[1][0] + Yv * (float) D[1][1] + Zv
							* (float) D[1][2] + po.getY();
					Zvo[io] = Xv * (float) D[2][0] + Yv * (float) D[2][1] + Zv
							* (float) D[2][2] + po.getZ();

					Vxo[io] = Vx * (float) D[0][0] + Vy * (float) D[0][1] + Vz
							* (float) D[0][2];
					Vyo[io] = Vx * (float) D[1][0] + Vy * (float) D[1][1] + Vz
							* (float) D[1][2];
					Vzo[io] = Vx * (float) D[2][0] + Vy * (float) D[2][1] + Vz
							* (float) D[2][2];

					// 19. Intersection stage – defined below.
					boolean cross = false;

					float div;
					float d;
					float dev;

					for (int iob = 0; iob < Q_POLYGONS; iob++) {
						div = normals[iob][0] * Vxo[io] + normals[iob][1]
								* Vyo[io] + normals[iob][2] * Vzo[io];
						d = normals[iob][0] * points[polygons[iob][0]][0]
								+ normals[iob][1] * points[polygons[iob][0]][1]
								+ normals[iob][2] * points[polygons[iob][0]][2];
						dev = normals[iob][0] * Xvo[io] + normals[iob][1]
								* Yvo[io] + normals[iob][2] * Zvo[io] + d;

						if (div != 0) {
							t = -dev / div;
							if (div < 0) {
								if (t < tin) {
									tin = t;
									gin = iob;
								}
							} else {
								if (t > tout) {
									tout = t;
								}
							}
						} else {
							tin = -1_000_000;
							tout = 0;
						}
					}// end of for iob< Q_POLYGONS

					//
					if (tin >= tout) {//
						cross = true;
					} else {
						cross = false;
					}
					t_ = tin;

					// 20
					if (cross) {
						hit++;// 23
						if (hit == 1) {// 21
							tmin = t_;
							gmin = gin;
						} else {
							if (t_ < tmin) {// 22 //<
								tmin = t_;
								gmin = gin;
								// continue;
							}
						}
					}
				}// end of for io<K objects
					// 13

				if (hit == 0) {
					// 14
					Color cFill = new Color(0, 0, 0);
					// fillPixcel(g2, i, j, cFill);
				} else {// 15
					Color cFill = new Color(255, 255, 255);
					// Color cFill = c[gin];
					// fillPixcel(g2, i, j, cFill);
				}
			}// Ny
		}// Nx

		// End of timer. Calc elapsed time.
		timeout = System.currentTimeMillis() - timeout;
	}

	/**
	 * Передаёт время выполнения
	 */
	public long getTimeout() {
		return timeout;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\ray\ray_key_manager\CraftFast.java

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ua.edu.donntu.cs.ray.ray_key_manager;

import java.awt.event.KeyEvent;

/**
 * Этот класс обрабатывает нажатие клавиш. Изменение позиции и угла поворота
 * объета увеличиваются на 10 единиц при одном нажатии. Это необходимо, т.к.
 * метод трассирови лучей работает медленней.
 * 
 * @author Denis Vodolazskiy
 */
public class CraftFast {
	private float psi;// = 0;// -30;
	private float teta;// = 0;// 30;
	private float gamma;// = 0;
	private float dpsi = 0;
	private float dteta = 0;
	private float dgamma = 0;
	private int distX;// = 60000;
	private int distY;// = 0;
	private int distZ;// = 0;
	private int deltadistX = 0;
	private int deltadistY = 0;
	private int deltadistZ = 0;

	/**
	 * Конструктор менеджера клавиатуры
	 * 
	 * @param psi
	 *            угол пси (вокруг оси Y)
	 * @param teta
	 *            угол тэта (вокруг оси Z)
	 * @param gamma
	 *            угол гамма (вокруг оси X)
	 * @param distX
	 *            текущее расстояние по оси X
	 * @param distY
	 *            текущее расстояние по оси Y
	 * @param distZ
	 *            текущее расстояние по оси Z
	 */
	public CraftFast(float psi, float teta, float gamma, int distX, int distY,
			int distZ) {
		this.psi = psi;
		this.teta = teta;
		this.gamma = gamma;
		this.distX = distX;
		this.distY = distY;
		this.distZ = distZ;
	}

	/**
	 * Если произошло событие
	 */
	public void move() {
		psi += dpsi;
		gamma += dgamma;
		teta += dteta;
		distX += deltadistX;
		distY += deltadistY;
		distZ += deltadistZ;
	}

	/**
	 * Взять psi
	 * 
	 * @return угол пси (вокруг оси Y)
	 */
	public float getPsi() {
		return psi;
	}

	/**
	 * Взять teta
	 * 
	 * @return угол тэта (вокруг оси Z)
	 */
	public float getTeta() {
		return teta;
	}

	/**
	 * Взять gamma
	 * 
	 * @return угол гамма (вокруг оси X)
	 */
	public float getGamma() {
		return gamma;
	}

	/**
	 * Взять distX
	 * 
	 * @return текущее расстояние по оси X
	 */
	public int getDistX() {
		return distX;
	}

	/**
	 * Взять distY
	 * 
	 * @return текущее расстояние по оси Y
	 */
	public int getDistY() {
		return distY;
	}

	/**
	 * Взять distZ
	 * 
	 * @return текущее расстояние по оси Z
	 */
	public int getDistZ() {
		return distZ;
	}

	/**
	 * Клавиша нажата
	 * 
	 * @param e
	 *            событие
	 */
	public void keyPressed(KeyEvent e) {

		int key = e.getKeyCode();

		if (key == KeyEvent.VK_LEFT) {
			dpsi = -10;
		}

		if (key == KeyEvent.VK_RIGHT) {
			dpsi = 10;
		}

		if (key == KeyEvent.VK_UP) {
			dgamma = -10;
		}

		if (key == KeyEvent.VK_DOWN) {
			dgamma = 10;
		}
		if (key == KeyEvent.VK_PAGE_UP) {
			dteta = -10;
		}

		if (key == KeyEvent.VK_PAGE_DOWN) {
			dteta = 10;
		}
		if (key == KeyEvent.VK_F11) {
			deltadistX = -1000;
		}

		if (key == KeyEvent.VK_F12) {
			deltadistX = 1000;
		}
		if (key == KeyEvent.VK_F5) {
			deltadistY = -1000;
		}

		if (key == KeyEvent.VK_F6) {
			deltadistY = 1000;
		}
		if (key == KeyEvent.VK_F7) {
			deltadistZ = -1000;
		}

		if (key == KeyEvent.VK_F8) {
			deltadistZ = 1000;
		}
	}

	/**
	 * Клавиша нажата
	 * 
	 * @param e
	 *            событие
	 */
	public void keyReleased(KeyEvent e) {
		int key = e.getKeyCode();

		if (key == KeyEvent.VK_LEFT) {
			dpsi = 0;
		}

		if (key == KeyEvent.VK_RIGHT) {
			dpsi = 0;
		}

		if (key == KeyEvent.VK_UP) {
			dgamma = 0;
		}

		if (key == KeyEvent.VK_DOWN) {
			dgamma = 0;
		}
		if (key == KeyEvent.VK_PAGE_UP) {
			dteta = 0;
		}

		if (key == KeyEvent.VK_PAGE_DOWN) {
			dteta = 0;
		}
		if (key == KeyEvent.VK_F11) {
			deltadistX = 0;
		}

		if (key == KeyEvent.VK_F12) {
			deltadistX = 0;
		}
		if (key == KeyEvent.VK_F5) {
			deltadistY = 0;
		}

		if (key == KeyEvent.VK_F6) {
			deltadistY = 0;
		}
		if (key == KeyEvent.VK_F7) {
			deltadistZ = 0;
		}

		if (key == KeyEvent.VK_F8) {
			deltadistZ = 0;
		}
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\service\CalcStrings.java

package ua.edu.donntu.cs.service;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * Этот класс выполняет подсчёт папок, файлов и строк кода во всех файлах. Тут
 * же можно скопировать все классы в один файл с помощью copyInOne
 * (раскомментировать одну строчку). Файл allCode.txt создаётся в корне проекта.
 * 
 * @author Denis Vodolazskiy
 */
public class CalcStrings {
	/**
	 * Количество папок
	 */
	private int directoriesNumber;
	/**
	 * Количество файлов
	 */
	private int filesNumber;
	/**
	 * Количество строк
	 */
	private int count = 0;
	/**
	 * Перезапись файла со всем кодом
	 */
	private boolean rewrite = true;

	/**
	 * Конструктор. Берёт файлы из .java из папки "src" и файлы ".cu" из папки
	 * "data/cuSource"
	 */

	public CalcStrings() {
		File f = new File("src");
		//
		ArrayList<File> res = new ArrayList<File>();
		search(f, res);
		f = new File("data/cuSource");
		search(f, res, ".cu");
	}

	/**
	 * Считает количество строк в файле
	 * 
	 * @param name
	 *            путь к файлу
	 */
	private void quantityOfStrings(String name) {

		FileReader fr;
		try {
			fr = new FileReader(name);
			BufferedReader br = new BufferedReader(fr);
			while (br.readLine() != null) {
				count++;
			}
			br.close();
			copyInOne(name);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			System.out.println("File not found");
			// e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/**
	 * Копирует все файлы в один
	 * 
	 * @param name
	 *            путь к файлу
	 */
	private void copyInOne(String name) {
		FileReader fr = null;
		BufferedReader br = null;
		BufferedWriter writer = null;
		try {
			if (rewrite) {
				writer = new BufferedWriter(new FileWriter("allCode.txt", false));
				rewrite = false;
			}
			writer = new BufferedWriter(new FileWriter("allCode.txt", true));
			fr = new FileReader(name);
			br = new BufferedReader(fr);
			String s;
			writer.write(name);
			writer.write("\n");
			writer.write("\n");
			while ((s = br.readLine()) != null) {
				writer.write(s);
				writer.write("\n");
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally {
			try {
				fr.close();
				br.close();
				writer.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		}
	}

	/**
	 * Ишет все файлы в папке и подпапках
	 * 
	 * @param topDirectory
	 *            путь к файлу
	 * @param res
	 *            список файлов
	 */
	private void search(File topDirectory, List<File> res) {
		// получаем список всех объектов в текущей директории
		File[] list = topDirectory.listFiles();
		// просматриваем все объекты по-очереди
		for (int i = 0; i < list.length; i++) {
			// если это директория (папка)...
			if (list[i].isDirectory()) {
				directoriesNumber++;
				res.add(list[i]);
				// выполняем поиск во вложенных директориях
				search(list[i], res);
			}
			// если это файл
			else {
				if (list[i].isFile()) {
					// ...добавляем текущий объект в список результатов,
					// и обновляем значения счетчиков
					filesNumber++;
					res.add(list[i]);
					quantityOfStrings(list[i].getAbsolutePath());
				}
			}
		}
	}

	/**
	 * Ишет все файлы в папке и подпапках (.cu)
	 * 
	 * @param topDirectory
	 *            путь к файлу
	 * @param res
	 *            список файлов
	 * @param ext
	 *            расширение файла
	 */
	private void search(File topDirectory, List<File> res, String ext) {
		// получаем список всех объектов в текущей директории
		File[] list = topDirectory.listFiles();
		// просматриваем все объекты по-очереди
		for (int i = 0; i < list.length; i++) {
			// если это директория (папка)...
			if (list[i].isDirectory()) {
				directoriesNumber++;
				res.add(list[i]);
				// выполняем поиск во вложенных директориях
				search(list[i], res);
			}
			// если это файл
			else {
				if (list[i].isFile()) {
					// ...добавляем текущий объект в список результатов,
					// и обновляем значения счетчиков
					if (list[i].getName().endsWith(ext)) {
						filesNumber++;
						res.add(list[i]);
						quantityOfStrings(list[i].getAbsolutePath());
					}
				}
			}
		}
	}

	/**
	 * Возвращает количество папок
	 * 
	 * @return количество папок
	 */
	public int getDirectoriesNumber() {
		return directoriesNumber;
	}

	/**
	 * Возвращает количество файлов
	 * 
	 * @return количество файлов
	 */
	public int getFilesNumber() {
		return filesNumber;
	}

	/**
	 * Возвращает количество строк
	 * 
	 * @return количество строк
	 */
	public int getCount() {
		return count;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\service\Model2013Juli.java

/**
 * 
 * @author Denis Vodolazskiy
 */

package ua.edu.donntu.cs.service;

/**
 * Класс запуска программы
 */

public class Model2013Juli {

	public static void main(String[] args) {
		/**
		 * Вызов класса заставки
		 */
		new Splash();
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\service\Splash.java

package ua.edu.donntu.cs.service;

/**
 * Класс для вызова заставки при запуске 
 * 
 * @author Denis Vodolazskiy
 */
import java.awt.Graphics;
import java.awt.Image;
import java.awt.SplashScreen;
import java.awt.Toolkit;

import javax.swing.ImageIcon;
import javax.swing.JWindow;

public class Splash extends JWindow {
	Image img = Toolkit.getDefaultToolkit().getImage("data/images/splash.JPG");
	ImageIcon imgicon = new ImageIcon(img);

	/**
	 * Конструктор, вызывает заставку
	 */
	public Splash() {
		try {
			setSize(imgicon.getIconWidth(), imgicon.getIconHeight());
			setLocationRelativeTo(null);
			setVisible(true);
			Thread.sleep(2000);
			dispose();
			/*
			 * javax.swing.JOptionPane.showMessageDialog( (java.awt.Component)
			 * null, "Welcome", "Welcome Screen:",
			 * javax.swing.JOptionPane.DEFAULT_OPTION);
			 */
		} catch (Exception exception) {
			/*
			 * javax.swing.JOptionPane.showMessageDialog( (java.awt.Component)
			 * null, "Error" + exception.getMessage(), "Error:",
			 * javax.swing.JOptionPane.DEFAULT_OPTION);
			 */
		}
		SplashScreen screen = SplashScreen.getSplashScreen();
		new StartFrame();
	}

	/**
	 * Выполняет перерисовку окна
	 */
	public void paint(Graphics g) {
		g.drawImage(img, 0, 0, this);
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\service\StartFrame.java

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ua.edu.donntu.cs.service;

import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.UIManager;

import ua.edu.donntu.cs.athor_doc.Athor;
import ua.edu.donntu.cs.athor_doc.Documents;
import ua.edu.donntu.cs.cuda.compare_frame.CPUandGPUCompareFrame;
import ua.edu.donntu.cs.cuda.exception.InitCuda;
import ua.edu.donntu.cs.cuda.many_ships.ManyShipsCuda;
import ua.edu.donntu.cs.cuda.properties.ShowDeviceProperties;
import ua.edu.donntu.cs.draw.animation.AnimateShip;
import ua.edu.donntu.cs.draw.animation.SwimShipThread;
import ua.edu.donntu.cs.draw.main.StartDrawClass;
import ua.edu.donntu.cs.draw.move.MoveShip;
import ua.edu.donntu.cs.draw.move.SwimShip;
import ua.edu.donntu.cs.path.calculations_kutt.IKuttCalc;
import ua.edu.donntu.cs.path.frames.BigGraphicUniFrame;
import ua.edu.donntu.cs.path.frames.ObjectCoordFrame;
import ua.edu.donntu.cs.path.frames.ObserverCoordFrame;
import ua.edu.donntu.cs.path.frames.VelocityFrame;
import ua.edu.donntu.cs.path.paint.PaintGraph;
import ua.edu.donntu.cs.path.paint.PaintGraphCoordCircle;
import ua.edu.donntu.cs.priority_method.draw.ManyShipsMove;
import ua.edu.donntu.cs.ray.compare_graphic.CPUandGPUCompareRayFrame;
import ua.edu.donntu.cs.ray.draw_ray.DrawRay;
import ua.edu.donntu.cs.ray.draw_ray.DrawRayCuda;

/**
 * Класс для построения начального окна.
 * 
 * @author Denis Vodolazskiy
 */
public class StartFrame extends JFrame implements ActionListener, IKuttCalc {

	private JButton jbt1, jbt2, jbt3, jexit, jbt5, jbt6, jbt7, jbt8, jbt9,
			jbt10, jbt11, jbt12, jbt13, jbt14, jbt15, jbt16, jbt17, jbt18;
	private PaintGraph pgXYmov;

	/**
	 * Выполняет действия при нажатии кнопок
	 */
	@Override
	public void actionPerformed(ActionEvent e) {

		if (e.getSource().equals(jbt1)) {
			new VelocityFrame();
		} else if (e.getSource().equals(jbt2)) {
			new ObjectCoordFrame();
		} else if (e.getSource().equals(jbt3)) {
			new ObserverCoordFrame();
		} else if (e.getSource().equals(jexit)) {
			System.exit(0);
		} else if (e.getSource().equals(jbt5)) {
			pgXYmov = new PaintGraphCoordCircle("Xmov", "Ymov", MC.getXobs(),
					MC.getYobs(), 1, 1, 3500, 3500, 1);
			new BigGraphicUniFrame(pgXYmov);
		} else if (e.getSource().equals(jbt6)) {
			new StartDrawClass(new AnimateShip());
		} else if (e.getSource().equals(jbt7)) {
			new StartDrawClass(new MoveShip());
		} else if (e.getSource().equals(jbt8)) {
			new StartDrawClass(new ManyShipsMove());
		} else if (e.getSource().equals(jbt9)) {
			if (new InitCuda().isPresent())
				new StartDrawClass(new ManyShipsCuda());
		} else if (e.getSource().equals(jbt10)) {
			new StartDrawClass(new SwimShipThread());
		} else if (e.getSource().equals(jbt11)) {
			new StartDrawClass(new SwimShip());
		} else if (e.getSource().equals(jbt12)) {
			new CPUandGPUCompareFrame();
		} else if (e.getSource().equals(jbt13)) {
			if (new InitCuda().isPresent())
				new ShowDeviceProperties();
		} else if (e.getSource().equals(jbt14)) {
			new Athor();
		} else if (e.getSource().equals(jbt15)) {
			new Documents();
		} else if (e.getSource().equals(jbt16)) {
			new StartDrawClass(new DrawRay());
		} else if (e.getSource().equals(jbt17)) {
			new CPUandGPUCompareRayFrame();
		} else if (e.getSource().equals(jbt18)) {
			new StartDrawClass(new DrawRayCuda());
		}
	}

	/**
	 * Конструктор, задаёт расположение окна и его свойства
	 */
	public StartFrame() {
		super("Построить:");
		// System Look-And-Feel:
		try {
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (Exception e) {
			// Exception handle
		}
		JPanel panel = new JPanel();
		panel.setLayout(new GridLayout(15, 1, 1, 1));
		setSize(280, 580); // задание размеров
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // задание параметров //
														// главного окна при
														// закрытии

		Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();
		// int width = getSize().width;
		// int height = getSize().height;
		int x = dim.width - 280;// (dim.width - width) / 2;
		int y = 0;// (dim.height - height) / 2;
		setLocation(x, y);

		Image img = Toolkit.getDefaultToolkit().getImage(
				"data/images/splash.JPG");
		setIconImage(img);
		// setIconImage(getToolkit().getImage(getClass().getResource("/data/images/splash.JPG")));

		jbt1 = new JButton("VelocityFrame");
		jbt2 = new JButton("ObjectCoordFrame");
		jbt3 = new JButton("ObserverCoordFrame");
		jbt5 = new JButton("Path");
		jexit = new JButton("Exit");
		jbt6 = new JButton("AnimateShip");
		jbt7 = new JButton("MoveShip");
		jbt8 = new JButton("Метод приоритетов");
		jbt9 = new JButton("Метод приоритетов Cuda");
		jbt10 = new JButton("SwimShipThread");
		jbt11 = new JButton("SwimShip");
		jbt12 = new JButton("GPU vs CPU");
		jbt13 = new JButton("Свойства системы");
		jbt14 = new JButton("Об авторе и проекте");
		jbt15 = new JButton("Документация");
		jbt16 = new JButton("Ray CPU");
		jbt17 = new JButton("Ray GPU vs CPU");
		jbt18 = new JButton("Ray GPU");

		// -------------
		panel.add(jbt1);
		jbt2.setEnabled(false);
		// panel.add(jbt2);
		jbt3.setEnabled(false);
		// panel.add(jbt3);
		panel.add(jbt5);
		panel.add(jbt6);
		panel.add(jbt7);
		panel.add(jbt8);
		panel.add(jbt9);
		// panel.add(jbt10);
		jbt10.setEnabled(false);
		panel.add(jbt11);
		panel.add(jbt12);
		panel.add(jbt17);
		panel.add(jbt13);
		panel.add(jbt16);
		panel.add(jbt18);
		panel.add(jbt15);
		panel.add(jbt14);
		panel.add(jexit);
		// ----------
		jbt1.addActionListener(this);
		jbt2.addActionListener(this);
		jbt3.addActionListener(this);
		jexit.addActionListener(this);
		jbt5.addActionListener(this);
		jbt6.addActionListener(this);
		jbt7.addActionListener(this);
		jbt8.addActionListener(this);
		jbt9.addActionListener(this);
		jbt10.addActionListener(this);
		jbt11.addActionListener(this);
		jbt12.addActionListener(this);
		jbt13.addActionListener(this);
		jbt14.addActionListener(this);
		jbt15.addActionListener(this);
		jbt16.addActionListener(this);
		jbt17.addActionListener(this);
		jbt18.addActionListener(this);
		// ----------
		setResizable(false);
		setVisible(true);
		setContentPane(panel);
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\service\TestRef.java

package ua.edu.donntu.cs.service;

import java.io.IOException;

public class TestRef {
	TestRef(){
	try {
		Process process = Runtime.getRuntime().exec("explorer");
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\service\transform_pixels_meters\MetMmTransform.java

/*Этот класс переводит координаты в в метры. За основу взято отношение длины корабля в точках к длине в метрах*/
package ua.edu.donntu.cs.service.transform_pixels_meters;

import ua.edu.donntu.cs.path.calculations_kutt.IKuttCalc;

/**
 * Преобразоваяние метров в пикселы и наоборот. За основу взято отношение длины
 * корабля в точках к длине в метрах
 * 
 * @author Denis Vodolazskiy
 * 
 */
public class MetMmTransform implements IKuttCalc {
	private double meter;
	private double mm;

	/**
	 * Конструктор устанавоивает цену деления для пиксела и метра
	 */
	public MetMmTransform() {		
		meter = 1000;
		mm = 1.0 / meter;
	}

	/**
	 * Перевод метров в пикселы
	 * 
	 * @param Xm
	 *            количество метров
	 * @return количество пикселов
	 */
	public int meter2mm(double Xm) {
		if (Xm >= 0)
			return (int) (meter * Xm + 0.5);
		else
			return (int) (meter * Xm - 0.5);
	}

	/**
	 * Перевод пикселов в метры
	 * 
	 * @param Xp
	 *            количество пикселов
	 * @return количество метров
	 */
	public int mm2meter(double Xp) {
		if (Xp >= 0)
			return (int) (mm * Xp + 0.5);
		else
			return (int) (mm * Xp - 0.5);
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\src\ua\edu\donntu\cs\service\transform_pixels_meters\ShipParametersInPixels.java

/*Max and min values of point coordinates. Uses axis X*/
package ua.edu.donntu.cs.service.transform_pixels_meters;

import ua.edu.donntu.cs.inout.IPrepareData;

/**
 * Этот класс определяет длину корабля в пикселах. Разница между самым большим и
 * самым малым значением по иксу является основой для перевода из метров в
 * пикселы и наоборот
 * 
 * @author Denis Vodolazskiy
 * 
 */
public class ShipParametersInPixels implements IPrepareData {
	private int minPixX = 0;// -4905;
	private int maxPixX = 0;// 4728;

	public ShipParametersInPixels() {
		for (int i = 0; i < Q_POINTS; i++) {
			if (points[i][0] < minPixX) {
				minPixX = points[i][0];
			}
			if (points[i][0] > maxPixX) {
				maxPixX = points[i][0];
			}
		}
	}

	public int getMinPixX() {
		return minPixX;
	}

	public int getMaxPixX() {
		return maxPixX;
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\data\cuSource\modelCalc.cu

extern "C"

__device__ float vxd(const float m,float Vy, float w, float ZpTei, float Xr, float Kvx)
{
	if (Vy > 0) {
            return ((m * Vy * w - Xr + ZpTei) * Kvx);
        } else {
            return ((m * Vy * w * 1.09f - Xr + ZpTei) * Kvx);//Vx*1.061 ;N0=3;k11=580.91f Ubuntu
            //return ((m * Vy * w  - Xr + ZpTei) * Kvx);
        }//*1.1045; k11=5.91f windows ; 1.09; k11=580.91f
}

extern "C"

__device__ float vyd(const float m,float Vx, float w, float ZpYri, float Yr, float Kvy) {
        if (Vx > 0) {
            return ((Yr - ZpYri - m * Vx * w * 1.0165f) * Kvy);//Vx*1.0179
            //return ((Yr - ZpYri - m * Vx * w) * Kvy);
        } else {//*1.0165; k11=5.91f windows
            return ((Yr - ZpYri - m * Vx * w) * Kvy);
        }
    }
extern "C"

__device__ float wd(const float lr,float Mr, float ZpYri, float Yr, float Kw) {
        return ((Mr + lr * ZpYri) * Kw);
    }
	
extern "C"

__global__ void modelCalc(float* VX, float* VY, float* ww, float* X, float* Y,
float* W, float* Xobs, float* Yobs, float T, float L, float B,float m,float lr,float Vx, float Vy,
float v,float w, const int size,const int nShips) 
{ 
int j = blockDim.x * blockIdx.x + threadIdx.x; 
if (j<nShips){
		float k11, k22, k66, k26;
        
        const float delta = 0.7f;//����������� ����� �������
        float c1, c2, c3, m1, m2;//����������� �.�.�������
        float w_ = 0.0f;//���� ������						approx
        float betta_d = 0.0f;//���� ������ � ������ ������� (rad)
        float Cxr, Cyr, Cmr;//������������ Cxr, ������� ����, �������
        //	float L1=B,T1=L/2;//�����, ��������� ������������� ����� ????????????????????
        const float p = 1000.0f;//��������� ����
        float Xr, Yr, Mr;//����������������� ������
        float ZpTei = 0;//�������� ���� ������ ��� ����������� ������������� �������� =R+Xa
        float Jz;//������ ������� ����� ����� ������������ ��� Gz
        float ZpYri;//������� ���� ��� 
        const float a66 = 0.31f;//�������� �����������
        //float Ramp = 0.0f;//��� ��������� �����
        const float lyamdaR = 1.4f;//��������� c 335 //0.5--1.4 //1
        
        const float deltaR = 0.349f;//���� ���������� ����  - 20% //0.349f
        
//	float Va;//�������� ��������� ���� �� ����
        float Yri, Ysi;//������� � ��������������� ����
        const float Ar = 6.0f;//������� ������//5 ����� ���������
        const float D = 1.5f;//������� ����� �����//2 ����� ���������
        const float Cta = 10.0f, Ctt = 50.0f;//c 334 //Cta<=20, 0.5--30, Ctt<=20, 1--50 UP!!!
        //Ctt =30
        float Kvx, Kvy, Kw;//����������� ��� �����������
        const float No = 3.0f;//������� ��������� //������//3 �������
        const float Re = 5000000.0f;//����� ��������� >5E8
        float K_betta;
        float fit;
        const float xk = 1.0f;
        const float bettar = 0.9f;
        const float fik = 0.95f;
        float ld_;//������������� ����� ������� c228
        float betta_D;//����������� ����������
        float fiD;//c 338
        float CyD1;
        float CyD;
        float A0;//������� ����� �����
        float xD;//c 339
        float viv = 0.0f;//���� ��� ����������� ������� ��������� � 27 ch3_2
		float Rmatr[3][3]={cosf(viv),-sinf(viv),0.0f,sinf(viv),cosf(viv),0.0f,0.0f,0.0f,1.0f};
		 //------------------------------------------------------------
//c 330         5.91-� �����, 580.91 - ��������� �
        k11 = (580.91f * (float) pow(B / L, 2.0f) + 7.76f * (B / L) - 0.259f) / (48.4f - 6.89f * (B / T) + 1.47f * (float) pow(B / T, 2.0f) - 0.0475f * (float) pow(B / T, 3.0f));

        k22 = ((0.722f + 0.224f * delta) * (1.022f - (float) pow(B / L, 2.0f))) / (0.264f + 0.368f * (B / T));
        k66 = (2.0f * T / B) * (2.59f + 0.781f * delta) * (0.357f - 1.77f * (float) pow(B / L, 2.0f));
        k26 = k22;
        //k26=0;       
//c 323
        c1 = 3.14f * (T / L) * (float) pow((0.63f / delta), (5.0f / 2.0f)) * (float) pow(L / (6.0f * B), (1.0f / 3.0f)) - 0.032f;
        c2 = -2.0f * k11 * delta * (B / L);
        c3 = 1.35f * (float) pow(T / B, (1.0f / 2.0f)) * (float) pow((0.63f / delta), (3.0f / 2.0f)) - 0.029f;
        m1 = 1.67f * (T / L) - 0.56f * delta + 0.43f;
        m2 = -0.44f * (T / L) - 0.0375f;
        // System.out.printf("c1=%f\tc2=%f\tc3=%f\tm1=%f\tm2=%f\n", c1, c2, c3, m1, m2);
        Jz = (m * (float) pow(L, 2.0f) / 12.4f) * (0.463f + 0.574f * (float) pow(delta, a66) + (float) pow(B / L, 2.0f));//c 330
        
        Kvx = 1 / (m * (1 + k11));
        Kvy = 1 / (m * (1 + k22));
        Kw = 1 / (Jz * (1 + k66));//????? m        
//----------------------------------------------------------------
        float k1, k2, k3, k4;
        float q1, q2, q3, q4;
        float z1, z2, z3, z4;
        float j1, j2, j3, j4;
        //t = 0.0f; // ��� �������		
        int t = 0;
        float h = 1.0f;		
		for (int i = 0; i < size; i++) {	//16550
                v = (float) sqrt((float) pow(Vx, 2.0f) + (float) pow(Vy, 2.0f));
                //assert(Vx==0);
                if (Vx != 0) {
				//c 353 ?????????????????????????
                    w_ = w * L / v;//??????????????????????
                    betta_d = -(float) atan(Vy / Vx);//c 350
                } else {
                    w_ = w * L / v;
                    //betta_d = 0;
                    betta_d = -(float) atan(Vy / Vx);//c 350
                }
                
                Cxr = 0.01f * (1.0f + 170.0f * (T / L));// ��� ����� c 119
                Cyr = c1 * betta_d + c2 * w_ + c3 * betta_d * abs(betta_d);//c 323
                Cmr = m1 * betta_d + m2 * w_;

                Xr = Cxr * L * T * (float) pow(v, 2.0f) * p / 2.0f;//c 320
                Yr = Cyr * L * T * (float) pow(v, 2.0f) * p / 2.0f;
                Mr = Cmr * L * T * (float) pow(v, 2.0f) * p / 2.0f;

                K_betta = 0.43f * (float) pow(Ctt, -0.6f);
                fit = (float) pow(1.0f + Ctt, 0.508f);
                //IMPORTANT!!!  deltaR
                Yri = 3.14f * (deltaR - K_betta * xk * (betta_d + lr * w_)) * p * Ar * (float) pow(v * fik * fit, 2.0f) / (1.0f + 2.2f / (float) pow(lyamdaR, 2.0f / 3.0f));

                ld_ = 0.77f - 0.125f * (float) sqrt(Ctt) / (1.65f * (float) sqrt(Ctt) - 1.0f);
                betta_D = 1.22f - 0.0563f * (float) sqrt(Ctt) / (1.65f * (float) sqrt(Ctt) - 1.0f);
                fiD = 0.5f * ((float) sqrt(1.0f + 2.0f * Ctt / betta_D) + 1.0f);

                CyD1 = 12.0f * ld_ / (1.0f + 1.56f * ld_);
                CyD = CyD1 + 2.0f * betta_D * (float) pow(fiD, 2.0f);
                xD = xk * (CyD1 + 2.0f * betta_D * fiD) / (CyD1 + 2.0f * betta_D * (float) pow(fiD, 2.0f));
                A0 = 3.14f * (float) pow(D, 2.0f) / 4.0f;
                Ysi = CyD * (xD - 0.02f * xk) * (betta_d + lr * w_) * (p / 2.0f) * A0 * (float) pow(v, 2.0f) * (float) pow(fik, 2.0f);                
                ZpTei = 1000000.0f * (9.740f * (float) pow(No, 2.0f) - 2.23f * v); //�������//9.740f                
                ZpYri = 2.0f * (Yri - Ysi);//2 �����
               
                k1 = h * vxd(m,Vy, w, ZpTei, Xr, Kvx);
                q1 = h * vyd(m,Vx, w, ZpYri, Yr, Kvy);
                z1 = h * wd(lr,Mr, ZpTei, Yr, Kw);

                k2 = h * vxd(m,Vy + q1 / 2.0f, w + z1 / 2.0f, ZpTei, Xr, Kvx);
                q2 = h * vyd(m,Vx + k1 / 2.0f, w + z1 / 2.0f, ZpYri, Yr, Kvy);
                z2 = h * wd(lr,Mr, ZpYri, Yr, Kw);

                k3 = h * vxd(m,Vy + q2 / 2.0f, w + z2 / 2.0f, ZpTei, Xr, Kvx);
                q3 = h * vyd(m,Vx + k2 / 2.0f, w + z2 / 2.0f, ZpYri, Yr, Kvy);
                z3 = h * wd(lr,Mr, ZpYri, Yr, Kw);

                k4 = h * vxd(m,Vy + q3, w + z3, ZpTei, Xr, Kvx);
                q4 = h * vyd(m,Vx + k3, w + z3, ZpYri, Yr, Kvy);
                z4 = h * wd(lr,Mr, ZpYri, Yr, Kw);

                Vx = Vx + (1.0f / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
                //VX[t] = Vx / 1.24f;
                VX[t] = Vx;
                Vy = Vy + (1.0f / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
                VY[t] = Vy;
                w = w + (1.0f / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);
                ww[t] = w;

//---������ ��������-----------------------------------------
                k1 = h * vxd(m,Vy, w, ZpTei, Xr, Kvx);
                q1 = h * vyd(m,Vx, w, ZpYri, Yr, Kvy);
                z1 = h * wd(lr,Mr, ZpTei, Yr, Kw);

                k2 = h * vxd(m,Vy + q1 / 2.0f, w + z1 / 2.0f, ZpTei, Xr, Kvx);
                q2 = h * vyd(m,Vx + k1 / 2.0f, w + z1 / 2.0f, ZpYri, Yr, Kvy);
                z2 = h * wd(lr,Mr, ZpYri, Yr, Kw);

                k3 = h * vxd(m,Vy + q2 / 2.0f, w + z2 / 2.0f, ZpTei, Xr, Kvx);
                q3 = h * vyd(m,Vx + k2 / 2.0f, w + z2 / 2.0f, ZpYri, Yr, Kvy);
                z3 = h * wd(lr,Mr, ZpYri, Yr, Kw);

                k4 = h * vxd(m,Vy + q3, w + z3, ZpTei, Xr, Kvx);
                q4 = h * vyd(m,Vx + k3, w + z3, ZpYri, Yr, Kvy);
                z4 = h * wd(lr,Mr, ZpYri, Yr, Kw);

                X[t] = Vx + (1.0f / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
                Y[t] = Vy + (1.0f / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
                W[t] = w + (1.0f / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);                
                //���� ��� ����������� ������� ���������                
                viv = W[t];                                
                //-------
                Rmatr[0][0] = (float)cos(viv);
                Rmatr[0][1] = -(float)sin(viv);
                Rmatr[1][0] = (float)sin(viv);
                Rmatr[1][1] = (float)cos(viv);
                Xobs[t] = Rmatr[0][0] * X[t] + Rmatr[0][1] * Y[t];
                Yobs[t] = Rmatr[1][0] * X[t] + Rmatr[1][1] * Y[t];                
                //----------
                t++;               
                       
        }
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\data\cuSource\obtainPolygons.cu

extern "C"
#define n (3)
#define qPoints (58)
#define qPolygons (96)
__global__ void obtainPolygons(int* dev_S,int* dev_polygonToFillX,int* dev_polygonToFillY,int* dev_shipLocationX,
int* dev_shipLocationZ,float* dev_matrixC,int* dev_points,int* dev_polygons,int* dev_normals,const int N)
{	
	int j = threadIdx.x;
	if (j<N){		
		//__shared__ 
		float observerCoord[3*qPoints];
		for (int i = 0; i < qPoints; i++) {
			observerCoord[3*i] = (dev_points[3*i]+dev_shipLocationX[j]) * dev_matrixC[0] + dev_points[3*i+1]
			* dev_matrixC[1] + (dev_points[3*i+2]+dev_shipLocationZ[j]) * dev_matrixC[2] +dev_matrixC[3];			
			observerCoord[3*i+1] = (dev_points[3*i]+dev_shipLocationX[j]) * dev_matrixC[4] + dev_points[3*i+1]
			* dev_matrixC[5] + (dev_points[3*i+2]+dev_shipLocationZ[j]) * dev_matrixC[6] + dev_matrixC[7];
			observerCoord[3*i+2] = (dev_points[3*i]+dev_shipLocationX[j]) * dev_matrixC[8] + dev_points[3*i+1]
			* dev_matrixC[9] + (dev_points[3*i+2]+dev_shipLocationZ[j]) * dev_matrixC[10] + dev_matrixC[11];
		}
		int xp[qPoints];
		int yp[qPoints];
		for (int i = 0; i < qPoints; i++) {
			xp[i] = (int) (4.35f * 160 * 0.6f * observerCoord[3*i+2] / observerCoord[3*i]) + 350;
			yp[i] = -(int) (4.35f * 160 * 0.6f * observerCoord[3*i+1] / observerCoord[3*i]) + 350;
		}		
		for (int i = 0; i < qPolygons; i++) {
			if (
				(
				(dev_normals[3*i] * dev_matrixC[0] + dev_normals[3*i+1] * dev_matrixC[1] + dev_normals[3*i+2] * dev_matrixC[2]) * 
				observerCoord[3*dev_polygons[3*i]] + 
				(dev_normals[3*i] * dev_matrixC[4] + dev_normals[3*i+1]* dev_matrixC[5] + dev_normals[3*+2] * dev_matrixC[6]) * 
				observerCoord[3*dev_polygons[3*i]+1] + 
				(dev_normals[3*i] * dev_matrixC[8] + dev_normals[3*i+1]	* dev_matrixC[9] + dev_normals[3*i+2] * dev_matrixC[10]) *
				observerCoord[3*dev_polygons[3*i]+2])<0){
					dev_S[j*qPolygons+i]=1;
			}
			else {
			dev_S[j*qPolygons+i]=0;
			}
		}
		for (int i = 0; i < qPolygons; i++) {
			dev_polygonToFillX[j*qPolygons*n+3*i] = xp[dev_polygons[3*i]];
			dev_polygonToFillX[j*qPolygons*n+3*i+1] = xp[dev_polygons[3*i+1]];
			dev_polygonToFillX[j*qPolygons*n+3*i+2] = xp[dev_polygons[3*i+2]];
			dev_polygonToFillY[j*qPolygons*n+3*i] = yp[dev_polygons[3*i]];
			dev_polygonToFillY[j*qPolygons*n+3*i+1] = yp[dev_polygons[3*i+1]];
			dev_polygonToFillY[j*qPolygons*n+3*i+2] = yp[dev_polygons[3*i+2]];
		}			
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\data\cuSource\obtainPolygonsDOUBLE.cu

extern "C"
#define n (3)
#define qPoints (58)
#define qPolygons (96)
__global__ void obtainPolygonsDOUBLE(int* dev_S,int* dev_polygonToFillX,int* dev_polygonToFillY,int* dev_shipLocationX,
int* dev_shipLocationZ,double* dev_matrixC,int* dev_points,int* dev_polygons,int* dev_normals,const int N)
{	
	int j = threadIdx.x;
	if (j<N){				
		double observerCoord[3*qPoints];
		for (int i = 0; i < qPoints; i++) {
			observerCoord[3*i] = (dev_points[3*i]+dev_shipLocationX[j]) * dev_matrixC[0] + dev_points[3*i+1]
			* dev_matrixC[1] + (dev_points[3*i+2]+dev_shipLocationZ[j]) * dev_matrixC[2] +dev_matrixC[3];			
			observerCoord[3*i+1] = (dev_points[3*i]+dev_shipLocationX[j]) * dev_matrixC[4] + dev_points[3*i+1]
			* dev_matrixC[5] + (dev_points[3*i+2]+dev_shipLocationZ[j]) * dev_matrixC[6] + dev_matrixC[7];
			observerCoord[3*i+2] = (dev_points[3*i]+dev_shipLocationX[j]) * dev_matrixC[8] + dev_points[3*i+1]
			* dev_matrixC[9] + (dev_points[3*i+2]+dev_shipLocationZ[j]) * dev_matrixC[10] + dev_matrixC[11];
		}
		int xp[qPoints];
		int yp[qPoints];
		for (int i = 0; i < qPoints; i++) {
			xp[i] = (int) (4.35f * 160 * 0.6f * observerCoord[3*i+2] / observerCoord[3*i]) + 350;
			yp[i] = -(int) (4.35f * 160 * 0.6f * observerCoord[3*i+1] / observerCoord[3*i]) + 350;
		}		
		for (int i = 0; i < qPolygons; i++) {
			if (
				(
				(dev_normals[3*i] * dev_matrixC[0] + dev_normals[3*i+1] * dev_matrixC[1] + dev_normals[3*i+2] * dev_matrixC[2]) * 
				observerCoord[3*dev_polygons[3*i]] + 
				(dev_normals[3*i] * dev_matrixC[4] + dev_normals[3*i+1]* dev_matrixC[5] + dev_normals[3*+2] * dev_matrixC[6]) * 
				observerCoord[3*dev_polygons[3*i]+1] + 
				(dev_normals[3*i] * dev_matrixC[8] + dev_normals[3*i+1]	* dev_matrixC[9] + dev_normals[3*i+2] * dev_matrixC[10]) *
				observerCoord[3*dev_polygons[3*i]+2])<0){
					dev_S[j*qPolygons+i]=1;
			}
			else {
			dev_S[j*qPolygons+i]=0;
			}
		}
		for (int i = 0; i < qPolygons; i++) {
			dev_polygonToFillX[j*qPolygons*n+3*i] = xp[dev_polygons[3*i]];
			dev_polygonToFillX[j*qPolygons*n+3*i+1] = xp[dev_polygons[3*i+1]];
			dev_polygonToFillX[j*qPolygons*n+3*i+2] = xp[dev_polygons[3*i+2]];
			dev_polygonToFillY[j*qPolygons*n+3*i] = yp[dev_polygons[3*i]];
			dev_polygonToFillY[j*qPolygons*n+3*i+1] = yp[dev_polygons[3*i+1]];
			dev_polygonToFillY[j*qPolygons*n+3*i+2] = yp[dev_polygons[3*i+2]];
		}			
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\data\cuSource\obtainPolygonsSteps.cu

extern "C"
#define n (3)
#define qPoints (58)
#define qPolygons (96)
__global__ void obtainPolygonsSteps(int* dev_S,int* dev_polygonToFillX,int* dev_polygonToFillY,int* dev_shipLocationX,
int* dev_shipLocationZ,float* dev_matrixC,int* dev_points,int* dev_polygons,int* dev_normals,const int N)
{	
	int j = threadIdx.x;
	if (j<N){		
		//__shared__ 
		float observerCoord[3*qPoints];
		for (int i = 0; i < qPoints; i++) {
			observerCoord[3*i] = (dev_points[3*i]+dev_shipLocationX[j]) * dev_matrixC[0] + dev_points[3*i+1]
			* dev_matrixC[1] + (dev_points[3*i+2]+dev_shipLocationZ[j]) * dev_matrixC[2] +dev_matrixC[3];			
			observerCoord[3*i+1] = (dev_points[3*i]+dev_shipLocationX[j]) * dev_matrixC[4] + dev_points[3*i+1]
			* dev_matrixC[5] + (dev_points[3*i+2]+dev_shipLocationZ[j]) * dev_matrixC[6] + dev_matrixC[7];
			observerCoord[3*i+2] = (dev_points[3*i]+dev_shipLocationX[j]) * dev_matrixC[8] + dev_points[3*i+1]
			* dev_matrixC[9] + (dev_points[3*i+2]+dev_shipLocationZ[j]) * dev_matrixC[10] + dev_matrixC[11];
		}
		/*
		float to2d[2*qPoints];
		for (int i = 0; i < qPoints; i++) {
			to2d[2*i] = 0.6 * observerCoord[3*i+2] / observerCoord[3*i];
			to2d[2*i+1] = 0.6 * observerCoord[3*i+1] / observerCoord[3*i];
		}
		// ---------------to2dmm----------------------------------------------
		double to2dmm[2*qPoints];
		for (int i = 0; i < qPoints; i++) {
			to2dmm[2*i] = 160 * to2d[2*i];
			to2dmm[2*i+1] = 160 * to2d[2*i+1];
		}
		// -----------------------spX, spY--------------------------------------
		int spX[qPoints];
		int spY[qPoints];
		for (int i = 0; i < qPoints; i++) {
			spX[i] = (int) (4.35 * to2dmm[2*i]);
			spY[i] = (int)(4.35 * to2dmm[2*i+1]);
		}
		int xp[qPoints];
		int yp[qPoints];
		for (int i = 0; i < qPoints; i++) {
			xp[i] = spX[i] + 350;
			yp[i] = -spY[i] + 350;
		}	*/	
		int xp[qPoints];
		int yp[qPoints];
		for (int i = 0; i < qPoints; i++) {
			xp[i] = (int) (4.35f * 160 * 0.6f * observerCoord[3*i+2] / observerCoord[3*i]) + 350;
			yp[i] = -(int) (4.35f * 160 * 0.6f * observerCoord[3*i+1] / observerCoord[3*i]) + 350;
		}
		float NormalObs[3*qPolygons];
		for (int i = 0; i < qPolygons; i++) {
			NormalObs[3*i] = dev_normals[3*i] * dev_matrixC[0] + dev_normals[3*i+1]
					* dev_matrixC[1] + dev_normals[3*i+2] * dev_matrixC[2];
			NormalObs[3*i+1] = dev_normals[3*i] * dev_matrixC[4] + dev_normals[3*i+1]
					* dev_matrixC[5] + dev_normals[3*i+2] *dev_matrixC[6];
			NormalObs[3*i+2] = dev_normals[3*i] * dev_matrixC[8] + dev_normals[3*i+1]
					* dev_matrixC[9] + dev_normals[3*i+2] * dev_matrixC[10];
		}
		for (int i = 0; i < qPolygons; i++) {
			if (
				(
				NormalObs[3*i] * observerCoord[3*dev_polygons[3*i]] + NormalObs[3*i+1]
					*observerCoord[3*dev_polygons[3*i]+1] + NormalObs[3*i+2]
					* observerCoord[3*dev_polygons[3*i]+2]
				)<0){
					dev_S[j*qPolygons+i]=1;
			}
			else {
			dev_S[j*qPolygons+i]=0;
			}
		}
		for (int i = 0; i < qPolygons; i++) {
			dev_polygonToFillX[j*qPolygons*n+3*i] = xp[dev_polygons[3*i]];
			dev_polygonToFillX[j*qPolygons*n+3*i+1] = xp[dev_polygons[3*i+1]];
			dev_polygonToFillX[j*qPolygons*n+3*i+2] = xp[dev_polygons[3*i+2]];
			dev_polygonToFillY[j*qPolygons*n+3*i] = yp[dev_polygons[3*i]];
			dev_polygonToFillY[j*qPolygons*n+3*i+1] = yp[dev_polygons[3*i+1]];
			dev_polygonToFillY[j*qPolygons*n+3*i+2] = yp[dev_polygons[3*i+2]];
		}			
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\data\cuSource\ParallelFullCalcCuda.cu

#define size (8000)
extern "C"

__device__ float vxd(const float m,float Vy, float w, float ZpTei, float Xr, float Kvx)
{
	if (Vy > 0) {
            return ((m * Vy * w - Xr + ZpTei) * Kvx);
        } else {
            return ((m * Vy * w * 1.09f - Xr + ZpTei) * Kvx);//Vx*1.061 ;N0=3;k11=580.91f Ubuntu
            //return ((m * Vy * w  - Xr + ZpTei) * Kvx);
        }//*1.1045; k11=5.91f windows ; 1.09; k11=580.91f
}

extern "C"

__device__ float vyd(const float m,float Vx, float w, float ZpYri, float Yr, float Kvy) {
        if (Vx > 0) {
            return ((Yr - ZpYri - m * Vx * w * 1.0165f) * Kvy);//Vx*1.0179
            //return ((Yr - ZpYri - m * Vx * w) * Kvy);
        } else {//*1.0165; k11=5.91f windows
            return ((Yr - ZpYri - m * Vx * w) * Kvy);
        }
    }
extern "C"

__device__ float wd(const float lr,float Mr, float ZpYri, float Yr, float Kw) {
        return ((Mr + lr * ZpYri) * Kw);
    }
	
extern "C"

__global__ void ParallelFullCalcCuda(float* VX, float* VY, float* ww, float* X, float* Y,
float* W, float* Xobs, float* Yobs,const int nShips) 
{ 
int j = blockDim.x * blockIdx.x + threadIdx.x; 
if (j<nShips){
		float k11, k22, k66, k26;
        
		float devVX[size];
		float devVY[size];
		float devww[size];
		float devX[size];
		float devY[size];
		float devW[size];
		float devXobs[size];
		float devYobs[size];
		
		const float T = 4.0f;
		const float L = 80.0f;
		const float B = 15.0f;// ������, �����, ������
															// c 323, 321
		const float m = 20000000000.0f; // ����� �����
		const float lr = 40.0f; // ���������� �� ��� �� �� �����
		float Vx = 5.0f, Vy = 0.0f;// �������� �� ����
		float v = 0.0f, w = 0.0f;// �������� � ������� ��������
		
        const float delta = 0.7f;//����������� ����� �������
        float c1, c2, c3, m1, m2;//����������� �.�.�������
        float w_ = 0.0f;//���� ������						approx
        float betta_d = 0.0f;//���� ������ � ������ ������� (rad)
        float Cxr, Cyr, Cmr;//������������ Cxr, ������� ����, �������
        //	float L1=B,T1=L/2;//�����, ��������� ������������� ����� ????????????????????
        const float p = 1000.0f;//��������� ����
        float Xr, Yr, Mr;//����������������� ������
        float ZpTei = 0;//�������� ���� ������ ��� ����������� ������������� �������� =R+Xa
        float Jz;//������ ������� ����� ����� ������������ ��� Gz
        float ZpYri;//������� ���� ��� 
        const float a66 = 0.31f;//�������� �����������
        //float Ramp = 0.0f;//��� ��������� �����
        const float lyamdaR = 1.4f;//��������� c 335 //0.5--1.4 //1
        
        const float deltaR = 0.349f;//���� ���������� ����  - 20% //0.349f
        
//	float Va;//�������� ��������� ���� �� ����
        float Yri, Ysi;//������� � ��������������� ����
        const float Ar = 6.0f;//������� ������//5 ����� ���������
        const float D = 1.5f;//������� ����� �����//2 ����� ���������
        const float Cta = 10.0f, Ctt = 50.0f;//c 334 //Cta<=20, 0.5--30, Ctt<=20, 1--50 UP!!!
        //Ctt =30
        float Kvx, Kvy, Kw;//����������� ��� �����������
        const float No = 3.0f;//������� ��������� //������//3 �������
        const float Re = 5000000.0f;//����� ��������� >5E8
        float K_betta;
        float fit;
        const float xk = 1.0f;
        const float bettar = 0.9f;
        const float fik = 0.95f;
        float ld_;//������������� ����� ������� c228
        float betta_D;//����������� ����������
        float fiD;//c 338
        float CyD1;
        float CyD;
        float A0;//������� ����� �����
        float xD;//c 339
        float viv = 0.0f;//���� ��� ����������� ������� ��������� � 27 ch3_2
		float Rmatr[3][3]={cosf(viv),-sinf(viv),0.0f,sinf(viv),cosf(viv),0.0f,0.0f,0.0f,1.0f};
		 //------------------------------------------------------------
//c 330         5.91-� �����, 580.91 - ��������� �
        k11 = (580.91f * (float) pow(B / L, 2.0f) + 7.76f * (B / L) - 0.259f) / (48.4f - 6.89f * (B / T) + 1.47f * (float) pow(B / T, 2.0f) - 0.0475f * (float) pow(B / T, 3.0f));

        k22 = ((0.722f + 0.224f * delta) * (1.022f - (float) pow(B / L, 2.0f))) / (0.264f + 0.368f * (B / T));
        k66 = (2.0f * T / B) * (2.59f + 0.781f * delta) * (0.357f - 1.77f * (float) pow(B / L, 2.0f));
        k26 = k22;
        //k26=0;       
//c 323
        c1 = 3.14f * (T / L) * (float) pow((0.63f / delta), (5.0f / 2.0f)) * (float) pow(L / (6.0f * B), (1.0f / 3.0f)) - 0.032f;
        c2 = -2.0f * k11 * delta * (B / L);
        c3 = 1.35f * (float) pow(T / B, (1.0f / 2.0f)) * (float) pow((0.63f / delta), (3.0f / 2.0f)) - 0.029f;
        m1 = 1.67f * (T / L) - 0.56f * delta + 0.43f;
        m2 = -0.44f * (T / L) - 0.0375f;
        // System.out.printf("c1=%f\tc2=%f\tc3=%f\tm1=%f\tm2=%f\n", c1, c2, c3, m1, m2);
        Jz = (m * (float) pow(L, 2.0f) / 12.4f) * (0.463f + 0.574f * (float) pow(delta, a66) + (float) pow(B / L, 2.0f));//c 330
        
        Kvx = 1 / (m * (1 + k11));
        Kvy = 1 / (m * (1 + k22));
        Kw = 1 / (Jz * (1 + k66));//????? m        
//----------------------------------------------------------------
        float k1, k2, k3, k4;
        float q1, q2, q3, q4;
        float z1, z2, z3, z4;
        float j1, j2, j3, j4;
        //t = 0.0f; // ��� �������		
        int t = 0;
        float h = 1.0f;		
		for (int i = 0; i < size; i++) {	//16550
                v = (float) sqrt((float) pow(Vx, 2.0f) + (float) pow(Vy, 2.0f));
                //assert(Vx==0);
                if (Vx != 0) {
				//c 353 ?????????????????????????
                    w_ = w * L / v;//??????????????????????
                    betta_d = -(float) atan(Vy / Vx);//c 350
                } else {
                    w_ = w * L / v;
                    //betta_d = 0;
                    betta_d = -(float) atan(Vy / Vx);//c 350
                }
                
                Cxr = 0.01f * (1.0f + 170.0f * (T / L));// ��� ����� c 119
                Cyr = c1 * betta_d + c2 * w_ + c3 * betta_d * abs(betta_d);//c 323
                Cmr = m1 * betta_d + m2 * w_;

                Xr = Cxr * L * T * (float) pow(v, 2.0f) * p / 2.0f;//c 320
                Yr = Cyr * L * T * (float) pow(v, 2.0f) * p / 2.0f;
                Mr = Cmr * L * T * (float) pow(v, 2.0f) * p / 2.0f;

                K_betta = 0.43f * (float) pow(Ctt, -0.6f);
                fit = (float) pow(1.0f + Ctt, 0.508f);
                //IMPORTANT!!!  deltaR
                Yri = 3.14f * (deltaR - K_betta * xk * (betta_d + lr * w_)) * p * Ar * (float) pow(v * fik * fit, 2.0f) / (1.0f + 2.2f / (float) pow(lyamdaR, 2.0f / 3.0f));

                ld_ = 0.77f - 0.125f * (float) sqrt(Ctt) / (1.65f * (float) sqrt(Ctt) - 1.0f);
                betta_D = 1.22f - 0.0563f * (float) sqrt(Ctt) / (1.65f * (float) sqrt(Ctt) - 1.0f);
                fiD = 0.5f * ((float) sqrt(1.0f + 2.0f * Ctt / betta_D) + 1.0f);

                CyD1 = 12.0f * ld_ / (1.0f + 1.56f * ld_);
                CyD = CyD1 + 2.0f * betta_D * (float) pow(fiD, 2.0f);
                xD = xk * (CyD1 + 2.0f * betta_D * fiD) / (CyD1 + 2.0f * betta_D * (float) pow(fiD, 2.0f));
                A0 = 3.14f * (float) pow(D, 2.0f) / 4.0f;
                Ysi = CyD * (xD - 0.02f * xk) * (betta_d + lr * w_) * (p / 2.0f) * A0 * (float) pow(v, 2.0f) * (float) pow(fik, 2.0f);                
                ZpTei = 1000000.0f * (9.740f * (float) pow(No, 2.0f) - 2.23f * v); //�������//9.740f                
                ZpYri = 2.0f * (Yri - Ysi);//2 �����
               
                k1 = h * vxd(m,Vy, w, ZpTei, Xr, Kvx);
                q1 = h * vyd(m,Vx, w, ZpYri, Yr, Kvy);
                z1 = h * wd(lr,Mr, ZpTei, Yr, Kw);

                k2 = h * vxd(m,Vy + q1 / 2.0f, w + z1 / 2.0f, ZpTei, Xr, Kvx);
                q2 = h * vyd(m,Vx + k1 / 2.0f, w + z1 / 2.0f, ZpYri, Yr, Kvy);
                z2 = h * wd(lr,Mr, ZpYri, Yr, Kw);

                k3 = h * vxd(m,Vy + q2 / 2.0f, w + z2 / 2.0f, ZpTei, Xr, Kvx);
                q3 = h * vyd(m,Vx + k2 / 2.0f, w + z2 / 2.0f, ZpYri, Yr, Kvy);
                z3 = h * wd(lr,Mr, ZpYri, Yr, Kw);

                k4 = h * vxd(m,Vy + q3, w + z3, ZpTei, Xr, Kvx);
                q4 = h * vyd(m,Vx + k3, w + z3, ZpYri, Yr, Kvy);
                z4 = h * wd(lr,Mr, ZpYri, Yr, Kw);

                Vx = Vx + (1.0f / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
                //devVX[t] = Vx / 1.24f;
                devVX[t] = Vx;
                Vy = Vy + (1.0f / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
                devVY[t] = Vy;
                w = w + (1.0f / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);
                devww[t] = w;

//---������ ��������-----------------------------------------
                k1 = h * vxd(m,Vy, w, ZpTei, Xr, Kvx);
                q1 = h * vyd(m,Vx, w, ZpYri, Yr, Kvy);
                z1 = h * wd(lr,Mr, ZpTei, Yr, Kw);

                k2 = h * vxd(m,Vy + q1 / 2.0f, w + z1 / 2.0f, ZpTei, Xr, Kvx);
                q2 = h * vyd(m,Vx + k1 / 2.0f, w + z1 / 2.0f, ZpYri, Yr, Kvy);
                z2 = h * wd(lr,Mr, ZpYri, Yr, Kw);

                k3 = h * vxd(m,Vy + q2 / 2.0f, w + z2 / 2.0f, ZpTei, Xr, Kvx);
                q3 = h * vyd(m,Vx + k2 / 2.0f, w + z2 / 2.0f, ZpYri, Yr, Kvy);
                z3 = h * wd(lr,Mr, ZpYri, Yr, Kw);

                k4 = h * vxd(m,Vy + q3, w + z3, ZpTei, Xr, Kvx);
                q4 = h * vyd(m,Vx + k3, w + z3, ZpYri, Yr, Kvy);
                z4 = h * wd(lr,Mr, ZpYri, Yr, Kw);

                devX[t] = Vx + (1.0f / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
                devY[t] = Vy + (1.0f / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
                devW[t] = w + (1.0f / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);                
                //���� ��� ����������� ������� ���������                
                viv = devW[t];                                
                //-------
                Rmatr[0][0] = (float)cos(viv);
                Rmatr[0][1] = -(float)sin(viv);
                Rmatr[1][0] = (float)sin(viv);
                Rmatr[1][1] = (float)cos(viv);
                devXobs[t] = Rmatr[0][0] * devX[t] + Rmatr[0][1] * devY[t];
                devYobs[t] = Rmatr[1][0] * devX[t] + Rmatr[1][1] * devY[t];                
                //----------
                t++;               
                       
        }
		for (int i=0;i<size;i++){
			VX[j*size+i]=devVX[i];
			VY[j*size+i]=devVY[i];	
			ww[j*size+i]=devww[i];
			X[j*size+i]=devX[i];
			Y[j*size+i]=devY[i];
			W[j*size+i]=devW[i];
			Xobs[j*size+i]=devXobs[i];
			Yobs[j*size+i]=devYobs[i];
		}		
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\data\cuSource\ParallelRay.cu

D:\универ\3dmax\cudaJava_C\java\shipCuda10\data\cuSource\ParallelRay100.cu

D:\универ\3dmax\cudaJava_C\java\shipCuda10\data\cuSource\ParallelSpeedCalcCuda.cu

#define size (8000)
extern "C"

__device__ float vxd(const float m,float Vy, float w, float ZpTei, float Xr, float Kvx)
{
	if (Vy > 0) {
            return ((m * Vy * w - Xr + ZpTei) * Kvx);
        } else {
            return ((m * Vy * w * 1.09f - Xr + ZpTei) * Kvx);//Vx*1.061 ;N0=3;k11=580.91f Ubuntu
            //return ((m * Vy * w  - Xr + ZpTei) * Kvx);
        }//*1.1045; k11=5.91f windows ; 1.09; k11=580.91f
}

extern "C"

__device__ float vyd(const float m,float Vx, float w, float ZpYri, float Yr, float Kvy) {
        if (Vx > 0) {
            return ((Yr - ZpYri - m * Vx * w * 1.0165f) * Kvy);//Vx*1.0179
            //return ((Yr - ZpYri - m * Vx * w) * Kvy);
        } else {//*1.0165; k11=5.91f windows
            return ((Yr - ZpYri - m * Vx * w) * Kvy);
        }
    }
extern "C"

__device__ float wd(const float lr,float Mr, float ZpYri, float Yr, float Kw) {
        return ((Mr + lr * ZpYri) * Kw);
    }
	
extern "C"

__global__ void ParallelSpeedCalcCuda(float* VX, float* VY, float* ww, float* X, float* Y,
float* W, float* Xobs, float* Yobs,const int nShips) 
{ 
int j = blockDim.x * blockIdx.x + threadIdx.x; 
if (j<nShips){
		float k11, k22, k66, k26;
        
		float devVX[size];
		float devVY[size];
		float devww[size];
		float devX[size];
		float devY[size];
		float devW[size];
		float devXobs[size];
		float devYobs[size];
		
		const float T = 4.0f;
		const float L = 80.0f;
		const float B = 15.0f;// ������, �����, ������
															// c 323, 321
		const float m = 20000000000.0f; // ����� �����
		const float lr = 40.0f; // ���������� �� ��� �� �� �����
		float Vx = 5.0f, Vy = 0.0f;// �������� �� ����
		float v = 0.0f, w = 0.0f;// �������� � ������� ��������
		
        const float delta = 0.7f;//����������� ����� �������
        float c1, c2, c3, m1, m2;//����������� �.�.�������
        float w_ = 0.0f;//���� ������						approx
        float betta_d = 0.0f;//���� ������ � ������ ������� (rad)
        float Cxr, Cyr, Cmr;//������������ Cxr, ������� ����, �������
        //	float L1=B,T1=L/2;//�����, ��������� ������������� ����� ????????????????????
        const float p = 1000.0f;//��������� ����
        float Xr, Yr, Mr;//����������������� ������
        float ZpTei = 0;//�������� ���� ������ ��� ����������� ������������� �������� =R+Xa
        float Jz;//������ ������� ����� ����� ������������ ��� Gz
        float ZpYri;//������� ���� ��� 
        const float a66 = 0.31f;//�������� �����������
        //float Ramp = 0.0f;//��� ��������� �����
        const float lyamdaR = 1.4f;//��������� c 335 //0.5--1.4 //1
        
        const float deltaR = 0.349f;//���� ���������� ����  - 20% //0.349f
        
//	float Va;//�������� ��������� ���� �� ����
        float Yri, Ysi;//������� � ��������������� ����
        const float Ar = 6.0f;//������� ������//5 ����� ���������
        const float D = 1.5f;//������� ����� �����//2 ����� ���������
        const float Cta = 10.0f, Ctt = 50.0f;//c 334 //Cta<=20, 0.5--30, Ctt<=20, 1--50 UP!!!
        //Ctt =30
        float Kvx, Kvy, Kw;//����������� ��� �����������
        const float No = 3.0f;//������� ��������� //������//3 �������
        const float Re = 5000000.0f;//����� ��������� >5E8
        float K_betta;
        float fit;
        const float xk = 1.0f;
        const float bettar = 0.9f;
        const float fik = 0.95f;
        float ld_;//������������� ����� ������� c228
        float betta_D;//����������� ����������
        float fiD;//c 338
        float CyD1;
        float CyD;
        float A0;//������� ����� �����
        float xD;//c 339
        float viv = 0.0f;//���� ��� ����������� ������� ��������� � 27 ch3_2
		float Rmatr[3][3]={cosf(viv),-sinf(viv),0.0f,sinf(viv),cosf(viv),0.0f,0.0f,0.0f,1.0f};
		 //------------------------------------------------------------
//c 330         5.91-� �����, 580.91 - ��������� �
        k11 = (580.91f * (float) pow(B / L, 2.0f) + 7.76f * (B / L) - 0.259f) / (48.4f - 6.89f * (B / T) + 1.47f * (float) pow(B / T, 2.0f) - 0.0475f * (float) pow(B / T, 3.0f));

        k22 = ((0.722f + 0.224f * delta) * (1.022f - (float) pow(B / L, 2.0f))) / (0.264f + 0.368f * (B / T));
        k66 = (2.0f * T / B) * (2.59f + 0.781f * delta) * (0.357f - 1.77f * (float) pow(B / L, 2.0f));
        k26 = k22;
        //k26=0;       
//c 323
        c1 = 3.14f * (T / L) * (float) pow((0.63f / delta), (5.0f / 2.0f)) * (float) pow(L / (6.0f * B), (1.0f / 3.0f)) - 0.032f;
        c2 = -2.0f * k11 * delta * (B / L);
        c3 = 1.35f * (float) pow(T / B, (1.0f / 2.0f)) * (float) pow((0.63f / delta), (3.0f / 2.0f)) - 0.029f;
        m1 = 1.67f * (T / L) - 0.56f * delta + 0.43f;
        m2 = -0.44f * (T / L) - 0.0375f;
        // System.out.printf("c1=%f\tc2=%f\tc3=%f\tm1=%f\tm2=%f\n", c1, c2, c3, m1, m2);
        Jz = (m * (float) pow(L, 2.0f) / 12.4f) * (0.463f + 0.574f * (float) pow(delta, a66) + (float) pow(B / L, 2.0f));//c 330
        
        Kvx = 1 / (m * (1 + k11));
        Kvy = 1 / (m * (1 + k22));
        Kw = 1 / (Jz * (1 + k66));//????? m        
//----------------------------------------------------------------
        float k1, k2, k3, k4;
        float q1, q2, q3, q4;
        float z1, z2, z3, z4;
        float j1, j2, j3, j4;
        //t = 0.0f; // ��� �������		
        int t = 0;
        float h = 1.0f;		
		for (int i = 0; i < size; i++) {	//16550
                v = (float) sqrt((float) pow(Vx, 2.0f) + (float) pow(Vy, 2.0f));
                //assert(Vx==0);
                if (Vx != 0) {
				//c 353 ?????????????????????????
                    w_ = w * L / v;//??????????????????????
                    betta_d = -(float) atan(Vy / Vx);//c 350
                } else {
                    w_ = w * L / v;
                    //betta_d = 0;
                    betta_d = -(float) atan(Vy / Vx);//c 350
                }
                
                Cxr = 0.01f * (1.0f + 170.0f * (T / L));// ��� ����� c 119
                Cyr = c1 * betta_d + c2 * w_ + c3 * betta_d * abs(betta_d);//c 323
                Cmr = m1 * betta_d + m2 * w_;

                Xr = Cxr * L * T * (float) pow(v, 2.0f) * p / 2.0f;//c 320
                Yr = Cyr * L * T * (float) pow(v, 2.0f) * p / 2.0f;
                Mr = Cmr * L * T * (float) pow(v, 2.0f) * p / 2.0f;

                K_betta = 0.43f * (float) pow(Ctt, -0.6f);
                fit = (float) pow(1.0f + Ctt, 0.508f);
                //IMPORTANT!!!  deltaR
                Yri = 3.14f * (deltaR - K_betta * xk * (betta_d + lr * w_)) * p * Ar * (float) pow(v * fik * fit, 2.0f) / (1.0f + 2.2f / (float) pow(lyamdaR, 2.0f / 3.0f));

                ld_ = 0.77f - 0.125f * (float) sqrt(Ctt) / (1.65f * (float) sqrt(Ctt) - 1.0f);
                betta_D = 1.22f - 0.0563f * (float) sqrt(Ctt) / (1.65f * (float) sqrt(Ctt) - 1.0f);
                fiD = 0.5f * ((float) sqrt(1.0f + 2.0f * Ctt / betta_D) + 1.0f);

                CyD1 = 12.0f * ld_ / (1.0f + 1.56f * ld_);
                CyD = CyD1 + 2.0f * betta_D * (float) pow(fiD, 2.0f);
                xD = xk * (CyD1 + 2.0f * betta_D * fiD) / (CyD1 + 2.0f * betta_D * (float) pow(fiD, 2.0f));
                A0 = 3.14f * (float) pow(D, 2.0f) / 4.0f;
                Ysi = CyD * (xD - 0.02f * xk) * (betta_d + lr * w_) * (p / 2.0f) * A0 * (float) pow(v, 2.0f) * (float) pow(fik, 2.0f);                
                ZpTei = 1000000.0f * (9.740f * (float) pow(No, 2.0f) - 2.23f * v); //�������//9.740f                
                ZpYri = 2.0f * (Yri - Ysi);//2 �����
               
                k1 = h * vxd(m,Vy, w, ZpTei, Xr, Kvx);
                q1 = h * vyd(m,Vx, w, ZpYri, Yr, Kvy);
                z1 = h * wd(lr,Mr, ZpTei, Yr, Kw);

                k2 = h * vxd(m,Vy + q1 / 2.0f, w + z1 / 2.0f, ZpTei, Xr, Kvx);
                q2 = h * vyd(m,Vx + k1 / 2.0f, w + z1 / 2.0f, ZpYri, Yr, Kvy);
                z2 = h * wd(lr,Mr, ZpYri, Yr, Kw);

                k3 = h * vxd(m,Vy + q2 / 2.0f, w + z2 / 2.0f, ZpTei, Xr, Kvx);
                q3 = h * vyd(m,Vx + k2 / 2.0f, w + z2 / 2.0f, ZpYri, Yr, Kvy);
                z3 = h * wd(lr,Mr, ZpYri, Yr, Kw);

                k4 = h * vxd(m,Vy + q3, w + z3, ZpTei, Xr, Kvx);
                q4 = h * vyd(m,Vx + k3, w + z3, ZpYri, Yr, Kvy);
                z4 = h * wd(lr,Mr, ZpYri, Yr, Kw);

                Vx = Vx + (1.0f / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
                //devVX[t] = Vx / 1.24f;
                devVX[t] = Vx;
                Vy = Vy + (1.0f / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
                devVY[t] = Vy;
                w = w + (1.0f / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);
                devww[t] = w;

//---������ ��������-----------------------------------------
                k1 = h * vxd(m,Vy, w, ZpTei, Xr, Kvx);
                q1 = h * vyd(m,Vx, w, ZpYri, Yr, Kvy);
                z1 = h * wd(lr,Mr, ZpTei, Yr, Kw);

                k2 = h * vxd(m,Vy + q1 / 2.0f, w + z1 / 2.0f, ZpTei, Xr, Kvx);
                q2 = h * vyd(m,Vx + k1 / 2.0f, w + z1 / 2.0f, ZpYri, Yr, Kvy);
                z2 = h * wd(lr,Mr, ZpYri, Yr, Kw);

                k3 = h * vxd(m,Vy + q2 / 2.0f, w + z2 / 2.0f, ZpTei, Xr, Kvx);
                q3 = h * vyd(m,Vx + k2 / 2.0f, w + z2 / 2.0f, ZpYri, Yr, Kvy);
                z3 = h * wd(lr,Mr, ZpYri, Yr, Kw);

                k4 = h * vxd(m,Vy + q3, w + z3, ZpTei, Xr, Kvx);
                q4 = h * vyd(m,Vx + k3, w + z3, ZpYri, Yr, Kvy);
                z4 = h * wd(lr,Mr, ZpYri, Yr, Kw);

                devX[t] = Vx + (1.0f / 6.0f) * (k1 + 2.0f * k2 + 2.0f * k3 + k4);
                devY[t] = Vy + (1.0f / 6.0f) * (q1 + 2.0f * q2 + 2.0f * q3 + q4);
                devW[t] = w + (1.0f / 6.0f) * (z1 + 2.0f * z2 + 2.0f * z3 + z4);                
                //���� ��� ����������� ������� ���������                
                viv = devW[t];                                
                //-------
                Rmatr[0][0] = (float)cos(viv);
                Rmatr[0][1] = -(float)sin(viv);
                Rmatr[1][0] = (float)sin(viv);
                Rmatr[1][1] = (float)cos(viv);
                devXobs[t] = Rmatr[0][0] * devX[t] + Rmatr[0][1] * devY[t];
                devYobs[t] = Rmatr[1][0] * devX[t] + Rmatr[1][1] * devY[t];                
                //----------
                t++;               
                       
        }
		VX[j]=devVX[size-1];
		VY[j]=devVY[size-1];	
		ww[j]=devww[size-1];
		X[j]=devX[size-1];
		Y[j]=devY[size-1];
		W[j]=devW[size-1];
		Xobs[j]=devXobs[size-1];
		Yobs[j]=devYobs[size-1];		
	}
}
D:\универ\3dmax\cudaJava_C\java\shipCuda10\data\cuSource\TestNormalFull.cu

extern "C"

__device__ void createNewNormal(int* x, int* y, int* z,int* nX, int* nY, int* nZ, int i)
{
int j = 0;
nX[i]=0;
nY[i]=0;
nZ[i]=0;
        for (int k = 0; k < 3; k++) {
            if (k < 2) {
                j = k + 1;
                nX[i] += -(y[k] - y[j]) * (z[k] + z[j]);
                nY[i] += -(z[k] - z[j]) * (x[k] + x[j]);
                nZ[i] += -(x[k] - x[j]) * (y[k] + y[j]);
            } else {
                j = 0;
                nX[i] += -(y[k] - y[j]) * (z[k] + z[j]);
                nY[i] += -(z[k] - z[j]) * (x[k] + x[j]);
                nZ[i] += -(x[k] - x[j]) * (y[k] + y[j]);
            }
        }
//return x;
}

extern "C"

__device__ void createNewNormalSecond(int* x, int* y, int* z,int* nX, int* nY, int* nZ, int i)
{
int j = 0;
int bufX=0,bufY=0,bufZ=0; 
        for (int k = 0; k < 3; k++) {
            if (k < 2) {
                j = k + 1;
                bufX += -(y[k] - y[j]) * (z[k] + z[j]);
                bufY += -(z[k] - z[j]) * (x[k] + x[j]);
                bufZ += -(x[k] - x[j]) * (y[k] + y[j]);
            } else {
                j = 0;
                bufX += -(y[k] - y[j]) * (z[k] + z[j]);
                bufY += -(z[k] - z[j]) * (x[k] + x[j]);
                bufZ += -(x[k] - x[j]) * (y[k] + y[j]);
            }
        }
nX[i]=bufX;
nY[i]=bufY;
nZ[i]=bufZ;
}


extern "C"
__global__ void TestNormalFull(int* point, int*polygon, int* nX, int* nY, int* nZ, int N) 

{ 
int i = blockDim.x * blockIdx.x + threadIdx.x; 

if (i < N){
int xxx[3];
int yyy[3];
int zzz[3];
for (int j=0;j<3;j++)
{
  xxx[j]= point[3*polygon[3*i+j]];
  yyy[j]= point[3*polygon[3*i+j]+1];
  zzz[j]= point[3*polygon[3*i+j]+2];
}

/*
xxx[0]= point[3*polygon[3*i]];
xxx[1]= point[3*polygon[3*i+1]];
xxx[2]= point[3*polygon[3*i+2]];
yyy[0]= point[3*polygon[3*i]+1];
yyy[1]= point[3*polygon[3*i+1]+1];
yyy[2]= point[3*polygon[3*i+2]+1];
zzz[0]= point[3*polygon[3*i]+2];
zzz[1]= point[3*polygon[3*i+1]+2];
zzz[2]= point[3*polygon[3*i+2]+2];
*/

createNewNormal(xxx,yyy,zzz,nX,nY,nZ,i);
}
}
